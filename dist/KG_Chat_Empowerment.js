// ==UserScript==
// @name         KG_Chat_Empowerment
// @namespace    klavogonki
// @version      1.0.0
// @description  Enhance the chat abilities
// @author       Patcher
// @match        *://klavogonki.ru/g*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=klavogonki.ru
// @updateURL    https://raw.githubusercontent.com/VimiummuimiV/KG_Goddies/refs/heads/master/KG_Chat_Empowerment.js
// @downloadURL  https://raw.githubusercontent.com/VimiummuimiV/KG_Goddies/refs/heads/master/KG_Chat_Empowerment.js
// @grant        none
// ==/UserScript==

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.empowerment-button {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  width: 48px;\r\n  height: 48px;\r\n  cursor: pointer;\r\n  margin: 4px;\r\n  background-color: #212226;\r\n  border: 1px solid #45474b;\r\n}\r\n\r\n/* input error indication */\r\n.input-error {\r\n  transition: background-color 300ms ease-in-out;\r\n  background-color: #6b2f2f !important;\r\n}\r\n\r\n/* chat length popup on field type with dynamic movement horizontally */\r\n.length-field-popup {\r\n  position: absolute;\r\n  font: bold 12px Montserrat;\r\n  bottom: 40px;\r\n  transition: left 100ms ease-out;\r\n  height: 20px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  padding: 2px 4px;\r\n  margin: 2px;\r\n  opacity: 0;\r\n}\r\n\r\n.bounce-in {\r\n  animation: bounceIn 500ms forwards;\r\n}\r\n\r\n@keyframes bounceIn {\r\n  0% {\r\n    transform: translateY(0);\r\n    opacity: 0;\r\n  }\r\n\r\n  50% {\r\n    transform: translateY(-10px);\r\n    opacity: 1;\r\n  }\r\n\r\n  100% {\r\n    transform: translateY(0);\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n.bounce-out {\r\n  animation: bounceOut 500ms forwards;\r\n}\r\n\r\n@keyframes bounceOut {\r\n  0% {\r\n    transform: translateY(0);\r\n    opacity: 1;\r\n  }\r\n\r\n  50% {\r\n    transform: translateY(-10px);\r\n    opacity: 1;\r\n  }\r\n\r\n  100% {\r\n    transform: translateY(0);\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n/* catalogs panel && personal messages panel messages anchors color */\r\n.chat-logs-panel .message-text a,\r\n.cached-messages-panel .message-text a {\r\n  color: burlywood !important;\r\n  transition: color 0.15s ease-in-out;\r\n}\r\n\r\n.chat-logs-panel .message-text a:hover,\r\n.cached-messages-panel .message-text a:hover {\r\n  color: lightgoldenrodyellow !important;\r\n}\r\n\r\n/* Empowerment panel */\r\n.empowerment-panel {\r\n  position: fixed;\r\n  top: 60px;\r\n  right: 12px;\r\n  padding: 6px;\r\n  z-index: 1000;\r\n}\r\n\r\n/* Chat user count element */\r\n.chat-user-count {\r\n  filter: grayscale(100%);\r\n  transition: 0.2s ease-in-out;\r\n  font-family: 'Orbitron', sans-serif;\r\n  font-size: 24px;\r\n  color: #83cf40;\r\n  background-color: #2b4317;\r\n  width: 48px;\r\n  height: 48px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border: 1px solid #4b7328;\r\n  margin: 4px;\r\n}\r\n\r\n.pulse-effect {\r\n  animation: pulse 500ms ease-out;\r\n}\r\n\r\n@keyframes pulse {\r\n  0% {\r\n    filter: brightness(1);\r\n  }\r\n\r\n  50% {\r\n    filter: brightness(1.5);\r\n  }\r\n\r\n  100% {\r\n    filter: brightness(1);\r\n  }\r\n}\r\n\r\n.shake-effect {\r\n  animation: shake 500ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;\r\n}\r\n\r\n@keyframes shake {\r\n  0% {\r\n    transform: translateX(0);\r\n  }\r\n\r\n  10% {\r\n    transform: translateX(-4px);\r\n  }\r\n\r\n  20% {\r\n    transform: translateX(6px);\r\n  }\r\n\r\n  30% {\r\n    transform: translateX(-8px);\r\n  }\r\n\r\n  40% {\r\n    transform: translateX(8px);\r\n  }\r\n\r\n  50% {\r\n    transform: translateX(-6px);\r\n  }\r\n\r\n  60% {\r\n    transform: translateX(5px);\r\n  }\r\n\r\n  70% {\r\n    transform: translateX(-3px);\r\n  }\r\n\r\n  80% {\r\n    transform: translateX(2px);\r\n  }\r\n\r\n  90% {\r\n    transform: translateX(-1px);\r\n  }\r\n\r\n  100% {\r\n    transform: translateX(0);\r\n  }\r\n}\r\n\r\n.custom-tooltip-popup {\r\n  position: fixed;\r\n  background: rgb(22, 22, 22);\r\n  color: rgb(222, 222, 222);\r\n  padding: 0.5em;\r\n  z-index: 1200;\r\n  font-size: 0.9em;\r\n  pointer-events: none;\r\n  white-space: nowrap;\r\n  opacity: 0;\r\n  transition: opacity 0.1s;\r\n  display: none;\r\n  left: 0;\r\n  top: 0;\r\n  border: 1px solid rgb(60, 60, 60) !important;\r\n  border-radius: 4px !important;\r\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3) !important;\r\n}\r\n\r\n.static-chat-notification {\r\n  cursor: default;\r\n  white-space: nowrap;\r\n  padding: 8px;\r\n  display: inline-flex;\r\n  flex: auto;\r\n  justify-content: center;\r\n  margin: 4px;\r\n  font-size: 1em;\r\n  align-items: center;\r\n  border-radius: 4px !important;\r\n}\r\n\r\n.dynamic-chat-notifications-container {\r\n  z-index: 1000;\r\n  width: 0;\r\n  position: fixed;\r\n  display: flex;\r\n  flex-direction: column;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  padding-top: 160px;\r\n}\r\n\r\n.dynamic-chat-notification {\r\n  cursor: default;\r\n  white-space: nowrap;\r\n  position: relative;\r\n  align-items: center;\r\n  width: fit-content;\r\n  display: flex;\r\n  margin-bottom: 0.2em;\r\n  padding: 8px 16px 8px 12px;\r\n  border-radius: 0 4px 4px 0 !important;\r\n  left: 0;\r\n  transform: translateX(-100%);\r\n  opacity: 1;\r\n  transition: transform 0.3s cubic-bezier(0.83, 0, 0.17, 1), opacity 0.3s cubic-bezier(0.83, 0, 0.17, 1);\r\n}\r\n\r\n/* For both (static and dynamic) notifications */\r\n.user-enter {\r\n  color: hsl(100, 50%, 50%) !important;\r\n  background-color: hsl(100, 50%, 10%) !important;\r\n  outline: 1px solid hsl(100, 50%, 25%) !important;\r\n}\r\n\r\n.user-left {\r\n  color: hsl(0, 50%, 70%) !important;\r\n  background-color: hsl(0, 50%, 15%) !important;\r\n  outline: 1px solid hsl(0, 50%, 40%) !important;\r\n}\r\n\r\n/* convertImageLinksToImage */\r\n.clickable-thumbnail {\r\n  opacity: 1;\r\n  transition: opacity 0.15s ease-in-out;\r\n  border: none;\r\n  width: 6vw;\r\n  min-width: 100px;\r\n  max-height: 200px;\r\n  height: auto;\r\n  cursor: pointer;\r\n  background-color: transparent;\r\n  padding: 2px;\r\n  margin: 6px;\r\n  overflow-y: auto;\r\n}\r\n\r\n.clickable-thumbnail:hover {\r\n  opacity: 0.8;\r\n}\r\n\r\n.clickable-thumbnail img {\r\n  max-height: 100%;\r\n  max-width: 100%;\r\n  background-color: transparent;\r\n}\r\n\r\n.scaled-thumbnail {\r\n  top: 50%;\r\n  left: 50%;\r\n  transform-origin: center center;\r\n  transform: translate(-50%, -50%) scale(1);\r\n  position: fixed;\r\n  opacity: 0;\r\n  z-index: 999;\r\n  transform-origin: center center;\r\n  max-height: 90vh;\r\n  max-width: 90vw;\r\n  cursor: pointer;\r\n}\r\n\r\n/* convertVideoLinksToPlayer */\r\n.video-wrapper {\r\n  display: flex;\r\n  width: fit-content;\r\n  flex-direction: column;\r\n  gap: 6px;\r\n  margin-bottom: 10px;\r\n}\r\n\r\n.video-container {\r\n  display: flex;\r\n  border: none;\r\n  height: 165px;\r\n}\r\n\r\n/* Dimming element */\r\n.dimming-background {\r\n  background: black;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  position: fixed;\r\n  opacity: 0;\r\n  z-index: 998;\r\n}\r\n\r\n/* loadProfileIntoIframe */\r\n.profile-iframe-container {\r\n  opacity: 0;\r\n  border: none;\r\n  display: flex;\r\n  position: fixed;\r\n  z-index: 999;\r\n  width: 75vw;\r\n  min-width: 1000px;\r\n  height: 80vh;\r\n  top: 48.5vh;\r\n  left: 50vw;\r\n  transform: translate(-50%, -50%);\r\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08) !important;\r\n  border-radius: 0.6em !important;\r\n}\r\n\r\n.scroll-buttons-container {\r\n  display: flex;\r\n  justify-content: center;\r\n  grid-area: scroll;\r\n  flex-direction: column;\r\n  height: calc(100% - 1em);\r\n  padding: 1em;\r\n}\r\n\r\n.scroll-buttons-container .scroll-button {\r\n  margin: 0.25em 0;\r\n  background-color: rgba(222, 222, 222, 0.1);\r\n}\r\n\r\n/* Common styles for all panel header buttons */\r\n.large-button {\r\n  width: 48px;\r\n  height: 48px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  cursor: pointer;\r\n  border-radius: 0.2em !important;\r\n  filter: brightness(1);\r\n  transition: filter 0.3s ease, opacity 0.3s ease;\r\n}\r\n\r\n.large-button:hover {\r\n  filter: brightness(0.8);\r\n}\r\n\r\n.panel-control-buttons {\r\n  display: flex;\r\n}\r\n\r\n.panel-control-buttons>div:not(:first-child) {\r\n  margin-left: 0.5em;\r\n}\r\n\r\n/* Common background color for all panel header buttons */\r\n.panel-header-clear-button {\r\n  background-color: brown;\r\n}\r\n\r\n.panel-header-close-button {\r\n  background-color: darkolivegreen;\r\n}\r\n\r\n.panel-header-save-button {\r\n  display: none;\r\n  opacity: 0;\r\n  visibility: hidden;\r\n  background-color: #2f6b63;\r\n}\r\n\r\n.panel-header-import-button {\r\n  background-color: #502f6b;\r\n}\r\n\r\n.panel-header-export-button {\r\n  background-color: #2f4c6b;\r\n}\r\n\r\n.panel-header-copy-button,\r\n.panel-header-date-button {\r\n  background-color: steelblue;\r\n}\r\n\r\n.panel-header-toggle-button {\r\n  background-color: #144e9d;\r\n}\r\n\r\n.panel-header-toggle-media-messages {\r\n  background-color: darkslategray;\r\n}\r\n\r\n.toggle-mention-messages-button {\r\n  background-color: saddlebrown;\r\n}\r\n\r\n.panel-header-one-day-back-button,\r\n.panel-header-one-day-forward-button {\r\n  background-color: darkcyan;\r\n}\r\n\r\n.panel-header-shuffle-button {\r\n  background-color: darkslateblue;\r\n}\r\n\r\n/* New chat user list */\r\n#chat-general .userlist-content {\r\n  opacity: 0;\r\n}\r\n\r\n#chat-general .smile-tab {\r\n  position: relative;\r\n  z-index: 1;\r\n}\r\n\r\n.chat-user-list {\r\n  display: flex;\r\n  flex-direction: column;\r\n  position: absolute;\r\n  top: 20px;\r\n  padding-top: 8px;\r\n  width: 200px;\r\n  height: 94%;\r\n  overflow-y: auto;\r\n  overflow-x: hidden;\r\n}\r\n\r\n.chat-user-list [class^=\"rank-group\"] {\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.chat-user-list [class^=\"user\"] {\r\n  display: inline-flex;\r\n  margin: 2px 0;\r\n}\r\n\r\n.chat-user-list .avatar {\r\n  width: 24px;\r\n  height: 24px;\r\n  display: inline-flex;\r\n}\r\n\r\n.chat-user-list .avatar img,\r\n.fetched-users .avatar img {\r\n  transform-origin: left;\r\n  transition: transform 0.3s;\r\n}\r\n\r\n.chat-user-list .avatar img:hover,\r\n.fetched-users .avatar img:hover {\r\n  transform: scale(2);\r\n}\r\n\r\n.chat-user-list .name {\r\n  text-decoration: none;\r\n  display: inline-flex;\r\n  width: auto;\r\n  height: 24px;\r\n  line-height: 24px;\r\n  padding: 0 8px;\r\n  max-width: 124px;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n}\r\n\r\n.chat-user-list .name:hover {\r\n  text-decoration: underline;\r\n}\r\n\r\n.chat-user-list .profile,\r\n.chat-user-list .tracked,\r\n.chat-user-list .ignored,\r\n.chat-user-list .moderator {\r\n  display: inline-flex;\r\n  width: 24px;\r\n  height: 24px;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n/* Highlight for mention words */\r\n.mention {\r\n  display: inline-flex;\r\n  color: #83cf40;\r\n  font-family: Roboto Mono, monospace;\r\n  font-weight: bold;\r\n}\r\n\r\n/* Chat popup messages */\r\n.popup-messages-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: flex-end;\r\n  align-items: start;\r\n  user-select: none;\r\n  pointer-events: none;\r\n  position: fixed;\r\n  left: 0;\r\n  right: 0;\r\n  top: 50px;\r\n  bottom: 0;\r\n}\r\n\r\n.popup-chat-message {\r\n  display: flex;\r\n  align-items: center;\r\n  background-color: hsl(100, 50%, 10%);\r\n  position: relative;\r\n  max-width: 70vw;\r\n  border-radius: 0.2em !important;\r\n  color: hsl(100, 50%, 50%);\r\n  border: 1px solid hsl(100, 50%, 25%);\r\n  padding: 4px;\r\n  margin: 6px 15vw;\r\n  opacity: 0;\r\n  transform: translateY(20px);\r\n  transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;\r\n  animation: fadeIn 0.3s ease-in-out forwards;\r\n}\r\n\r\n@keyframes fadeIn {\r\n  from {\r\n    opacity: 0;\r\n    transform: translateY(20px);\r\n  }\r\n\r\n  to {\r\n    opacity: 1;\r\n    transform: translateY(0);\r\n  }\r\n}\r\n\r\n.popup-chat-message.fade-out {\r\n  animation: fadeOut 0.3s ease-in-out forwards;\r\n}\r\n\r\n@keyframes fadeOut {\r\n  from {\r\n    opacity: 1;\r\n    transform: translateY(0);\r\n  }\r\n\r\n  to {\r\n    opacity: 0;\r\n    transform: translateY(-20px);\r\n  }\r\n}\r\n\r\n.popup-chat-message>div {\r\n  padding: 2px;\r\n  display: flex;\r\n  font-family: 'Montserrat', sans-serif;\r\n}\r\n\r\n.popup-chat-message .time,\r\n.popup-chat-message .time-icon {\r\n  opacity: 0.7;\r\n}\r\n\r\n/* Empowerment voice settings (Ctrl + Alt) */\r\n.voice-settings {\r\n  position: absolute;\r\n  top: 65px;\r\n  right: 70px;\r\n  opacity: 0;\r\n  transition: opacity 0.3s ease;\r\n  font-family: Orbitron, sans-serif;\r\n}\r\n\r\n/* Basic styles for empowerment voice settings */\r\n.voice-value-info {\r\n  display: flex;\r\n  width: 100%;\r\n  justify-content: center;\r\n  margin-bottom: 6px;\r\n}\r\n\r\n/* voice speed */\r\n.voice-speed {\r\n  color: hsl(100, 50%, 50%);\r\n}\r\n\r\n.voice-speed-progress {\r\n  display: block;\r\n  width: 120px;\r\n  height: 12px;\r\n  background-color: hsl(90, 60%, 30%);\r\n}\r\n\r\n.voice-speed-progress-fill {\r\n  display: block;\r\n  height: 100%;\r\n  background-color: hsl(90, 60%, 50%);\r\n}\r\n\r\n/* voice pitch */\r\n.voice-pitch {\r\n  color: hsl(180, 60%, 50%);\r\n}\r\n\r\n.voice-pitch-progress {\r\n  display: block;\r\n  width: 120px;\r\n  height: 12px;\r\n  background-color: hsl(180, 60%, 30%);\r\n}\r\n\r\n.voice-pitch-progress-fill {\r\n  display: block;\r\n  height: 100%;\r\n  background-color: hsl(180, 60%, 50%);\r\n}\r\n\r\n/* showCachePanel */\r\n.cached-users-panel {\r\n  opacity: 0;\r\n  background-color: #1b1b1b;\r\n  border-radius: 0.6em !important;\r\n  position: fixed;\r\n  top: 100px;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  width: 80vw;\r\n  height: 80vh;\r\n  z-index: 999;\r\n  display: grid;\r\n  grid-template-columns: 1fr;\r\n  grid-template-rows: min-content;\r\n  grid-template-areas:\r\n    \"header header\"\r\n    \"cache scroll\";\r\n}\r\n\r\n.cached-users-panel .panel-header {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: space-between;\r\n  padding: 0.6em;\r\n  grid-area: header;\r\n}\r\n\r\n.cached-users-panel .drop-time {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  min-width: fit-content;\r\n}\r\n\r\n.cached-users-panel .drop-time-threshold-description {\r\n  padding: 0.6em;\r\n  color: #c6b209;\r\n}\r\n\r\n.cached-users-panel .drop-time-threshold {\r\n  padding: 0.6em;\r\n  color: lightcoral;\r\n  font-family: 'Roboto Mono', monospace;\r\n  font-size: 1.1em;\r\n  font-weight: bold;\r\n  border-radius: 0.2em !important;\r\n  border: 1px solid rgba(240, 128, 128, 0.20);\r\n  background-color: rgba(240, 128, 128, 0.05);\r\n  transition: filter 0.3s;\r\n  filter: sepia(0);\r\n  cursor: pointer;\r\n}\r\n\r\n.cached-users-panel .drop-time-threshold:hover {\r\n  filter: sepia(1);\r\n}\r\n\r\n.cached-users-panel .drop-time-expiration-description {\r\n  padding: 0.6em;\r\n  color: #d0562c;\r\n}\r\n\r\n.cached-users-panel .drop-time-expiration {\r\n  padding: 0.6em;\r\n  color: antiquewhite;\r\n  font-family: 'Roboto Mono', monospace;\r\n  font-size: 1.1em;\r\n}\r\n\r\n.cached-users-panel .search-for-cached-users {\r\n  width: 100%;\r\n  margin: 0 0.5em;\r\n  display: flex;\r\n}\r\n\r\n.cached-users-panel .cached-users-search-input {\r\n  outline: none;\r\n  width: 100%;\r\n  padding: 10px;\r\n  font-size: 1em;\r\n  font-family: 'Montserrat';\r\n  color: bisque !important;\r\n  border-radius: 0.2em !important;\r\n  box-sizing: border-box;\r\n  background-color: #111;\r\n  border: 1px solid #222;\r\n}\r\n\r\n.cached-users-panel .error-message {\r\n  width: fit-content;\r\n  white-space: nowrap;\r\n  font-family: 'Montserrat';\r\n  color: lightcoral;\r\n}\r\n\r\n.fetch-mode-button {\r\n  background-color: #b2a4f9;\r\n}\r\n\r\n.fetch-mode-button svg {\r\n  stroke: darkslateblue;\r\n}\r\n\r\n.cache-mode-button {\r\n  background-color: darkslateblue;\r\n}\r\n\r\n.cache-mode-button svg {\r\n  stroke: #b2a4f9;\r\n}\r\n\r\n.cached-users-panel .fetched-users {\r\n  display: grid;\r\n  grid-template-rows: 1fr 1fr;\r\n  height: calc(100% - 0.5em);\r\n  overflow-y: auto;\r\n  grid-area: cache;\r\n}\r\n\r\n.cached-users-panel .users-container {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));\r\n  gap: 12px;\r\n  padding: 1em;\r\n  height: fit-content;\r\n}\r\n\r\n/* Common styles for all descriptions */\r\n.cached-users-panel .description {\r\n  color: bisque;\r\n  font-family: Montserrat;\r\n  font-size: 1em;\r\n  margin: 0;\r\n  padding: 0.4em 0.2em;\r\n  grid-column: 1 / -1;\r\n  height: fit-content;\r\n}\r\n\r\n/* Common styles for user container elements in cached users panel */\r\n.cached-users-panel .user-item {\r\n  padding: 0.2em;\r\n  margin: 0.4em 0.2em;\r\n  display: grid;\r\n  grid-template-columns: auto 1fr;\r\n  align-items: center;\r\n  height: fit-content;\r\n}\r\n\r\n/* Common styles for the visits element */\r\n.cached-users-panel .visits {\r\n  margin-left: 8px;\r\n  padding: 4px 6px;\r\n  border-radius: 2px !important;\r\n  cursor: pointer;\r\n  white-space: pre;\r\n}\r\n\r\n/* Styling for tracked visits */\r\n.cached-users-panel .visits.tracked {\r\n  color: greenyellow;\r\n  background-color: darkgreen;\r\n  font-weight: bold;\r\n}\r\n\r\n/* Styling for untracked visits */\r\n.cached-users-panel .visits.untracked {\r\n  color: orange;\r\n  background-color: #111111;\r\n  font-weight: normal;\r\n}\r\n\r\n/* Common styles for the action log container */\r\n.cached-users-panel .action-log {\r\n  position: fixed;\r\n  opacity: 0;\r\n  padding: 8px;\r\n  gap: 4px;\r\n  top: 50%;\r\n  left: 50%;\r\n  transform: translate(-50%, -50%);\r\n  max-height: 85vh;\r\n  overflow-y: auto;\r\n  scrollbar-width: none;\r\n  overflow-x: hidden;\r\n  display: flex;\r\n  min-width: 30vw;\r\n  max-width: 50vw;\r\n  flex-wrap: wrap;\r\n  background-color: #111111;\r\n  border: 3px dashed #212121;\r\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08) !important;\r\n  border-radius: 0.2em !important;\r\n}\r\n\r\n.cached-users-panel .rank {\r\n  padding: 2px 0;\r\n}\r\n\r\n.cached-users-panel .registered {\r\n  color: cadetblue;\r\n  font-size: 12px;\r\n}\r\n\r\n.cached-users-panel .user-metrics {\r\n  margin-top: 4px;\r\n  grid-column: span 2;\r\n}\r\n\r\n.cached-users-panel .avatar {\r\n  font-size: 1.8rem;\r\n  margin-right: 8px;\r\n}\r\n\r\n.cached-users-panel .avatar img {\r\n  height: 24px;\r\n  width: 24px;\r\n}\r\n\r\n.cached-users-panel .login {\r\n  color: skyblue !important;\r\n  text-decoration: none;\r\n  font-family: 'Montserrat', sans-serif;\r\n  transition: color 0.3s ease;\r\n}\r\n\r\n.cached-users-panel .login:hover {\r\n  color: cornsilk !important;\r\n}\r\n\r\n/* createCacheButton */\r\n.cache-user-count {\r\n  display: flex;\r\n  position: absolute;\r\n  justify-content: center;\r\n  align-items: center;\r\n  left: 0;\r\n  bottom: 0;\r\n  transform: translate(-50%, 50%);\r\n  z-index: 1;\r\n  height: 20px;\r\n  padding: 0 4px;\r\n  border-radius: 2px !important;\r\n  background-color: #9db380;\r\n  color: rgb(2, 2, 2);\r\n  font-size: 12px;\r\n  font-family: Roboto, sans-serif;\r\n  font-weight: bold;\r\n}\r\n\r\n/* createPersonalMessagesButton */\r\n.personal-messages-button {\r\n  position: relative;\r\n  z-index: 2;\r\n}\r\n\r\n.message-count {\r\n  display: flex;\r\n  position: absolute;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: 20px;\r\n  padding: 0 4px;\r\n  border-radius: 2px !important;\r\n  color: rgb(2, 2, 2);\r\n  font-size: 12px;\r\n  font-family: Roboto, sans-serif;\r\n  font-weight: bold;\r\n  bottom: 0;\r\n}\r\n\r\n.total-message-count {\r\n  left: 0;\r\n  transform: translate(-50%, 50%);\r\n  background-color: #fa8072;\r\n}\r\n\r\n.new-message-count {\r\n  right: 0;\r\n  transform: translate(50%, 50%);\r\n  background-color: #ffd700;\r\n}\r\n\r\n/* showPersonalMessagesPanel */\r\n.cached-messages-panel {\r\n  opacity: 0;\r\n  background-color: #1b1b1b;\r\n  border-radius: 0.6em !important;\r\n  position: fixed;\r\n  top: 100px;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  width: 50vw;\r\n  height: 80vh;\r\n  z-index: 999;\r\n  min-width: 1000px;\r\n  display: grid;\r\n  grid-template-columns: 1fr;\r\n  grid-template-rows: min-content;\r\n  grid-template-areas:\r\n    \"header header\"\r\n    \"messages scroll\";\r\n}\r\n\r\n.panel-header {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: flex-end;\r\n  /* Aligns to the right */\r\n  padding: 0.6em;\r\n  grid-area: header;\r\n}\r\n\r\n.search-for-personal-messages {\r\n  width: 100%;\r\n  margin: 0 0.5em 0 0;\r\n  display: flex;\r\n}\r\n\r\n.personal-messages-search-input {\r\n  outline: none;\r\n  width: 100%;\r\n  padding: 10px;\r\n  font-size: 1em;\r\n  font-family: Montserrat, sans-serif;\r\n  color: bisque !important;\r\n  border-radius: 0.2em !important;\r\n  box-sizing: border-box;\r\n  background-color: #111;\r\n  border: 1px solid #222 !important;\r\n}\r\n\r\n.cached-messages-panel .messages-container {\r\n  overflow-y: auto;\r\n  height: calc(100% - 0.5em);\r\n  padding: 1em;\r\n  grid-area: messages;\r\n}\r\n\r\n.cached-messages-panel .date-item {\r\n  position: relative;\r\n  font: 1em Montserrat, sans-serif;\r\n  color: burlywood;\r\n  background-color: rgba(222, 184, 135, 0.1);\r\n  width: fit-content;\r\n  margin: 2em 1em 1em;\r\n  padding: 0.4em 0.8em;\r\n  text-align: center;\r\n  border-radius: 0.4em !important;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n}\r\n\r\n.cached-messages-panel .message-item {\r\n  padding: 0.2em;\r\n}\r\n\r\n.cached-messages-panel .message-time {\r\n  margin: 0px 0.4em;\r\n  height: fit-content;\r\n  cursor: pointer;\r\n  transition: color 0.2s ease;\r\n}\r\n\r\n.cached-messages-panel .message-username {\r\n  display: inline-flex;\r\n  cursor: pointer;\r\n  margin: 0px 0.4em;\r\n  height: fit-content;\r\n}\r\n\r\n.cached-messages-panel .message-text {\r\n  cursor: pointer;\r\n  margin: 0px 0.4em;\r\n  height: fit-content;\r\n}\r\n\r\n/* createChatLogsButton */\r\n.chat-logs-button {\r\n  position: relative;\r\n  z-index: 1;\r\n}\r\n\r\n/* showChatLogsPanel */\r\n.chat-logs-panel {\r\n  opacity: 0;\r\n  background-color: #1b1b1b;\r\n  border-radius: 0.6em !important;\r\n  position: fixed;\r\n  top: 100px;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  width: 80vw;\r\n  height: 80vh;\r\n  z-index: 999;\r\n  min-width: 1000px;\r\n  display: grid;\r\n  grid-template-columns: 1fr;\r\n  grid-template-rows: min-content;\r\n  grid-template-areas:\r\n    \"header header header\"\r\n    \"messages scroll users\";\r\n}\r\n\r\n.chat-logs-panel .panel-header {\r\n  display: flex;\r\n  flex-direction: row;\r\n  grid-area: header;\r\n  justify-content: flex-end;\r\n  padding: 0.6em;\r\n}\r\n\r\n.chat-logs-panel .panel-control-buttons {\r\n  display: flex;\r\n}\r\n\r\n.chat-logs-panel .search-for-chatlogs-messages {\r\n  width: 100%;\r\n  margin: 0 0.5em 0 0;\r\n  display: flex;\r\n}\r\n\r\n.chat-logs-panel .chatlogs-search-input {\r\n  outline: none;\r\n  height: 48px;\r\n  width: 100%;\r\n  padding: 10px;\r\n  font-size: 1em;\r\n  font-family: Montserrat;\r\n  color: bisque !important;\r\n  border-radius: 0.2em !important;\r\n  box-sizing: border-box;\r\n  background-color: #111;\r\n  border: 1px solid #222 !important;\r\n}\r\n\r\n.chat-logs-panel .chatlogs-date-input {\r\n  background-color: #111;\r\n  color: bisque;\r\n  border: 1px solid #222;\r\n  width: fit-content;\r\n  height: 48px;\r\n  padding: 10px;\r\n  font-size: 1em;\r\n  font-family: Montserrat;\r\n  border-radius: 0.2em !important;\r\n  box-sizing: border-box;\r\n  margin: 0 0.5em;\r\n}\r\n\r\n.toggle-mention-messages-counter,\r\n.toggle-media-messages-counter {\r\n  display: flex;\r\n  position: absolute;\r\n  justify-content: center;\r\n  align-items: center;\r\n  padding: 2px 4px;\r\n  border-radius: 2px !important;\r\n  font-size: 12px;\r\n  font-family: Roboto;\r\n  font-weight: bold;\r\n  bottom: 0px;\r\n  left: 0px;\r\n  transform: translate(-50%, 50%);\r\n  color: #020202;\r\n  pointer-events: none;\r\n  user-select: none;\r\n}\r\n\r\n.toggle-mention-messages-counter {\r\n  background-color: #ffa07a;\r\n}\r\n\r\n.toggle-media-messages-counter {\r\n  background-color: #71c4c4;\r\n}\r\n\r\n.chat-logs-panel .saved-chatlog-url {\r\n  color: darkseagreen !important;\r\n  text-decoration: none;\r\n  display: inline-flex;\r\n  padding: 0.5em;\r\n}\r\n\r\n.chat-logs-panel .saved-chatlog-url-title {\r\n  color: lightsteelblue;\r\n  padding: 0.5em;\r\n}\r\n\r\n.saved-chatlog-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  overflow-y: auto;\r\n  background-color: rgb(30, 40, 45);\r\n  border: 1px solid rgb(60, 70, 80) !important;\r\n  border-radius: 0.2em !important;\r\n  position: absolute;\r\n  padding: 0.5em;\r\n  height: fit-content;\r\n  width: max-content;\r\n  max-height: 400px;\r\n  top: calc(50px + 1em);\r\n  right: 0;\r\n}\r\n\r\n.chat-logs-panel .chat-logs-container {\r\n  overflow-y: auto;\r\n  height: calc(100% - 0.5em);\r\n  padding: 1em;\r\n  display: flex;\r\n  grid-area: messages;\r\n  flex-direction: column;\r\n}\r\n\r\n.chat-logs-panel .message-item {\r\n  padding: 0.2em;\r\n  display: inline-flex;\r\n  cursor: pointer;\r\n  align-items: start;\r\n}\r\n\r\n.chat-logs-panel .message-time {\r\n  color: darkseagreen;\r\n  margin: 0 0.4em;\r\n  cursor: pointer;\r\n  transition: color 0.2s ease;\r\n  height: fit-content;\r\n}\r\n\r\n.chat-logs-panel .message-time:hover {\r\n  color: lightgreen;\r\n}\r\n\r\n.chat-logs-panel .message-username {\r\n  cursor: pointer;\r\n  margin: 0 0.4em;\r\n  height: fit-content;\r\n}\r\n\r\n.chat-logs-panel .message-text {\r\n  color: lightsteelblue;\r\n  margin: 0 0.4em;\r\n  overflow-wrap: anywhere;\r\n  height: fit-content;\r\n}\r\n\r\n.chat-logs-panel .active-users {\r\n  padding: 1em;\r\n  height: calc(100% - 1em);\r\n  width: fit-content;\r\n  overflow-y: auto;\r\n  overflow-x: hidden;\r\n  grid-area: users;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.chat-logs-panel .active-user-item {\r\n  display: flex;\r\n  height: fit-content;\r\n  align-items: center;\r\n  justify-content: left;\r\n  margin: 0.2em 0;\r\n  cursor: pointer;\r\n  transition: filter 0.15s;\r\n}\r\n\r\n.chat-logs-panel .active-user-item:hover {\r\n  filter: brightness(0.8);\r\n}\r\n\r\n.chat-logs-panel .active-user-name {\r\n  padding: 0.4em;\r\n}\r\n\r\n.chat-logs-panel .active-user-messages-count {\r\n  padding: 0.4em;\r\n  border-radius: 0.2em !important;\r\n}\r\n\r\n/* showSettingsPanel */\r\n.settings-panel {\r\n  opacity: 0;\r\n  background-color: #1b1b1b;\r\n  border-radius: 0.6em !important;\r\n  position: fixed;\r\n  top: 100px;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  width: 50vw;\r\n  height: 80vh;\r\n  z-index: 999;\r\n  min-width: 1000px;\r\n  display: grid;\r\n  grid-template-columns: 1fr;\r\n  grid-template-rows: min-content;\r\n  grid-template-areas:\r\n    \"header header\"\r\n    \"settings scroll\";\r\n}\r\n\r\n.settings-panel .panel-header {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: flex-end;\r\n  padding: 0.6em;\r\n  grid-area: header;\r\n}\r\n\r\n.settings-panel .settings-content-container {\r\n  overflow-y: auto;\r\n  height: calc(100% - 0.5em);\r\n  padding: 1em;\r\n  grid-area: settings;\r\n}\r\n\r\n.settings-panel .settings-description {\r\n  position: relative;\r\n  font: 1em Montserrat;\r\n  color: burlywood;\r\n  background-color: rgba(222, 184, 135, 0.1);\r\n  width: fit-content;\r\n  margin: 0 0 1em;\r\n  padding: 0.4em 0.8em;\r\n  border-radius: 0.4em !important;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n}\r\n\r\n.settings-panel .settings-spoiler button {\r\n  position: relative;\r\n  font: 1em Montserrat;\r\n  color: lightgreen;\r\n  background-color: rgba(222, 184, 135, 0.1);\r\n  margin: 0 0 3em 0;\r\n  padding: 0.4em 0.8em;\r\n  border-radius: 0.4em !important;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  cursor: pointer;\r\n  transition: background-color 0.3s ease;\r\n  border: none;\r\n}\r\n\r\n.settings-panel .settings-spoiler button:hover {\r\n  background-color: rgba(222, 184, 135, 0.25);\r\n}\r\n\r\n.settings-panel .settings-field {\r\n  height: 30px;\r\n  max-width: 200px;\r\n  min-width: 150px;\r\n  padding: 0.4em;\r\n  font: 1em Montserrat;\r\n  font-family: Montserrat;\r\n  color: bisque;\r\n  border-radius: 0.2em !important;\r\n  box-sizing: border-box;\r\n  background-color: rgb(17, 17, 17);\r\n  border: 1px solid rgb(34, 34, 34);\r\n}\r\n\r\n.settings-panel .settings-button {\r\n  width: 30px;\r\n  height: 30px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border-radius: 0.2em !important;\r\n  cursor: pointer;\r\n  transition: filter 0.3s;\r\n  filter: brightness(1);\r\n}\r\n\r\n.settings-panel .settings-button:hover {\r\n  filter: brightness(0.8);\r\n}\r\n\r\n/* Disabled state */\r\n.settings-panel .settings-button.disabled {\r\n  filter: grayscale(1);\r\n  pointer-events: none;\r\n  opacity: 0.5;\r\n}\r\n\r\n.settings-panel .settings-button {\r\n  width: 30px;\r\n  height: 30px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border-radius: 0.2em !important;\r\n  cursor: pointer;\r\n  transition: filter 0.3s;\r\n}\r\n\r\n.settings-panel .remove-settings-button {\r\n  stroke: #ee9090;\r\n  background-color: #6b2f2f;\r\n}\r\n\r\n.settings-panel .assigned-settings-button {\r\n  stroke: lightsteelblue;\r\n  background-color: steelblue;\r\n}\r\n\r\n.settings-panel .add-settings-button {\r\n  stroke: #d190ee;\r\n  background-color: #502f6b;\r\n}\r\n\r\n.settings-panel .settings-container {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  align-items: start;\r\n  flex-direction: column;\r\n}\r\n\r\n/* toggleHiddenMessages */\r\n.toggle-button-hidden {\r\n  background-color: hsl(0, 20%, 10%);\r\n  color: hsl(0, 50%, 50%);\r\n  border: 1px solid hsl(0, 50%, 50%);\r\n}\r\n\r\n.toggle-button-show {\r\n  background-color: hsl(90, 20%, 10%);\r\n  color: hsl(90, 50%, 50%);\r\n  border: 1px solid hsl(90, 50%, 50%);\r\n}\r\n\r\n.toggle-button-hide {\r\n  background-color: hsl(50, 20%, 10%);\r\n  color: hsl(50, 50%, 50%);\r\n  border: 1px solid hsl(50, 50%, 50%);\r\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/style.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\r\n\r\n/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function (cssWithMappingToString) {\r\n  var list = [];\r\n\r\n  // return the list of modules as css string\r\n  list.toString = function toString() {\r\n    return this.map(function (item) {\r\n      var content = \"\";\r\n      var needLayer = typeof item[5] !== \"undefined\";\r\n      if (item[4]) {\r\n        content += \"@supports (\".concat(item[4], \") {\");\r\n      }\r\n      if (item[2]) {\r\n        content += \"@media \".concat(item[2], \" {\");\r\n      }\r\n      if (needLayer) {\r\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\r\n      }\r\n      content += cssWithMappingToString(item);\r\n      if (needLayer) {\r\n        content += \"}\";\r\n      }\r\n      if (item[2]) {\r\n        content += \"}\";\r\n      }\r\n      if (item[4]) {\r\n        content += \"}\";\r\n      }\r\n      return content;\r\n    }).join(\"\");\r\n  };\r\n\r\n  // import a list of modules into the list\r\n  list.i = function i(modules, media, dedupe, supports, layer) {\r\n    if (typeof modules === \"string\") {\r\n      modules = [[null, modules, undefined]];\r\n    }\r\n    var alreadyImportedModules = {};\r\n    if (dedupe) {\r\n      for (var k = 0; k < this.length; k++) {\r\n        var id = this[k][0];\r\n        if (id != null) {\r\n          alreadyImportedModules[id] = true;\r\n        }\r\n      }\r\n    }\r\n    for (var _k = 0; _k < modules.length; _k++) {\r\n      var item = [].concat(modules[_k]);\r\n      if (dedupe && alreadyImportedModules[item[0]]) {\r\n        continue;\r\n      }\r\n      if (typeof layer !== \"undefined\") {\r\n        if (typeof item[5] === \"undefined\") {\r\n          item[5] = layer;\r\n        } else {\r\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\r\n          item[5] = layer;\r\n        }\r\n      }\r\n      if (media) {\r\n        if (!item[2]) {\r\n          item[2] = media;\r\n        } else {\r\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\r\n          item[2] = media;\r\n        }\r\n      }\r\n      if (supports) {\r\n        if (!item[4]) {\r\n          item[4] = \"\".concat(supports);\r\n        } else {\r\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\r\n          item[4] = supports;\r\n        }\r\n      }\r\n      list.push(item);\r\n    }\r\n  };\r\n  return list;\r\n};\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\r\n\r\nmodule.exports = function (i) {\r\n  return i[1];\r\n};\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar stylesInDOM = [];\r\nfunction getIndexByIdentifier(identifier) {\r\n  var result = -1;\r\n  for (var i = 0; i < stylesInDOM.length; i++) {\r\n    if (stylesInDOM[i].identifier === identifier) {\r\n      result = i;\r\n      break;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction modulesToDom(list, options) {\r\n  var idCountMap = {};\r\n  var identifiers = [];\r\n  for (var i = 0; i < list.length; i++) {\r\n    var item = list[i];\r\n    var id = options.base ? item[0] + options.base : item[0];\r\n    var count = idCountMap[id] || 0;\r\n    var identifier = \"\".concat(id, \" \").concat(count);\r\n    idCountMap[id] = count + 1;\r\n    var indexByIdentifier = getIndexByIdentifier(identifier);\r\n    var obj = {\r\n      css: item[1],\r\n      media: item[2],\r\n      sourceMap: item[3],\r\n      supports: item[4],\r\n      layer: item[5]\r\n    };\r\n    if (indexByIdentifier !== -1) {\r\n      stylesInDOM[indexByIdentifier].references++;\r\n      stylesInDOM[indexByIdentifier].updater(obj);\r\n    } else {\r\n      var updater = addElementStyle(obj, options);\r\n      options.byIndex = i;\r\n      stylesInDOM.splice(i, 0, {\r\n        identifier: identifier,\r\n        updater: updater,\r\n        references: 1\r\n      });\r\n    }\r\n    identifiers.push(identifier);\r\n  }\r\n  return identifiers;\r\n}\r\nfunction addElementStyle(obj, options) {\r\n  var api = options.domAPI(options);\r\n  api.update(obj);\r\n  var updater = function updater(newObj) {\r\n    if (newObj) {\r\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\r\n        return;\r\n      }\r\n      api.update(obj = newObj);\r\n    } else {\r\n      api.remove();\r\n    }\r\n  };\r\n  return updater;\r\n}\r\nmodule.exports = function (list, options) {\r\n  options = options || {};\r\n  list = list || [];\r\n  var lastIdentifiers = modulesToDom(list, options);\r\n  return function update(newList) {\r\n    newList = newList || [];\r\n    for (var i = 0; i < lastIdentifiers.length; i++) {\r\n      var identifier = lastIdentifiers[i];\r\n      var index = getIndexByIdentifier(identifier);\r\n      stylesInDOM[index].references--;\r\n    }\r\n    var newLastIdentifiers = modulesToDom(newList, options);\r\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\r\n      var _identifier = lastIdentifiers[_i];\r\n      var _index = getIndexByIdentifier(_identifier);\r\n      if (stylesInDOM[_index].references === 0) {\r\n        stylesInDOM[_index].updater();\r\n        stylesInDOM.splice(_index, 1);\r\n      }\r\n    }\r\n    lastIdentifiers = newLastIdentifiers;\r\n  };\r\n};\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar memo = {};\r\n\r\n/* istanbul ignore next  */\r\nfunction getTarget(target) {\r\n  if (typeof memo[target] === \"undefined\") {\r\n    var styleTarget = document.querySelector(target);\r\n\r\n    // Special case to return head of iframe instead of iframe itself\r\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\r\n      try {\r\n        // This will throw an exception if access to iframe is blocked\r\n        // due to cross-origin restrictions\r\n        styleTarget = styleTarget.contentDocument.head;\r\n      } catch (e) {\r\n        // istanbul ignore next\r\n        styleTarget = null;\r\n      }\r\n    }\r\n    memo[target] = styleTarget;\r\n  }\r\n  return memo[target];\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction insertBySelector(insert, style) {\r\n  var target = getTarget(insert);\r\n  if (!target) {\r\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\r\n  }\r\n  target.appendChild(style);\r\n}\r\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction insertStyleElement(options) {\r\n  var element = document.createElement(\"style\");\r\n  options.setAttributes(element, options.attributes);\r\n  options.insert(element, options.options);\r\n  return element;\r\n}\r\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction setAttributesWithoutAttributes(styleElement) {\r\n  var nonce =  true ? __webpack_require__.nc : 0;\r\n  if (nonce) {\r\n    styleElement.setAttribute(\"nonce\", nonce);\r\n  }\r\n}\r\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction apply(styleElement, options, obj) {\r\n  var css = \"\";\r\n  if (obj.supports) {\r\n    css += \"@supports (\".concat(obj.supports, \") {\");\r\n  }\r\n  if (obj.media) {\r\n    css += \"@media \".concat(obj.media, \" {\");\r\n  }\r\n  var needLayer = typeof obj.layer !== \"undefined\";\r\n  if (needLayer) {\r\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\r\n  }\r\n  css += obj.css;\r\n  if (needLayer) {\r\n    css += \"}\";\r\n  }\r\n  if (obj.media) {\r\n    css += \"}\";\r\n  }\r\n  if (obj.supports) {\r\n    css += \"}\";\r\n  }\r\n  var sourceMap = obj.sourceMap;\r\n  if (sourceMap && typeof btoa !== \"undefined\") {\r\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\r\n  }\r\n\r\n  // For old IE\r\n  /* istanbul ignore if  */\r\n  options.styleTagTransform(css, styleElement, options.options);\r\n}\r\nfunction removeStyleElement(styleElement) {\r\n  // istanbul ignore if\r\n  if (styleElement.parentNode === null) {\r\n    return false;\r\n  }\r\n  styleElement.parentNode.removeChild(styleElement);\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction domAPI(options) {\r\n  if (typeof document === \"undefined\") {\r\n    return {\r\n      update: function update() {},\r\n      remove: function remove() {}\r\n    };\r\n  }\r\n  var styleElement = options.insertStyleElement(options);\r\n  return {\r\n    update: function update(obj) {\r\n      apply(styleElement, options, obj);\r\n    },\r\n    remove: function remove() {\r\n      removeStyleElement(styleElement);\r\n    }\r\n  };\r\n}\r\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction styleTagTransform(css, styleElement) {\r\n  if (styleElement.styleSheet) {\r\n    styleElement.styleSheet.cssText = css;\r\n  } else {\r\n    while (styleElement.firstChild) {\r\n      styleElement.removeChild(styleElement.firstChild);\r\n    }\r\n    styleElement.appendChild(document.createTextNode(css));\r\n  }\r\n}\r\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ \"./src/style.css\");\n/* harmony import */ var _modules_image_converter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/image-converter.js */ \"./src/modules/image-converter.js\");\n/* harmony import */ var _modules_video_converter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/video-converter.js */ \"./src/modules/video-converter.js\");\n/* harmony import */ var _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/icons.js */ \"./src/modules/icons.js\");\n/* harmony import */ var _modules_cache_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/cache.js */ \"./src/modules/cache.js\");\n/* harmony import */ var _modules_messages_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/messages.js */ \"./src/modules/messages.js\");\n/* harmony import */ var _modules_chatlogs_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/chatlogs.js */ \"./src/modules/chatlogs.js\");\n/* harmony import */ var _modules_settings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/settings.js */ \"./src/modules/settings.js\");\n/* harmony import */ var _modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/helpers.js */ \"./src/modules/helpers.js\");\n/* harmony import */ var _modules_chat_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/chat.js */ \"./src/modules/chat.js\");\n/* harmony import */ var _modules_tooltip_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/tooltip.js */ \"./src/modules/tooltip.js\");\n/* harmony import */ var _modules_notifications_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/notifications.js */ \"./src/modules/notifications.js\");\n/* harmony import */ var _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/definitions.js */ \"./src/modules/definitions.js\");\n// styles\r\n\r\n\r\n // image converter\r\n // video converter\r\n\r\n// icons\r\n\r\n\r\n // cache\r\n // messages\r\n // chatlogs\r\n // settings\r\n\r\n// helpers && helpers definitions\r\n\r\n\r\n// chat\r\n\r\n\r\n// notifications\r\n\r\n\r\n// notifications\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Array to store user IDs and their status titles\r\nlet fetchedUsers = JSON.parse(localStorage.getItem('fetchedUsers')) || {};\r\n\r\n(function () {\r\n  // Function to dynamically append font link to the head\r\n  function appendFontLink(fontFamily, fontWeights) {\r\n    // Check if the font link element with the specified class already exists\r\n    const existingFont = document.querySelector(`.font-${fontFamily.replace(/\\s/g, '-')}`);\r\n\r\n    // If it doesn't exist, create a new link element and append it to the document head\r\n    if (!existingFont) {\r\n      const fontLink = document.createElement('link');\r\n      fontLink.rel = 'stylesheet';\r\n      fontLink.href = `https://fonts.googleapis.com/css2?family=${fontFamily.replace(/\\s/g, '+')}:wght@${fontWeights.join(';')}&display=swap`;\r\n      fontLink.classList.add(`font-${fontFamily.replace(/\\s/g, '-')}`);\r\n\r\n      // Append the font link element to the document head\r\n      document.head.appendChild(fontLink);\r\n    }\r\n  }\r\n\r\n  // Specify the font weights you want to include\r\n  const montserratFontWeights = ['100', '200', '300', '400', '500', '600', '700', '800', '900'];\r\n  const orbitronFontWeights = ['400', '500', '600', '700', '800', '900'];\r\n  const robotoMonoFontWeights = ['100', '200', '300', '400', '500', '600', '700'];\r\n\r\n  // Call the function to append Montserrat font link\r\n  appendFontLink('Montserrat', montserratFontWeights);\r\n\r\n  // Call the function to append Orbitron font link\r\n  appendFontLink('Orbitron', orbitronFontWeights);\r\n\r\n  // Call the function to append Roboto Mono font link\r\n  appendFontLink('Roboto Mono', robotoMonoFontWeights);\r\n\r\n  // Define voice speed limits\r\n  const minVoiceSpeed = 0;\r\n  const maxVoiceSpeed = 2.5;\r\n\r\n  // Define voice pitch limits\r\n  const minVoicePitch = 0;\r\n  const maxVoicePitch = 2.0;\r\n\r\n  // Define default voice speed and pitch\r\n  const defaultVoiceSpeed = 1.5;\r\n  const defaultVoicePitch = 1.0;\r\n\r\n  // Retrieve KG_Chat_Empowerment from localStorage or create an object with empty voiceSettings if it doesn't exist\r\n  // This is the main key for the settings\r\n  let KG_Chat_Empowerment = JSON.parse(localStorage.getItem('KG_Chat_Empowerment'));\r\n\r\n  // If KG_Chat_Empowerment doesn't exist in localStorage, create it with an empty voiceSettings object\r\n  if (!KG_Chat_Empowerment) {\r\n    KG_Chat_Empowerment = {\r\n      voiceSettings: {\r\n        voiceSpeed: defaultVoiceSpeed, // Set default values for voiceSpeed\r\n        voicePitch: defaultVoicePitch, // Set default values for voicePitch\r\n      },\r\n      messageSettings: {},\r\n    };\r\n    localStorage.setItem('KG_Chat_Empowerment', JSON.stringify(KG_Chat_Empowerment));\r\n  }\r\n\r\n  // Define the default voice speed and pitch\r\n  let voiceSpeed = KG_Chat_Empowerment.voiceSettings.voiceSpeed !== null\r\n    ? KG_Chat_Empowerment.voiceSettings.voiceSpeed\r\n    : defaultVoiceSpeed; // Default value if KG_Chat_Empowerment.voiceSettings.voiceSpeed is null\r\n\r\n  let voicePitch = KG_Chat_Empowerment.voiceSettings.voicePitch !== null\r\n    ? KG_Chat_Empowerment.voiceSettings.voicePitch\r\n    : defaultVoicePitch; // Default value if KG_Chat_Empowerment.voiceSettings.voicePitch is null\r\n\r\n  // SOUND NOTIFICATION\r\n\r\n  // Function to create the audio context and return a Promise that resolves when the context is ready\r\n  function createAudioContext() {\r\n    const audioContext = new AudioContext();\r\n    return new Promise(resolve => {\r\n      audioContext.onstatechange = function () {\r\n        if (audioContext.state === 'running') {\r\n          resolve(audioContext);\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  // Create the audio context and wait for it to be ready\r\n  const audioContextPromise = createAudioContext();\r\n\r\n  // List of frequencies to play for \"User Left\" && \"User Entered\" && \"New Messages\"\r\n  const userEnteredFrequencies = [300, 600];\r\n  const userLeftFrequencies = [600, 300];\r\n  const usualMessageFrequencies = [500];\r\n  const mentionMessageFrequencies = [600, 800];\r\n\r\n  // Volume of the reader voice\r\n  const voiceVolume = 0.8;\r\n  // Volume of the beep signal\r\n  const beepVolume = 0.2;\r\n  // Duration for each frequency\r\n  const duration = 80;\r\n  // Smooth inception and termination for each note\r\n  const fade = 10;\r\n  // Space between each note to make noticeable pauses\r\n  const delay = 100;\r\n\r\n  // Function to play a beep given a list of frequencies\r\n  function playBeep(frequencies, volume) {\r\n    audioContextPromise.then(audioContext => {\r\n      for (let i = 0; i < frequencies.length; i++) {\r\n        const frequency = frequencies[i];\r\n        if (frequency === 0) {\r\n          // Rest note\r\n          setTimeout(() => { }, duration);\r\n        } else {\r\n          // Play note\r\n          const oscillator = audioContext.createOscillator();\r\n          const gain = audioContext.createGain();\r\n          oscillator.connect(gain);\r\n          oscillator.frequency.value = frequency;\r\n          oscillator.type = \"sine\";\r\n\r\n          // Create low pass filter to cut frequencies below 250Hz\r\n          const lowPassFilter = audioContext.createBiquadFilter();\r\n          lowPassFilter.type = 'lowpass';\r\n          lowPassFilter.frequency.value = 250;\r\n          oscillator.connect(lowPassFilter);\r\n\r\n          // Create high pass filter to cut frequencies above 16kHz\r\n          const highPassFilter = audioContext.createBiquadFilter();\r\n          highPassFilter.type = 'highpass';\r\n          highPassFilter.frequency.value = 16000;\r\n          lowPassFilter.connect(highPassFilter);\r\n\r\n          gain.connect(audioContext.destination);\r\n          gain.gain.setValueAtTime(0, audioContext.currentTime);\r\n          gain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + fade / 1000);\r\n          oscillator.start(audioContext.currentTime + i * delay / 1000);\r\n          oscillator.stop(audioContext.currentTime + (i * delay + duration) / 1000);\r\n          gain.gain.setValueAtTime(volume, audioContext.currentTime + (i * delay + (duration - fade)) / 1000);\r\n          gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + (i * delay + duration) / 1000);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // Create a promise that will resolve when the list of available voices is populated\r\n  const awaitVoices = new Promise(resolve => {\r\n    // Create a speech synthesis object\r\n    const synth = window.speechSynthesis;\r\n    // Retrieve the list of available voices\r\n    let voices = synth.getVoices();\r\n\r\n    // Define the voice names for Pavel and Irina\r\n    const pavelVoiceName = 'Microsoft Pavel - Russian (Russia)';\r\n    const irinaVoiceName = 'Microsoft Irina - Russian (Russia)';\r\n\r\n    // Find and store Pavel's voice\r\n    let pavelVoice = voices.find(voice => voice.name === pavelVoiceName);\r\n    // Find and store Irina's voice\r\n    let irinaVoice = voices.find(voice => voice.name === irinaVoiceName);\r\n\r\n    // If either voice is not found or the voices list is empty, wait for it to populate\r\n    if (!pavelVoice || !irinaVoice || voices.length === 0) {\r\n      synth.addEventListener('voiceschanged', () => {\r\n        voices = synth.getVoices();\r\n        pavelVoice = voices.find(voice => voice.name === pavelVoiceName);\r\n        irinaVoice = voices.find(voice => voice.name === irinaVoiceName);\r\n\r\n        // If both voices are found, continue with the initialization\r\n        if (pavelVoice && irinaVoice) {\r\n          // Define the utterance object as a global variable\r\n          const utterance = new SpeechSynthesisUtterance();\r\n          // Set the \"lang\" property of the utterance object to 'ru-RU'\r\n          utterance.lang = 'ru-RU';\r\n          // Set the \"voice\" property of the utterance object to Pavel's voice\r\n          utterance.voice = irinaVoice;\r\n          // Resolve the promise\r\n          resolve({ synth, utterance, voices, pavelVoice, irinaVoice });\r\n        }\r\n      });\r\n    } else {\r\n      // Define the utterance object as a global variable\r\n      const utterance = new SpeechSynthesisUtterance();\r\n      // Set the \"lang\" property of the utterance object to 'ru-RU'\r\n      utterance.lang = 'ru-RU';\r\n      // Set the \"voice\" property of the utterance object to (Needed) voice\r\n      utterance.voice = irinaVoice;\r\n      // Resolve the promise\r\n      resolve({ synth, utterance, voices, pavelVoice, irinaVoice });\r\n    }\r\n  });\r\n\r\n  async function cleanText(text) {\r\n    return text\r\n      // Replace all hyphens (- U+002D), minus signs ( U+2212), and underscores (_) with spaces\r\n      .replace(/[-_]/g, ' ')\r\n      // Replace URLs with just the domain name, removing \"https://\", \"http://\", and \"www.\"\r\n      .replace(/https?:\\/\\/(?:www\\.)?([a-zA-Z0-9.-]+)(\\/.*)?/g, (_, p1) => p1)\r\n      .replace(/\\s(?=[?!,.:;@])/g, '')\r\n      // Remove all other symbols completely\r\n      .replace(/[\"#$%&'()*+\\/<=>[\\\\\\]^`{|}~]/g, '')\r\n      // Remove extra spaces and format text\r\n      .split(' ').filter(Boolean).join(' ').trim();\r\n  }\r\n\r\n  // Split text into language blocks (Russian vs. English) based on per-word detection.\r\n  const detectLanguageBlocks = text =>\r\n    text.split(/\\s+/).reduce((blocks, word) => {\r\n      const lang = /[--0-9]/.test(word) ? 'ru' : 'en';\r\n      if (blocks.length && blocks[blocks.length - 1].lang === lang) {\r\n        blocks[blocks.length - 1].text += ' ' + word;\r\n      } else {\r\n        blocks.push({ lang, text: word });\r\n      }\r\n      return blocks;\r\n    }, []);\r\n\r\n  // Fallback: Web Speech API TTS\r\n  async function webTextToSpeech(text, voiceSpeed = voiceSpeed) {\r\n    const { synth, utterance, voice } = await awaitVoices;\r\n    Object.assign(utterance, { text, rate: voiceSpeed, volume: voiceVolume, pitch: voicePitch, voice });\r\n    return new Promise(resolve => { utterance.onend = resolve; synth.speak(utterance); });\r\n  }\r\n\r\n  // Main TTS function: plays each language block in order.\r\n  async function textToSpeech(text, voiceSpeed = voiceSpeed) {\r\n    const shouldUseGoogleTTS = (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.shouldEnableSetting)('sound', 'gTTS');\r\n    // Clean the text using the new cleanText function asynchronously\r\n    const cleanedText = await cleanText(text);\r\n\r\n    // If Google TTS is enabled, use it. Otherwise, fallback to Web Speech API.\r\n    if (shouldUseGoogleTTS) {\r\n      const blocks = detectLanguageBlocks(cleanedText);\r\n      try {\r\n        for (const { lang, text } of blocks) {\r\n          await new Promise((resolve, reject) => {\r\n            fetch(`http://127.0.0.1:5000/speak?text=${encodeURIComponent(text)}&lang=${lang}`)\r\n              .then(res => { if (!res.ok) throw new Error(`HTTP ${res.status}`); return res.arrayBuffer(); })\r\n              .then(buffer => {\r\n                const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n                const audio = new Audio(URL.createObjectURL(new Blob([buffer], { type: 'audio/mp3' })));\r\n                const source = audioContext.createMediaElementSource(audio);\r\n                const gainNode = audioContext.createGain();\r\n\r\n                gainNode.gain.value = 2.0; // Boost volume\r\n\r\n                // Connect the audio source to the gain node and the gain node to the destination (speakers)\r\n                source.connect(gainNode);\r\n                gainNode.connect(audioContext.destination);\r\n\r\n                audio.onended = resolve;\r\n                audio.onerror = reject;\r\n                audio.play();\r\n              })\r\n              .catch(reject);\r\n          });\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Server TTS failed:\", error);\r\n      }\r\n    } else {\r\n      // If Google TTS isn't enabled, fallback to Web Speech API\r\n      await webTextToSpeech(text, voiceSpeed);\r\n    }\r\n  }\r\n\r\n  const verbs = {\r\n    Male: { enter: '', leave: '' },\r\n    Female: { enter: '', leave: '' }\r\n  };\r\n\r\n  function getUserGender(userName) {\r\n    const user = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.find((user) => user.name === userName);\r\n    return user ? user.gender : null;\r\n  }\r\n\r\n  // Handles user entering and leaving actions\r\n  function userAction(user, actionType, userGender) {\r\n    const shouldPlayAction = (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.shouldEnableSetting)('sound', 'presence');\r\n    // If neither beep and voice is enabled, exit early.\r\n    if (!shouldPlayAction) return;\r\n\r\n    const gender = userGender || 'Male'; // Default to 'Male' if no gender provided\r\n    const userToTrack = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.find(userToTrack => userToTrack.name === user);\r\n    const action = actionType === \"enter\" ? verbs[gender].enter : verbs[gender].leave;\r\n    const frequencies = actionType === \"enter\" ? userEnteredFrequencies : userLeftFrequencies;\r\n\r\n    playBeep(frequencies, beepVolume);\r\n    setTimeout(() => textToSpeech(`${userToTrack.pronunciation} ${action}`, voiceSpeed), 300);\r\n  }\r\n\r\n\r\n  // EMPOWERMENT PANEL AND USER COUNTER\r\n\r\n  // Retrieve body element to inject this beast elements\r\n  const bodyElement = document.querySelector('body');\r\n  // Create parent container for the beast elements\r\n  const empowermentButtonsPanel = document.createElement('div');\r\n  empowermentButtonsPanel.classList.add(\"empowerment-panel\");\r\n\r\n  // Create chat user count container to store the user count number\r\n  const chatUserCount = document.createElement('div');\r\n  chatUserCount.classList.add(\"chat-user-count\");\r\n  chatUserCount.title = 'Current Chat Users Count';\r\n  chatUserCount.innerHTML = '0';  // Set initial value as 0\r\n\r\n  // Append user count element inside empowerment panel\r\n  empowermentButtonsPanel.appendChild(chatUserCount);\r\n  // Append panel element inside the body\r\n  bodyElement.appendChild(empowermentButtonsPanel);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  // NEW CHAT USER LIST (START)\r\n\r\n  // Function to dynamically apply background color\r\n  function applyDynamicBackgroundColor() {\r\n    // Create a new <style> element\r\n    const newChatUserListStyles = document.createElement('style');\r\n    newChatUserListStyles.classList.add(\"userlist-dynamic-background\");\r\n\r\n    // Get the dynamic background color\r\n    const dynamicBackgroundColor = getComputedStyle(document.querySelector('.chat .messages')).backgroundColor;\r\n\r\n    // Define the styles with only background color\r\n    const userListStyles = `\r\n    #chat-general .smile-tab {\r\n      background-color: ${dynamicBackgroundColor};\r\n    }\r\n    .chat-user-list {\r\n      background-color: ${dynamicBackgroundColor};\r\n    }\r\n  `;\r\n\r\n    // Set the innerHTML of the style element to the styles\r\n    newChatUserListStyles.innerHTML = userListStyles;\r\n    // Append the <style> element to the document head\r\n    document.head.appendChild(newChatUserListStyles);\r\n  }\r\n\r\n  // Call the function to apply the dynamic background color\r\n  applyDynamicBackgroundColor();\r\n\r\n  // Function to calculate time spent on the site\r\n  function calculateTimeOnSite(registeredDate) {\r\n    const totalSeconds = Math.floor((new Date() - new Date(registeredDate)) / 1000);\r\n    const years = Math.floor(totalSeconds / (365 * 24 * 60 * 60));\r\n    const months = Math.floor((totalSeconds % (365 * 24 * 60 * 60)) / (30.44 * 24 * 60 * 60));\r\n    const days = Math.floor((totalSeconds % (30.44 * 24 * 60 * 60)) / (24 * 60 * 60));\r\n    const hours = Math.floor((totalSeconds % (24 * 60 * 60)) / (60 * 60));\r\n    const minutes = Math.floor((totalSeconds % (60 * 60)) / 60);\r\n    const seconds = totalSeconds % 60;\r\n\r\n    const timeComponents = [];\r\n\r\n    if (years > 0) {\r\n      timeComponents.push(`${years} year${years > 1 ? 's' : ''}`);\r\n      if (months > 0) timeComponents.push(`${months} month${months > 1 ? 's' : ''}`);\r\n    } else if (months > 1 || (months === 1 && days > 0)) {\r\n      timeComponents.push(`${months} month${months > 1 ? 's' : ''}`);\r\n      if (days > 0) timeComponents.push(`${days} day${days > 1 ? 's' : ''}`);\r\n    } else if (days > 0) {\r\n      timeComponents.push(`${days} day${days > 1 ? 's' : ''}`);\r\n      if (hours > 0) timeComponents.push(`${hours} hour${hours > 1 ? 's' : ''}`);\r\n      if (minutes > 0) timeComponents.push(`${minutes} minute${minutes > 1 ? 's' : ''}`);\r\n    } else if (hours > 0) {\r\n      timeComponents.push(`${hours} hour${hours > 1 ? 's' : ''}`);\r\n      if (minutes > 0) timeComponents.push(`${minutes} minute${minutes > 1 ? 's' : ''}`);\r\n    } else if (minutes > 0) {\r\n      timeComponents.push(`${minutes} minute${minutes > 1 ? 's' : ''}`);\r\n      if (seconds > 0) timeComponents.push(`${seconds} second${seconds > 1 ? 's' : ''}`);\r\n    } else {\r\n      timeComponents.push(`${seconds} second${seconds > 1 ? 's' : ''}`);\r\n    }\r\n\r\n    return timeComponents.filter(Boolean).join(' '); // Filter out empty strings and join components\r\n  }\r\n\r\n  // Function to get rank information (class, color, and icon) based on status title in English\r\n  function getRankInfo(mainTitle) {\r\n    const statusData = {\r\n      '': { class: 'extra', icon: '', color: '#06B4E9' },\r\n      '': { class: 'cyber', icon: '', color: '#5681ff' },\r\n      '': { class: 'superman', icon: '', color: '#B543F5' },\r\n      '': { class: 'maniac', icon: '', color: '#DA0543' },\r\n      '': { class: 'racer', icon: '', color: '#FF8C00' },\r\n      '': { class: 'profi', icon: '', color: '#C1AA00' },\r\n      '': { class: 'driver', icon: '', color: '#2DAB4F' },\r\n      '': { class: 'amateur', icon: '', color: '#61B5B3' },\r\n      '': { class: 'newbie', icon: '', color: '#AFAFAF' }\r\n    };\r\n\r\n    const defaultData = { class: 'unknown', icon: '', color: '#000000' };\r\n    const rankInfo = statusData[mainTitle] || defaultData;\r\n\r\n    if (rankInfo.class === defaultData.class) {\r\n      console.log(`Class not found for status title: ${mainTitle}. Using default class: ${defaultData.class}`);\r\n    }\r\n\r\n    return rankInfo;\r\n  }\r\n\r\n  // Function to handle private message\r\n  function insertPrivate(userId) {\r\n    const userName = document.querySelector(`.name[data-user=\"${userId}\"]`).textContent;\r\n    const message = `<${userName}>`;\r\n\r\n    const textElement = document.querySelector('.messages .text');\r\n    textElement.value = message;\r\n\r\n    textElement.focus();\r\n    textElement.selectionEnd = textElement.value.length;\r\n  }\r\n\r\n  function createCircularProgress(percentage, color, isRevoked) {\r\n    const svgUrl = \"http://www.w3.org/2000/svg\";\r\n    const size = 20;\r\n    const center = size / 2;\r\n    const strokeWidth = 2;\r\n    const radius = center - strokeWidth;\r\n    const diameter = radius * 2;\r\n    const randomString = Math.random().toString(36).substring(2, 22);\r\n    const scaleMultiplier = !isRevoked && percentage === 0 ? 0.6 : 1;\r\n\r\n    const svg = document.createElementNS(svgUrl, \"svg\");\r\n    Object.entries({\r\n      width: size, height: size, viewBox: `0 0 ${size} ${size}`, xmlns: svgUrl\r\n    }).forEach(([k, v]) => svg.setAttribute(k, v));\r\n    svg.classList.add(\"circularProgress\");\r\n\r\n    if (isRevoked || percentage === 0) {\r\n      if (!isRevoked) {\r\n        const outerCircle = document.createElementNS(svgUrl, \"circle\");\r\n        Object.entries({\r\n          cx: center, cy: center, r: radius, fill: \"none\", stroke: color, \"stroke-width\": strokeWidth\r\n        }).forEach(([k, v]) => outerCircle.setAttribute(k, v));\r\n        outerCircle.classList.add(\"outerCircle\");\r\n        svg.appendChild(outerCircle);\r\n      }\r\n\r\n      const scale = (size / 24) * scaleMultiplier;\r\n      const offset = center - 12 * scale;\r\n      const closeIconGroup = document.createElementNS(svgUrl, \"g\");\r\n      closeIconGroup.setAttribute(\"transform\", `translate(${offset}, ${offset}) scale(${scale})`);\r\n      closeIconGroup.classList.add(\"closeIconGroup\");\r\n\r\n      const path = document.createElementNS(svgUrl, \"path\");\r\n      Object.entries({\r\n        d: \"M18.364 5.636a1 1 0 0 1 0 1.414L13.414 12l4.95 4.95a1 1 0 0 1-1.414 1.414L12 13.414l-4.95 4.95a1 1 0 0 1-1.414-1.414L10.586 12l-4.95-4.95a1 1 0 0 1 1.414-1.414L12 10.586l4.95-4.95a1 1 0 0 1 1.414 0z\",\r\n        fill: color\r\n      }).forEach(([k, v]) => path.setAttribute(k, v));\r\n\r\n      closeIconGroup.appendChild(path);\r\n      svg.appendChild(closeIconGroup);\r\n    } else {\r\n      const defs = document.createElementNS(svgUrl, \"defs\");\r\n      defs.classList.add(\"defs\");\r\n\r\n      const clipPath = document.createElementNS(svgUrl, \"clipPath\");\r\n      clipPath.setAttribute(\"id\", `clipInner-${randomString}`);\r\n      clipPath.classList.add(\"clipPath\");\r\n\r\n      const clipRect = document.createElementNS(svgUrl, \"rect\");\r\n      Object.entries({\r\n        x: center - radius, y: center - radius, width: diameter, height: 0, transform: `rotate(180, ${center}, ${center})`\r\n      }).forEach(([k, v]) => clipRect.setAttribute(k, v));\r\n      clipRect.classList.add(\"clipRect\");\r\n\r\n      const animate = document.createElementNS(svgUrl, \"animate\");\r\n      Object.entries({\r\n        attributeName: \"height\",\r\n        from: 0,\r\n        to: diameter * (percentage / 100),\r\n        begin: \"indefinite\",\r\n        dur: \"1s\",\r\n        fill: \"freeze\",\r\n        calcMode: \"spline\",\r\n        keySplines: \"0.4 0 0.2 1\", // Fast start, smooth stop\r\n        keyTimes: \"0;1\"\r\n      }).forEach(([k, v]) => animate.setAttribute(k, v));\r\n      animate.classList.add(\"animateProfileProgress\");\r\n\r\n      clipRect.appendChild(animate);\r\n      clipPath.appendChild(clipRect);\r\n      defs.appendChild(clipPath);\r\n      svg.appendChild(defs);\r\n\r\n      const outerCircle = document.createElementNS(svgUrl, \"circle\");\r\n      Object.entries({\r\n        cx: center, cy: center, r: radius, fill: \"none\", stroke: color, \"stroke-width\": strokeWidth\r\n      }).forEach(([k, v]) => outerCircle.setAttribute(k, v));\r\n      outerCircle.classList.add(\"outerCircle\");\r\n      svg.appendChild(outerCircle);\r\n\r\n      const innerCircle = document.createElementNS(svgUrl, \"circle\");\r\n      Object.entries({\r\n        cx: center, cy: center, r: radius, fill: color, \"clip-path\": `url(#clipInner-${randomString})`\r\n      }).forEach(([k, v]) => innerCircle.setAttribute(k, v));\r\n      innerCircle.classList.add(\"innerCircle\");\r\n      svg.appendChild(innerCircle);\r\n    }\r\n\r\n    return svg.outerHTML;\r\n  }\r\n\r\n  /**\r\n   * Calculates the percentage of a given number within its nearest range.\r\n   * The function dynamically determines the range based on the input value.\r\n   *\r\n   * @param {number} value - The input value to calculate the percentage for.\r\n   * @returns {number} - The percentage of the input value within its identified range.\r\n   */\r\n  function calculatePercentage(value) {\r\n    // Determine the lower bound of the range (this is smart, not hardcoded)\r\n    const lowerBound = Math.floor(value / 100) * 100; // Nearest lower multiple of 100\r\n    const upperBound = lowerBound + 100; // Nearest upper multiple of 100\r\n\r\n    // Calculate the percentage within the identified range\r\n    const percentage = ((value - lowerBound) / (upperBound - lowerBound)) * 100;\r\n\r\n    return percentage;\r\n  }\r\n\r\n  // Function to create a user element with avatar, name, and profile link based on user details\r\n  function createUserChatElement(userId, mainTitle, userName, bestSpeed, isRevoked) {\r\n    const avatarTimestamp = fetchedUsers[userId]?.avatarTimestamp;\r\n\r\n    // Ensure the bigAvatarUrl is only constructed if avatarTimestamp is not '00'\r\n    const bigAvatarUrl = avatarTimestamp !== '00' ? `/storage/avatars/${userId}_big.png?updated=${avatarTimestamp}` : '';\r\n\r\n    const newUserElement = document.createElement('div');\r\n    // Get rank information (class, color, icon)\r\n    const rankInfo = getRankInfo(mainTitle);\r\n    const rankClass = rankInfo.class;  // Rank class\r\n    const rankColor = rankInfo.color;  // Rank color\r\n    const rankIcon = rankInfo.icon;    // Rank icon (emoji)\r\n\r\n    newUserElement.classList.add(`user${userId}`, rankClass); // Assign the rank class\r\n\r\n    const newAvatarElement = document.createElement('div');\r\n    newAvatarElement.classList.add('avatar');\r\n\r\n    // Only create and append an image element if avatarTimestamp is not '00'\r\n    if (avatarTimestamp !== '00') {\r\n      const avatarImage = document.createElement('img');\r\n      avatarImage.src = bigAvatarUrl;\r\n      newAvatarElement.appendChild(avatarImage);\r\n    } else {\r\n      newAvatarElement.style.fontSize = '1.8rem';\r\n      // Insert a random SVG icon instead of an image when avatarTimestamp is '00'\r\n      newAvatarElement.innerHTML = (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.getRandomEmojiAvatar)();\r\n    }\r\n\r\n    const newNameElement = document.createElement('a');\r\n    newNameElement.classList.add('name');\r\n    newNameElement.title = '  ';\r\n    newNameElement.dataset.user = userId;\r\n    newNameElement.textContent = userName;\r\n\r\n    newNameElement.style.setProperty('color', rankColor, 'important');\r\n\r\n    const newProfileElement = document.createElement('a');\r\n    newProfileElement.classList.add('profile');\r\n    const title = `${rankIcon} ${mainTitle} - ${bestSpeed}`;\r\n    (0,_modules_tooltip_js__WEBPACK_IMPORTED_MODULE_10__.createCustomTooltip)(newProfileElement, title);\r\n    newProfileElement.target = '_blank';\r\n    newProfileElement.href = `/profile/${userId}/`;\r\n    let circularProgress = createCircularProgress(calculatePercentage(bestSpeed), rankColor, isRevoked);\r\n    // Use circular progress element for profile navigation from new chat user list\r\n    newProfileElement.innerHTML = circularProgress;\r\n    // Start animation after element is in DOM\r\n    setTimeout(() => {\r\n      const animateElement = newProfileElement.querySelector('.animateProfileProgress');\r\n      if (animateElement) animateElement.beginElement();\r\n    }, 10);\r\n    // Add event listener click with Hold Ctrl Key to open profile into iframe\r\n    newProfileElement.addEventListener('click', function (event) {\r\n      event.preventDefault();\r\n      if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed) {\r\n        // Open the profile in a new tab\r\n        window.open(_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.profileBaseUrl + userId, '_blank');\r\n      } else {\r\n        // Load the profile into the iframe\r\n        loadProfileIntoIframe(_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.profileBaseUrl + userId);\r\n      }\r\n    });\r\n\r\n    // Construct the URL for the messaging interface between two users\r\n    const messageInProfile = `${_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.profileBaseUrl}${_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.myUserId}/messages/${userId}/`;\r\n\r\n    // Attach a click event listener to the newNameElement element\r\n    newNameElement.addEventListener('click', function (event) {\r\n      // Check if both Ctrl and Shift keys are pressed during the click event\r\n      if (event.ctrlKey && event.shiftKey) {\r\n        // If both keys are pressed, open the messaging URL in a new tab\r\n        const newTab = window.open(messageInProfile, '_blank');\r\n        if (newTab) newTab.focus(); // Attempt to make the new tab active\r\n      }\r\n      // Check if only the Ctrl key is pressed\r\n      else if (event.ctrlKey) {\r\n        // If Ctrl is pressed, load the messaging interface URL into the iframe\r\n        loadProfileIntoIframe(messageInProfile);\r\n      }\r\n      // If neither Ctrl nor Shift is pressed, initiate a private chat message\r\n      else {\r\n        // The insertPrivate function handles sending a private message to the specified user\r\n        insertPrivate(userId);\r\n      }\r\n    });\r\n\r\n    newUserElement.appendChild(newAvatarElement);\r\n    newUserElement.appendChild(newNameElement);\r\n    newUserElement.appendChild(newProfileElement);\r\n\r\n    // Check if there is a user in 'usersToTrack' array by their name and state\r\n    const userToTrack = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.find((user) =>\r\n      user.name === userName && user.state === 'thawed'\r\n    );\r\n\r\n    if (userToTrack) {\r\n      const trackedIcon = document.createElement('div');\r\n      trackedIcon.title = 'Tracked user';\r\n      trackedIcon.classList.add('tracked');\r\n      trackedIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.trackedSVG;\r\n      newUserElement.appendChild(trackedIcon);\r\n    }\r\n\r\n    // Check if the user is in the ignore list\r\n    const isIgnoredUser = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.ignored.includes(userName);\r\n\r\n    // Create and hide a message element if the user is in ignored\r\n    if (isIgnoredUser) {\r\n      const ignoredIcon = document.createElement('div');\r\n      ignoredIcon.title = 'Ignored user';\r\n      ignoredIcon.classList.add('ignored');\r\n      ignoredIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.ignoredSVG;\r\n      newUserElement.appendChild(ignoredIcon);\r\n    }\r\n\r\n    // Check if there is an <img> element with a src attribute containing the word \"moderator\" inside the <ins> element\r\n    const hasModeratorIcon = document.querySelector(`.userlist-content ins.user${userId} img[src*=\"moderator\"]`);\r\n\r\n    // Check if the user is in the moderator list\r\n    const isModerator = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.moderator.includes(userName);\r\n\r\n    // If a moderator icon is found or the current user is in the moderator array, append the moderator icon.\r\n    if (hasModeratorIcon || isModerator) {\r\n      const moderatorIcon = document.createElement('div');\r\n      moderatorIcon.classList.add('moderator');\r\n      moderatorIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.moderatorSVG; // Assuming 'icons.moderatorSVG' contains the SVG for the icon\r\n      newUserElement.appendChild(moderatorIcon);\r\n    }\r\n\r\n    return newUserElement;\r\n  }\r\n\r\n  // Function to update users in the custom chat\r\n  async function refreshUserList(retrievedLogin, actionType) {\r\n    try {\r\n      // Get the original user list container\r\n      const originalUserListContainer = document.querySelector('.userlist-content');\r\n\r\n      // Get or create the user list container\r\n      let userListContainer = document.querySelector('.chat-user-list');\r\n      if (!userListContainer) {\r\n        userListContainer = document.createElement('div');\r\n        userListContainer.classList.add('chat-user-list');\r\n\r\n        // Find the element with the class \"userlist\"\r\n        const userlistElement = document.querySelector('.userlist');\r\n\r\n        // Append the userListContainer to the userlistElement if found\r\n        if (userlistElement) {\r\n          userlistElement.appendChild(userListContainer);\r\n        }\r\n      }\r\n\r\n      // Define the rank order\r\n      const rankOrder = ['extra', 'cyber', 'superman', 'maniac', 'racer', 'profi', 'driver', 'amateur', 'newbie'];\r\n\r\n      // Create an object to store subparent elements for each rank class\r\n      const rankSubparents = {};\r\n\r\n      // Check if subparent elements already exist, if not, create them\r\n      rankOrder.forEach(rankClass => {\r\n        const existingSubparent = userListContainer.querySelector(`.rank-group-${rankClass}`);\r\n        if (!existingSubparent) {\r\n          rankSubparents[rankClass] = document.createElement('div');\r\n          rankSubparents[rankClass].classList.add(`rank-group-${rankClass}`);\r\n          userListContainer.appendChild(rankSubparents[rankClass]);\r\n        } else {\r\n          rankSubparents[rankClass] = existingSubparent;\r\n        }\r\n      });\r\n\r\n      // Create a set to store existing user IDs in the updated user list\r\n      const existingUserIds = new Set();\r\n\r\n      // Iterate over each user element in the original user list\r\n      for (const userElement of originalUserListContainer.querySelectorAll('ins')) {\r\n        const nameElement = userElement.querySelector('.name');\r\n        const userId = nameElement.getAttribute('data-user');\r\n        const userName = nameElement.textContent;\r\n\r\n        // Check if the user already exists in the updated user list\r\n        if (!existingUserIds.has(userId)) {\r\n          try {\r\n            // Retrieve the user's profile data\r\n            const { rank: mainTitle, login, registeredDate, bestSpeed, ratingLevel, friends, cars, avatarTimestamp } = await (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.getUserProfileData)(userId);\r\n\r\n            // If the user data is not already stored in the fetchedUsers object\r\n            if (!fetchedUsers[userId]) {\r\n              // Set rank, login, registeredDate, bestSpeed, ratingLevel, friends, cars, and avatarTimestamp\r\n              fetchedUsers[userId] = {\r\n                rank: mainTitle,\r\n                login,\r\n                registered: registeredDate,\r\n                bestSpeed,\r\n                ratingLevel,\r\n                friends,\r\n                cars,\r\n                avatarTimestamp\r\n              };\r\n            } else {\r\n              // Update the user's data\r\n              fetchedUsers[userId].rank = mainTitle;\r\n              fetchedUsers[userId].login = login;\r\n              fetchedUsers[userId].registered = registeredDate;\r\n              fetchedUsers[userId].bestSpeed = bestSpeed;\r\n              fetchedUsers[userId].ratingLevel = ratingLevel;\r\n              fetchedUsers[userId].friends = friends;\r\n              fetchedUsers[userId].cars = cars;\r\n              fetchedUsers[userId].avatarTimestamp = avatarTimestamp;\r\n            }\r\n\r\n            // Logging user action (enter or leave) using the formatted time\r\n            if (retrievedLogin === userName) {\r\n              if (actionType === 'enter') {\r\n                fetchedUsers[userId].visits = (fetchedUsers[userId].visits || 0) + 1;\r\n                fetchedUsers[userId].tracked = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.some(u => u.name === retrievedLogin);\r\n              }\r\n            }\r\n\r\n            // Get the rank info from getRankInfo, which now returns an object with class, color, and icon\r\n            const { class: rankClass } = getRankInfo(mainTitle);  // Destructure the returned object to get the rank class\r\n\r\n            // Check if the user with the same ID already exists in the corresponding rank group\r\n            const existingUserElement = rankSubparents[rankClass].querySelector(`.user${userId}`);\r\n            if (!existingUserElement) {\r\n              const newUserElement = createUserChatElement(userId, mainTitle, userName, bestSpeed, userElement.classList.contains('revoked'));\r\n              // Add the user to the corresponding rank group\r\n              rankSubparents[rankClass].appendChild(newUserElement);\r\n              // Make sure the mutation observer for the new users changed flag to false to make it work\r\n              if (!isInitialObservation) addShakeEffect(newUserElement); // Add shake effect on entered users\r\n            }\r\n\r\n            // Update existing user IDs\r\n            existingUserIds.add(userId);\r\n          } catch (error) {\r\n            console.error(`Error fetching profile summary for user ${userId}:`, error);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Additional removal logic based on your provided code\r\n      userListContainer.querySelectorAll('.chat-user-list [class^=\"user\"]').forEach(userElement => {\r\n        const userId = userElement.querySelector('.name').getAttribute('data-user');\r\n        if (!existingUserIds.has(userId)) {\r\n          userElement.remove();\r\n        }\r\n      });\r\n\r\n      // Sorting logic (applied after all users are created)\r\n      Object.values(rankSubparents).forEach(rankGroup =>\r\n        [...rankGroup.children]\r\n          .sort((a, b) =>\r\n            (fetchedUsers[b.querySelector('.name')?.getAttribute('data-user')]?.bestSpeed || 0) -\r\n            (fetchedUsers[a.querySelector('.name')?.getAttribute('data-user')]?.bestSpeed || 0)\r\n          )\r\n          .forEach(el => rankGroup.appendChild(el))\r\n      );\r\n\r\n      // Update localStorage outside the if conditions\r\n      localStorage.setItem('fetchedUsers', JSON.stringify(fetchedUsers));\r\n\r\n      // Call updateUserCountText to refresh user count display\r\n      (0,_modules_cache_js__WEBPACK_IMPORTED_MODULE_4__.updateUserCountText)();\r\n\r\n    } catch (error) {\r\n      console.error('Error refreshing user list:', error);\r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n  // NEW CHAT USER LIST (END)\r\n\r\n\r\n  // Define reference for chat user list\r\n  const userList = document.querySelector('.userlist-content');\r\n\r\n  // Initialize user tracking map\r\n  let userMap = new Map(); // Store as [userId]: {userName, ...}\r\n  let prevUserCount = 0;\r\n  let isInitialObservation = true; // Initialize the flag for initial observation\r\n\r\n  let isAnimated = false;\r\n\r\n  function logUserAction(userId, actionType) {\r\n    if (userId && actionType) {\r\n      // Initialize user object and ensure actionLog is an array\r\n      fetchedUsers[userId] = fetchedUsers[userId] || {};\r\n      fetchedUsers[userId].actionLog = fetchedUsers[userId].actionLog || [];\r\n\r\n      // Log the action\r\n      fetchedUsers[userId].actionLog.push({\r\n        type: actionType,\r\n        timestamp: (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.getCurrentTimeFormatted)()\r\n      });\r\n    } else {\r\n      console.error('Missing userId or actionType');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the given user count element with the count, adjusting the font size based on the number of digits.\r\n   * @param {HTMLElement} element - The DOM element displaying the user count.\r\n   * @param {number} count - The user count.\r\n   */\r\n  function updateUserCount(element, count) {\r\n    if (!element) return; // Exit if the element doesn't exist.\r\n    const digits = count.toString().length;\r\n    element.textContent = count;\r\n    element.style.fontSize = Math.max(24 - (digits - 1) * 2, 12) + 'px';\r\n  }\r\n\r\n  // Function to animate user count change\r\n  function animateUserCount(actualUserCount, userCountElement) {\r\n    let count = 0;\r\n    const speed = 20;\r\n\r\n    const userCountIncrement = () => {\r\n      if (count <= actualUserCount) {\r\n        const progress = Math.min(count / (actualUserCount || 1), 1); // Handle zero case\r\n        updateUserCount(userCountElement, count++);\r\n        userCountElement.style.filter = `grayscale(${100 - progress * 100}%)`;\r\n        setTimeout(userCountIncrement, speed);\r\n      } else {\r\n        (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.addPulseEffect)(userCountElement);\r\n        isAnimated = true;\r\n      }\r\n    };\r\n\r\n    setTimeout(userCountIncrement, speed);\r\n  }\r\n\r\n  // Mutation Observer for new users\r\n  const chatUsersObserver = new MutationObserver((0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.debounce)((mutations) => {\r\n    mutations.forEach((mutation) => {\r\n      if (mutation.type === 'childList') {\r\n        const soundSwitcher = document.querySelector('#voice, #beep, #silence');\r\n        const isSilence = soundSwitcher && soundSwitcher.id === 'silence';\r\n        const chatHidden = document.querySelector('#chat-wrapper.chat-hidden');\r\n        const userCountElement = document.querySelector('.chat-user-count');\r\n\r\n        if (chatHidden) {\r\n          // If the chat is hidden, update the user count to 0 and exit early\r\n          userCountElement.style.filter = \"grayscale(100%)\";\r\n          userCountElement.textContent = \"0\";\r\n          return;\r\n        }\r\n\r\n        // Build current user map\r\n        const newUsers = new Map(\r\n          Array.from(userList.children)\r\n            .map(child => {\r\n              const nameElement = child.querySelector('.name');\r\n              const userId = nameElement?.getAttribute('data-user');\r\n              const userName = nameElement?.textContent?.trim();\r\n              return userId ? [userId, { userName }] : null;\r\n            })\r\n            .filter(Boolean) // Remove null entries\r\n        );\r\n\r\n        // Handle initial observation\r\n        if (isInitialObservation) {\r\n          if (userCountElement && Number(userCountElement.textContent) === 0 && !isAnimated) {\r\n            animateUserCount(newUsers.size, userCountElement);\r\n          }\r\n          newUsers.forEach((value, key) => userMap.set(key, value));\r\n          setTimeout(() => {\r\n            isInitialObservation = false; // Mark the initial observation as complete\r\n          }, 2000); // After a small delay\r\n          return; // Skip processing for initial load\r\n        }\r\n\r\n        // Detect users who entered (exist in newUsers but not in userMap)\r\n        let entered = [...newUsers].filter(([userId]) => !userMap.has(userId))\r\n          .map(([userId, data]) => ({ userId, ...data }));\r\n\r\n        // Detect users who left (exist in userMap but not in newUsers)\r\n        let left = [...userMap].filter(([userId]) => !newUsers.has(userId))\r\n          .map(([userId, data]) => ({ userId, userName: data.userName }));\r\n\r\n        // Reassign userMap instead of clearing and repopulating it\r\n        userMap = new Map(newUsers);\r\n\r\n        // User count management\r\n        const currentCount = userMap.size;\r\n        if (currentCount !== prevUserCount && isAnimated) {\r\n          updateUserCount(userCountElement, currentCount);\r\n          userCountElement.style.filter = currentCount > 0 ? 'none' : 'grayscale(100%)';\r\n          (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.addPulseEffect)(userCountElement);\r\n        }\r\n\r\n        // Common logic for processing both entered and left users\r\n        function processUserAction(user, actionType) {\r\n          const { userName, userId } = user;\r\n          const userGender = getUserGender(userName);\r\n          const isTracked = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.some(u => u.name === userName && u.state === 'thawed');\r\n\r\n          (0,_modules_notifications_js__WEBPACK_IMPORTED_MODULE_11__.showUserAction)(userName, actionType === \"enter\" ? _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.enterSVG : _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.leaveSVG, actionType === \"enter\");\r\n          refreshUserList(userName, actionType);\r\n          logUserAction(userId, actionType);\r\n\r\n          if (!isSilence && isTracked) {\r\n            userAction(userName, actionType, userGender);\r\n          }\r\n        }\r\n\r\n        // Process entries\r\n        entered.forEach(newUser => processUserAction(newUser, \"enter\"));\r\n\r\n        // Process exits\r\n        left.forEach(oldUser => processUserAction(oldUser, \"leave\"));\r\n\r\n\r\n        prevUserCount = currentCount; // Update previous count for next mutation\r\n      }\r\n    });\r\n  }, _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.debounceTimeout));\r\n\r\n  // Start observing\r\n  chatUsersObserver.observe(userList, { childList: true });\r\n\r\n  // Button to close the chat\r\n  const chatCloseButton = document.querySelector('.mostright');\r\n\r\n  // Event listener for mostright click event\r\n  chatCloseButton.addEventListener('click', () => {\r\n    // Trigger the logic you want to perform when the mostright button is clicked\r\n    setTimeout(() => {\r\n      // Check if the chat is not closed\r\n      const chatHidden = document.querySelector('#chat-wrapper.chat-hidden');\r\n      if (chatHidden) {\r\n        // Avoid \"newMessagesObserver\" run the call functions multiple times when the chat opens again\r\n        isInitialized = false;\r\n      } else {\r\n        // Call the function to assign all the removing functionality again after the chat was closed\r\n        executeMessageRemover();\r\n        // Set chat field focus\r\n        (0,_modules_chat_js__WEBPACK_IMPORTED_MODULE_9__.setChatFieldFocus)();\r\n        // Allow after \"N\" delay to run the \"newMessagesObserver\" call functions safely without repeating\r\n        isInitialized = false;\r\n        setTimeout(() => (isInitialized = false), 3000);\r\n      }\r\n    }, 300);\r\n  });\r\n\r\n  // Function to restore the chat state based on 'shouldShowPopupMessage' key in localStorage\r\n  function restoreChatState() {\r\n    // Main chat parent wrap element\r\n    const chatMainWrapper = document.querySelector('#chat-fixed-placeholder');\r\n\r\n    // Check if the key exists in localStorage\r\n    if ('shouldShowPopupMessage' in localStorage) {\r\n      // Retrieve the value from localStorage\r\n      const shouldShowPopupMessage = JSON.parse(localStorage.getItem('shouldShowPopupMessage'));\r\n\r\n      // Set the display property based on the retrieved value\r\n      chatMainWrapper.style.display = shouldShowPopupMessage ? 'none' : 'unset';\r\n    } else {\r\n      // Default to 'none' if the key doesn't exist\r\n      chatMainWrapper.style.display = 'none';\r\n    }\r\n  }\r\n\r\n  // Call restoreChatState when needed, for example, on page load\r\n  restoreChatState();\r\n\r\n  // Check if the key exists in localStorage\r\n  if (!('shouldShowPopupMessage' in localStorage)) {\r\n    localStorage.setItem('shouldShowPopupMessage', false);\r\n  }\r\n\r\n  // Custom chat hider with hotkeys Ctr + Space\r\n  document.addEventListener('keydown', (event) => {\r\n    // Check if Ctrl key and Space key are pressed simultaneously\r\n    if (event.ctrlKey && event.code === 'Space') {\r\n      // Main chat parent wrap element\r\n      const chatMainWrapper = document.querySelector('#chat-fixed-placeholder');\r\n      // Check if the 'style' attribute is present\r\n      const hasStyleAttribute = chatMainWrapper.hasAttribute('style');\r\n      // Check if the 'display' property is set on chatMainWrapper element\r\n      const isDisplayUnset = chatMainWrapper.style.display === 'unset';\r\n      // Popup messages container element\r\n      const popupMessagesContainer = document.querySelector('.popup-messages-container');\r\n\r\n      // Toggle the display property\r\n      if (hasStyleAttribute) {\r\n        if (isDisplayUnset) {\r\n          // Set the display property to 'none'\r\n          chatMainWrapper.style.display = 'none';\r\n          localStorage.setItem('shouldShowPopupMessage', true);\r\n        } else {\r\n          // Set the display property to 'unset'\r\n          chatMainWrapper.style.display = 'unset';\r\n          localStorage.setItem('shouldShowPopupMessage', false);\r\n\r\n          // Retrieve the chat input field and length popup container based on the current URL\r\n          const { inputField } = retrieveChatElementsByRoomType(); // Use your helper function\r\n\r\n          // Check if inputField is valid before focusing\r\n          if (inputField) {\r\n            inputField.focus(); // Set focus to the chat input field\r\n          } else {\r\n            console.error('Input field not found. Cannot set focus.');\r\n          }\r\n        }\r\n      } else {\r\n        // Initial case: Set the display property to 'none'\r\n        chatMainWrapper.style.display = 'none';\r\n        localStorage.setItem('shouldShowPopupMessage', true);\r\n      }\r\n\r\n      // Remove the element with class 'popup-messages-container' if it exists and display is 'unset'\r\n      if (popupMessagesContainer && hasStyleAttribute && isDisplayUnset) {\r\n        popupMessagesContainer.remove();\r\n      }\r\n    }\r\n  });\r\n\r\n  // EVERY NEW MESSAGE READER\r\n\r\n  // Initialize the variable to keep track of the last username seen\r\n  let lastUsername = null;\r\n\r\n  // Set the flag as false for the mention beep sound to trigger at first usual beep sound for usual messages\r\n  let isMention = false;\r\n\r\n  // Function to check if a username is mentioned in the message\r\n  function isMentionForMe(message) {\r\n    const messageLowercase = message.toLowerCase();\r\n    return _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.mentionKeywords.some(keyword => messageLowercase.includes(keyword.toLowerCase()));\r\n  }\r\n\r\n  function replaceWithPronunciation(text) {\r\n    if (text === null) return text;\r\n\r\n    // Combine all usernames that need replacement\r\n    const allUsernames = [\r\n      ..._modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.map(user => user.name),\r\n      ..._modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usernameReplacements.map(replacement => replacement.original)\r\n    ];\r\n\r\n    // Create a pattern to match any character that is part of a word (including Cyrillic characters).\r\n    const pattern = new RegExp(`(${allUsernames.join('|')})`, 'gu');\r\n\r\n    return text.replace(pattern, (matched) => {\r\n      // Priority 1: Check username replacements\r\n      const replacement = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usernameReplacements.find(r => r.original === matched);\r\n      if (replacement) return replacement.replacement;\r\n\r\n      // Priority 2: Check tracked user pronunciations\r\n      const trackedUser = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.find(user => user.name === matched);\r\n      return trackedUser?.pronunciation || matched;\r\n    });\r\n  }\r\n\r\n\r\n\r\n  const rgbToHsl = (r, g, b) => {\r\n    r /= 255;\r\n    g /= 255;\r\n    b /= 255;\r\n\r\n    const max = Math.max(r, g, b);\r\n    const min = Math.min(r, g, b);\r\n    let h, s, l = (max + min) / 2;\r\n\r\n    if (max === min) {\r\n      h = s = 0; // Achromatic\r\n    } else {\r\n      const delta = max - min;\r\n      s = l < 0.5 ? delta / (max + min) : delta / (2 - max - min);\r\n      h = (\r\n        max === r\r\n          ? (g - b) / delta + (g < b ? 6 : 0)\r\n          : max === g\r\n            ? (b - r) / delta + 2\r\n            : (r - g) / delta + 4\r\n      ) / 6;\r\n    }\r\n\r\n    h = Math.round(h * 360); // Convert to degrees\r\n    s = Math.min(Math.round(s * 100), 90); // Cap saturation at 90\r\n    l = Math.round(l * 100); // Convert lightness to 0100\r\n\r\n    // Adjust hue to allow only 0230 and 280360 ranges\r\n    if (h > 215 && h < 280) {\r\n      h = h < 255 ? 215 : 280; // Shift to nearest valid range\r\n    }\r\n\r\n    return { h, s, l };\r\n  };\r\n\r\n\r\n  const hslToRgb = (h, s, l) => {\r\n    s /= 100; l /= 100;\r\n    let r, g, b;\r\n    if (s === 0) r = g = b = l * 255; // Achromatic\r\n    else {\r\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;\r\n      const hue2rgb = (p, q, t) => {\r\n        if (t < 0) t += 1;\r\n        if (t > 1) t -= 1;\r\n        return t < 1 / 6 ? p + (q - p) * 6 * t :\r\n          t < 1 / 2 ? q :\r\n            t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :\r\n              p;\r\n      };\r\n      r = Math.round(hue2rgb(p, q, h / 360 + 1 / 3) * 255);\r\n      g = Math.round(hue2rgb(p, q, h / 360) * 255);\r\n      b = Math.round(hue2rgb(p, q, h / 360 - 1 / 3) * 255);\r\n    }\r\n    return `rgb(${r}, ${g}, ${b})`;\r\n  };\r\n\r\n  // Normalize chat username color to be readable in the personal messages panel\r\n  function normalizeUsernameColor(initialColor) {\r\n    const [r, g, b] = initialColor.match(/\\d+/g).map(Number);\r\n    const { h, s, l } = rgbToHsl(r, g, b);\r\n\r\n    // Adjust lightness to ensure it's at least 50\r\n    const normalizedLightness = l < 50 ? 50 : l;\r\n    const finalColor = hslToRgb(h, s, normalizedLightness);\r\n\r\n    // Round the RGB values in one go\r\n    return finalColor;\r\n  }\r\n\r\n  async function getLatestMessageData() {\r\n    const messageElement = document.querySelector('.messages-content div p:last-of-type');\r\n    if (!messageElement) return null;\r\n\r\n    // Inline helper: collects text parts from a container's child nodes.\r\n    const collectMessageParts = async (container) =>\r\n      Array.from(container.childNodes)\r\n        .map(node =>\r\n          node.nodeType === Node.TEXT_NODE && node.textContent.trim() ? node.textContent.trim() :\r\n            node.nodeName === 'IMG' && node.getAttribute('title') ? node.getAttribute('title') :\r\n              node.nodeName === 'A' && node.getAttribute('href') ? node.getAttribute('href') : ''\r\n        )\r\n        .filter(Boolean);\r\n\r\n    // 1. Extract common message text.\r\n    let finalMessageText = (await collectMessageParts(messageElement)).join(' ').trim();\r\n    let messageType = \"common\"; // Default message type\r\n\r\n    // 2. Check for private messages\r\n    const privateMessageContainer = messageElement.querySelector('.room.private');\r\n    if (privateMessageContainer && privateMessageContainer.textContent.includes('[ ')) {\r\n      const privateMessageElement = messageElement.querySelector('span.private');\r\n      if (privateMessageElement) {\r\n        finalMessageText = (await collectMessageParts(privateMessageElement)).join(' ').trim();\r\n        messageType = \"private\";\r\n      }\r\n    }\r\n\r\n    // 3. Check for system messages\r\n    const systemMessageElement = messageElement.querySelector('.system-message');\r\n    if (systemMessageElement) {\r\n      let systemMessageText = (await collectMessageParts(systemMessageElement)).join(' ').trim();\r\n      systemMessageText = systemMessageText.replace(/<>\\s*/g, '');\r\n      finalMessageText = systemMessageText;\r\n      messageType = \"system\";\r\n    }\r\n\r\n    // 4. If still \"common\" and it mentions the user, mark as \"mention\".\r\n    if (messageType === \"common\" && isMentionForMe(finalMessageText)) {\r\n      messageType = \"mention\";\r\n    }\r\n\r\n    // Process localStorage: retrieve or initialize personalMessages.\r\n    const personalMessages = JSON.parse(localStorage.getItem('personalMessages')) || {};\r\n    const getCurrentDate = () => new Date().toLocaleDateString('en-CA');\r\n\r\n    // Extract message metadata.\r\n    const time = messageElement.querySelector('.time')?.textContent || 'N/A';\r\n    const usernameDataElement = messageElement.querySelector('.username span[data-user]');\r\n    const userId = usernameDataElement ? usernameDataElement.getAttribute('data-user') : null;\r\n    const extractedUsername = usernameDataElement ? usernameDataElement.textContent : 'SYSTEM';\r\n    const usernameColor = usernameDataElement ? usernameDataElement.parentElement.style.color : 'rgb(180,180,180)';\r\n    const normalizedColor = normalizeUsernameColor(usernameColor);\r\n    const messageKey = `${time}_${extractedUsername}`;\r\n\r\n    // Check if the message type is \"mention\" or \"private\", and if the username is not in the ignore list\r\n    const shouldSaveMessage = (\r\n      messageType === \"mention\" ||\r\n      messageType === \"private\"\r\n    ) && !_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.ignored.includes(extractedUsername);\r\n\r\n    // If the condition is met, save the message to localStorage\r\n    if (shouldSaveMessage) {\r\n      personalMessages[messageKey] = {\r\n        time,\r\n        date: getCurrentDate(),\r\n        username: extractedUsername,\r\n        usernameColor: normalizedColor,\r\n        message: finalMessageText,\r\n        type: messageType,\r\n        userId\r\n      };\r\n      localStorage.setItem('personalMessages', JSON.stringify(personalMessages));\r\n    }\r\n\r\n    // Extract username (defaulting to \"SYSTEM\") and build prefix.\r\n    const usernameContainer = messageElement.querySelector('.username');\r\n    const usernameText = usernameContainer ? usernameContainer.textContent.replace(/[<>]/g, '') : 'SYSTEM';\r\n\r\n    (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.highlightMentionWords)(); // Apply highlight for all message types\r\n\r\n    let prefix = (messageType === \"mention\" || messageType === \"private\")\r\n      ? `${replaceWithPronunciation(usernameText)} : `\r\n      : (usernameText !== lastUsername ? `${replaceWithPronunciation(usernameText)} : ` : \"\");\r\n\r\n    lastUsername = usernameText;\r\n\r\n    const messageText = prefix + replaceWithPronunciation(finalMessageText);\r\n    return { messageText, usernameText };\r\n  }\r\n\r\n  // Prevent the \"readNewMessages\" function from being called multiple times until all messages in the set have been read\r\n  let isReading = false;\r\n\r\n  // Create a Set to store the new messages\r\n  const newMessages = new Set();\r\n\r\n  // This function adds a new message to the Set and triggers the \"readNewMessages\" function if the Set was empty before\r\n  function addNewMessage(message) {\r\n    // Check if the new message is not already in the Set\r\n    if (!newMessages.has(message)) {\r\n      // Add the new message to the Set\r\n      newMessages.add(message);\r\n      // If the \"readNewMessages\" function is not already in progress, trigger it\r\n      if (!isReading) {\r\n        // Change the flag to true to be initialized accent beep sound for mention message\r\n        isReading = true;\r\n        readNewMessages();\r\n      }\r\n    }\r\n  }\r\n\r\n  // This function reads the new messages from the Set and removes them after reading\r\n  async function readNewMessages() {\r\n    // Read each message in sequence from the Set\r\n    for (let message of newMessages) {\r\n      // Call the textToSpeech function to read the message\r\n      await textToSpeech(message, voiceSpeed);\r\n      // Remove the message from the Set after reading\r\n      newMessages.delete(message);\r\n    }\r\n    // Set the isReading flag to false after reading all messages\r\n    isReading = false;\r\n  }\r\n\r\n\r\n\r\n  function applyChatMessageGrouping() {\r\n    // Get the messages container element\r\n    const messagesContainer = document.getElementById('chat-content');\r\n\r\n    // Get all the chat message elements from the messages container\r\n    const chatMessages = messagesContainer.querySelectorAll('.messages-content div p');\r\n\r\n    // Initialize variables\r\n    let previousUser = null;\r\n    let isFirstMessage = true;\r\n    let spacing = '14px';\r\n\r\n    // Loop through the chat messages\r\n    for (let i = 0; i < chatMessages.length; i++) {\r\n      const message = chatMessages[i];\r\n      const usernameElement = message.querySelector('span.username');\r\n\r\n      // Check if it's a system message with the \"system-message\" class\r\n      const isSystemMessage = message.querySelector('.system-message');\r\n\r\n      if (isSystemMessage) {\r\n        // Apply margins to system messages\r\n        message.style.marginTop = spacing;\r\n        message.style.marginBottom = spacing;\r\n      } else if (usernameElement) { // Check if the message contains a username\r\n        // Get the username from the current message\r\n        const usernameElementWithDataUser = usernameElement.querySelector('span[data-user]');\r\n\r\n        if (!usernameElementWithDataUser) {\r\n          continue; // Skip messages without a data-user element\r\n        }\r\n\r\n        let usernameText = usernameElementWithDataUser.textContent;\r\n\r\n        // Remove the \"<\" and \">\" symbols from the username if they are present\r\n        usernameText = usernameText.replace(/</g, '').replace(/>/g, '');\r\n\r\n        // Apply margin-top for the first message or when the user changes\r\n        if (previousUser === null || usernameText !== previousUser) {\r\n          // Check if it's not the first message overall\r\n          if (!isFirstMessage) {\r\n            // Add margin-top to create separation between the current message and the previous message\r\n            message.style.marginTop = spacing;\r\n          }\r\n        } else {\r\n          // Check if it's not the first message of the current user\r\n          if (!isFirstMessage) {\r\n            // Remove the margin-bottom property from the current message to remove any previously set margin\r\n            message.style.removeProperty('margin-bottom');\r\n          }\r\n        }\r\n\r\n        // Check if there is a next message\r\n        const hasNextMessage = i < chatMessages.length - 1;\r\n\r\n        // Check if there is a next message and it contains a username\r\n        if (hasNextMessage) {\r\n          const nextMessage = chatMessages[i + 1];\r\n          const nextUsernameElement = nextMessage.querySelector('span.username');\r\n\r\n          if (nextUsernameElement) {\r\n            const nextUsernameElementWithDataUser = nextUsernameElement.querySelector('span[data-user]');\r\n\r\n            if (!nextUsernameElementWithDataUser) {\r\n              continue; // Skip messages without a data-user element\r\n            }\r\n\r\n            // Get the username from the next message\r\n            const nextUsernameText = nextUsernameElementWithDataUser.textContent;\r\n\r\n            // Apply margin-bottom for the last message of each user\r\n            if (usernameText !== nextUsernameText) {\r\n              message.style.marginBottom = spacing;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Update the previousUser variable to store the current username\r\n        previousUser = usernameText;\r\n        // Set isFirstMessage to false to indicate that this is not the first message overall\r\n        isFirstMessage = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Call the function to apply chat message grouping\r\n  applyChatMessageGrouping();\r\n\r\n  // Time difference threshold (in milliseconds) to identify spam\r\n  const timeDifferenceThreshold = 400;\r\n  // Message limit per timeDifferenceThreshold\r\n  const messageLimit = 1;\r\n  // Object to track user-specific data\r\n  let userChatData = {};\r\n  // Maximum number of consecutive times a user is allowed to exceed the message limit\r\n  const thresholdMaxTries = 10;\r\n\r\n  // Function to format time difference\r\n  function formatTimeDifference(difference) {\r\n    // Define time units\r\n    const units = ['hour', 'minute', 'second', 'millisecond'];\r\n\r\n    // Calculate values for each time unit\r\n    const values = [\r\n      Math.floor(difference / (1000 * 60 * 60)), // hours\r\n      Math.floor((difference / (1000 * 60)) % 60), // minutes\r\n      Math.floor((difference / 1000) % 60), // seconds\r\n      difference % 1000 // milliseconds\r\n    ];\r\n\r\n    // Map each non-zero value to a formatted string with its corresponding unit\r\n    const formattedStrings = values\r\n      .map((value, index) => (value > 0 ? `${value} ${units[index]}${value > 1 ? 's' : ''}` : ''));\r\n\r\n    // Filter out empty strings (units with a value of 0) and join the remaining strings\r\n    const formattedTime = formattedStrings\r\n      .filter(Boolean)\r\n      .join(' ');\r\n\r\n    // Return the formatted time string\r\n    return formattedTime;\r\n  }\r\n\r\n  // Helper function to remove all messages by a user\r\n  function removeUserMessages(userId) {\r\n    const userMessages = document.querySelectorAll(`.messages-content span[data-user=\"${userId}\"]`);\r\n    userMessages.forEach(message => {\r\n      const pTag = message.closest('p');\r\n      if (pTag) {\r\n        pTag.remove();\r\n      }\r\n    });\r\n  }\r\n\r\n  const digits = '0-9';\r\n  const whitespaces = '\\\\s';\r\n  const latinChars = 'a-zA-Z';\r\n  const cyrillicChars = '--';\r\n  const commonSymbols = '!@#$%^&*()-_=+[\\\\]{}|;:\\'\",.<>/?`~';\r\n\r\n  // Special symbols as characters\r\n  const copyrightSymbol = '\\\\u00A9'; // \r\n  const trademarkSymbol = '\\\\u2122'; // \r\n  const registeredSymbol = '\\\\u00AE'; // \r\n  const leftDoubleAngleQuote = '\\\\u00AB'; // \r\n  const rightDoubleAngleQuote = '\\\\u00BB'; // \r\n  const plusMinus = '\\\\u00B1'; // \r\n  const multiplication = '\\\\u00D7'; // \r\n  const division = '\\\\u00F7'; // \r\n  const degreeSymbol = '\\\\u00B0'; // \r\n  const notEqual = '\\\\u2260'; // \r\n  const lessThanOrEqual = '\\\\u2264'; // \r\n  const greaterThanOrEqual = '\\\\u2265'; // \r\n  const infinity = '\\\\u221E'; // \r\n  const euroSymbol = '\\\\u20AC'; // \r\n  const poundSymbol = '\\\\u00A3'; // \r\n  const yenSymbol = '\\\\u00A5'; // \r\n  const sectionSymbol = '\\\\u00A7'; // \r\n  const bulletPoint = '\\\\u2022'; // \r\n  const ellipsis = '\\\\u2026'; // \r\n  const minus = '\\\\u2212'; // \r\n  const enDash = '\\\\u2013'; // \r\n  const emDash = '\\\\u2014'; // \r\n\r\n  // Arrow and Mathematical symbols as Unicode escape sequences\r\n  const leftArrow = '\\\\u2190'; // \r\n  const rightArrow = '\\\\u2192'; // \r\n  const upArrow = '\\\\u2191'; // \r\n  const downArrow = '\\\\u2193'; // \r\n\r\n  const half = '\\\\u00BD'; // \r\n  const oneThird = '\\\\u2153'; // \r\n  const twoThirds = '\\\\u2154'; // \r\n\r\n  const summation = '\\\\u2211'; // \r\n  const acuteAccent = '\\\\u00B4'; // \r\n\r\n  const emojiRanges = '\\\\uD83C-\\\\uDBFF\\\\uDC00-\\\\uDFFF';\r\n\r\n  // Initialized to store characters found in a message that are not allowed\r\n  let disallowedChars = null;\r\n\r\n  function messageContainsAllowedChars(message) {\r\n    const allowedCharsRegex = new RegExp(\r\n      `[${digits}${latinChars}${cyrillicChars}${whitespaces}${commonSymbols}` +\r\n      `${copyrightSymbol}${trademarkSymbol}${registeredSymbol}${leftDoubleAngleQuote}${rightDoubleAngleQuote}` +\r\n      `${plusMinus}${multiplication}${division}${degreeSymbol}${notEqual}${lessThanOrEqual}${greaterThanOrEqual}` +\r\n      `${infinity}${euroSymbol}${poundSymbol}${yenSymbol}${sectionSymbol}${bulletPoint}${ellipsis}${minus}${enDash}${emDash}` +\r\n      `${leftArrow}${rightArrow}${upArrow}${downArrow}${half}${oneThird}${twoThirds}${summation}` +\r\n      `${acuteAccent}${emojiRanges}]+`, 'gu' // previous 'g'\r\n    );\r\n\r\n    const allowedChars = message.match(allowedCharsRegex);\r\n\r\n    if (allowedChars && allowedChars.join('') === message) {\r\n      return true;\r\n    } else {\r\n      disallowedChars = message.replace(allowedCharsRegex, '');\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Helper function to handle threshold check\r\n  function handleThresholdExceeded(userId, generateLogUserInfo) {\r\n    if (userChatData[userId].thresholdMaxTries >= thresholdMaxTries) {\r\n      // Set 'banned' to true after passing the max thresholdMaxTries to remove user messages passing the messages limit checking\r\n      userChatData[userId].banned = true;\r\n      console.log(generateLogUserInfo(), 'color: pink');\r\n      console.log(`%c${userChatData[userId].userName} cannot send messages anymore`, 'color: pink');\r\n    }\r\n  }\r\n\r\n  // Function to track and handle spam messages\r\n  function banSpammer() {\r\n    // Get the current timestamp\r\n    const currentTime = new Date().getTime();\r\n\r\n    // Select the last p element in the chat\r\n    const latestMessage = document.querySelector('.messages-content p:last-child');\r\n\r\n    if (latestMessage) {\r\n      // Get user ID from the last message\r\n      const userIdElement = latestMessage.querySelector('span[data-user]');\r\n      const userId = userIdElement ? userIdElement.getAttribute('data-user') : null;\r\n\r\n      // Initialize user-specific data outside the if block\r\n      if (!userChatData[userId]) {\r\n        userChatData[userId] = {\r\n          messagesCount: 0,\r\n          thresholdMaxTries: 0,\r\n          time: currentTime,\r\n          userName: userIdElement ? userIdElement.textContent : 'Unknown User',\r\n          previousTime: null,\r\n          firstInteraction: true,\r\n          banned: false\r\n        };\r\n      }\r\n\r\n      // Calculate time difference\r\n      const timeDifference = currentTime - userChatData[userId].time;\r\n\r\n      // Function to generate log information dynamically\r\n      function generateLogUserInfo() {\r\n        return `%cID: ${userId}, Name: ${userChatData[userId].userName}, ` +\r\n          `Time Difference: ${formatTimeDifference(timeDifference)}, ` +\r\n          `Messages Count: ${userChatData[userId].messagesCount}, ` +\r\n          `Spam Tries: ${userChatData[userId].thresholdMaxTries}, ` +\r\n          `Banned: ${userChatData[userId].banned}`;\r\n      }\r\n\r\n      // Check if the message contains not allowed chars\r\n      if (!messageContainsAllowedChars(latestMessage.textContent, userId) && !userChatData[userId].banned) {\r\n        // Increase thresholdMaxTries on every limit pass\r\n        userChatData[userId].thresholdMaxTries++;\r\n        // If the message contains not allowed chars, log the information\r\n        console.log(\r\n          `%c${userChatData[userId].userName} has sent a message with not allowed characters ${disallowedChars}.\r\n          Threshold: ${userChatData[userId].thresholdMaxTries}.`,\r\n          'color: orange;'\r\n        );\r\n        handleThresholdExceeded(userId, generateLogUserInfo);\r\n      }\r\n\r\n      // Special handling for the first interaction\r\n      if (userChatData[userId].firstInteraction) {\r\n        console.log(`%c${userChatData[userId].userName} posted the first message for the current chat session.`, 'color: yellow');\r\n        userChatData[userId].firstInteraction = false;\r\n      }\r\n\r\n      // Check if the user is banned\r\n      else if (userChatData[userId].banned) {\r\n        // Remove all the messages by that user continuously until banned\r\n        removeUserMessages(userId);\r\n      } else {\r\n        if (timeDifference < timeDifferenceThreshold) {\r\n          // Check if the time difference is less than the threshold\r\n          userChatData[userId].messagesCount++;\r\n\r\n          if (userChatData[userId].messagesCount > messageLimit) {\r\n            // Remove all messages by that user if messages limit was exceeded\r\n            removeUserMessages(userId);\r\n\r\n            // Increase thresholdMaxTries on every limit pass\r\n            userChatData[userId].thresholdMaxTries++;\r\n\r\n            handleThresholdExceeded(userId, generateLogUserInfo);\r\n\r\n            // Log the information immediately after updating the values if not banned\r\n            if (!userChatData[userId].banned) {\r\n              console.log(generateLogUserInfo(), 'color: red');\r\n            }\r\n          } else {\r\n            // Log the information immediately after updating the values if not banned and not exceeding the limit\r\n            console.log(generateLogUserInfo(), 'color: green');\r\n          }\r\n        } else {\r\n          // If none of the above conditions are met, update user-specific data for the current interaction\r\n          userChatData[userId].previousTime = userChatData[userId].time;\r\n          userChatData[userId].time = currentTime;\r\n          userChatData[userId].messagesCount = 1;\r\n\r\n          // Log the information immediately after updating the values if not banned and not exceeding the limit\r\n          console.log(generateLogUserInfo(), 'color: green');\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  // POPUP MESSAGES START\r\n\r\n  // Set the maximum number of popup messages to display globally\r\n  const maxPopupMessagesCount = 10;\r\n\r\n  // Define an object to store the hue for each username\r\n  const usernameHueMap = {};\r\n  // Increase step for noticeable color changes\r\n  const hueStep = 15;\r\n\r\n  // Define the function to show popup messages when the main chat is hidden by hotkeys Ctrl + Space (only)\r\n  function showPopupMessage() {\r\n    // Check if the key 'shouldShowPopupMessage' exists and has a value of true\r\n    const shouldShowPopupMessage = localStorage.getItem('shouldShowPopupMessage');\r\n\r\n    // Stop execution if shouldShowPopupMessage is false\r\n    if (shouldShowPopupMessage !== 'true') {\r\n      return;\r\n    }\r\n\r\n    // Get the last message in the chat\r\n    const latestMessage = document.querySelector('.messages-content p:last-of-type');\r\n\r\n    if (latestMessage) {\r\n      // Extract elements for time and username from the latest message\r\n      const time = latestMessage.querySelector('.time');\r\n      const username = latestMessage.querySelector('.username');\r\n\r\n      const nodes = Array.from(latestMessage.childNodes);\r\n      const elements = nodes.map(node => {\r\n        if (node.nodeType === Node.TEXT_NODE) {\r\n          return { type: 'text', value: node.nodeValue.replace(/ /g, '\\u00A0') }; // Replace spaces with Unicode non-breaking space\r\n        } else if (node.nodeType === Node.ELEMENT_NODE) {\r\n          if (node.tagName.toLowerCase() === 'a' && node.classList.contains('private')) {\r\n            return { type: 'text', value: '\\u00A0' };\r\n          }\r\n          if (node.tagName.toLowerCase() === 'span' && node.classList.contains('private')) {\r\n            return { type: 'text', value: node.textContent.replace(/ /g, '\\u00A0') };\r\n          }\r\n          if (node.tagName.toLowerCase() === 'img') {\r\n            return { type: 'img', title: node.getAttribute('title') };\r\n          }\r\n          if (node.tagName.toLowerCase() === 'a') {\r\n            return { type: 'anchor', href: node.getAttribute('href') };\r\n          }\r\n        }\r\n      }).filter(Boolean);\r\n\r\n      // Extract relevant data from the time and username elements\r\n      const cleanTime = time.textContent.replace(/[\\[\\]]/g, '');\r\n      const cleanUsername = username.textContent.replace(/[<>]/g, '');\r\n\r\n      // Check if the hue for this username is already stored\r\n      let hueForUsername = usernameHueMap[cleanUsername];\r\n\r\n      // If the hue is not stored, generate a new random hue with the specified step\r\n      if (!hueForUsername) {\r\n        hueForUsername = Math.floor(Math.random() * (360 / hueStep)) * hueStep;\r\n        // Store the generated hue for this username\r\n        usernameHueMap[cleanUsername] = hueForUsername;\r\n      }\r\n\r\n      // Create or get the main container for all messages\r\n      let popupMessagesContainer = document.querySelector('.popup-messages-container');\r\n      if (!popupMessagesContainer) {\r\n        popupMessagesContainer = document.createElement('div');\r\n        popupMessagesContainer.classList.add('popup-messages-container');\r\n        document.body.appendChild(popupMessagesContainer);\r\n      }\r\n\r\n      // Check if the total number of messages in the container exceeds the maximum\r\n      if (popupMessagesContainer.childElementCount >= maxPopupMessagesCount) {\r\n        // Get the oldest message\r\n        const oldestMessage = popupMessagesContainer.firstChild;\r\n\r\n        // Apply a CSS class to initiate the fade-out animation\r\n        oldestMessage.classList.add('fade-out');\r\n\r\n        // After the animation duration, remove the message from the DOM\r\n        setTimeout(() => {\r\n          popupMessagesContainer.removeChild(oldestMessage);\r\n        }, 300); // Adjust the time to match your CSS animation duration\r\n      }\r\n\r\n      // Create a container div for each message\r\n      const popupChatMessage = document.createElement('div');\r\n      popupChatMessage.classList.add('popup-chat-message');\r\n      // Apply the hue-rotate filter to the entire message container\r\n      popupChatMessage.style.filter = `hue-rotate(${hueForUsername}deg)`;\r\n\r\n      // Append time SVG icon before the time\r\n      const timeIcon = document.createElement('div');\r\n      timeIcon.classList.add('time-icon');\r\n      timeIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.clockSVG;\r\n\r\n      // Append spans for each part with respective classes\r\n      const timeElement = document.createElement('div');\r\n      timeElement.classList.add('time');\r\n      timeElement.textContent = cleanTime;\r\n\r\n      // Append user SVG icon after the time\r\n      const userIcon = document.createElement('div');\r\n      userIcon.classList.add('user-icon');\r\n      userIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.userSVG;\r\n\r\n      const usernameElement = document.createElement('div');\r\n      usernameElement.classList.add('username');\r\n      usernameElement.textContent = cleanUsername;\r\n\r\n      // Append action SVG icon after the username\r\n      const actionIcon = document.createElement('div');\r\n      actionIcon.classList.add('action-icon');\r\n      actionIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.actionSVG;\r\n\r\n      const messageElement = document.createElement('div');\r\n      messageElement.classList.add('message');\r\n\r\n      // Append elements to the message container\r\n      popupChatMessage.appendChild(timeIcon);\r\n      popupChatMessage.appendChild(timeElement);\r\n      popupChatMessage.appendChild(userIcon);\r\n      popupChatMessage.appendChild(usernameElement);\r\n      popupChatMessage.appendChild(actionIcon);\r\n      popupChatMessage.appendChild(messageElement);\r\n\r\n      // Fill the message container with text, images, and anchors\r\n      elements.forEach(element => {\r\n        const elementContainer = document.createElement('div');\r\n\r\n        if (element.type === 'text') {\r\n          elementContainer.textContent = element.value;\r\n        } else if (element.type === 'img') {\r\n          elementContainer.innerHTML = `&nbsp;${element.title}&nbsp;`;\r\n        } else if (element.type === 'anchor') {\r\n          elementContainer.innerHTML = `&nbsp;${element.href}&nbsp;`;\r\n        }\r\n\r\n        messageElement.appendChild(elementContainer);\r\n      });\r\n\r\n      // Append the message container to the main container\r\n      popupMessagesContainer.appendChild(popupChatMessage);\r\n    }\r\n  }\r\n\r\n  // POPUP MESSAGES END\r\n\r\n  // Function to convert Cyrillic characters to Latin\r\n  function convertCyrillicToLatin(input) {\r\n    const cyrillicToLatinMap = {\r\n      '': 'A', '': 'B', '': 'V', '': 'G', '': 'D',\r\n      '': 'E', '': 'Yo', '': 'Zh', '': 'Z', '': 'I',\r\n      '': 'Y', '': 'K', '': 'L', '': 'M', '': 'N',\r\n      '': 'O', '': 'P', '': 'R', '': 'S', '': 'T',\r\n      '': 'U', '': 'F', '': 'Kh', '': 'Ts', '': 'Ch',\r\n      '': 'Sh', '': 'Shch', '': 'y', // '' maps to 'y'\r\n      '': 'Y', '': 'i', // '' maps to 'i'\r\n      '': 'E', '': 'Yu', '': 'Ya',\r\n      '': 'a', '': 'b', '': 'v', '': 'g', '': 'd',\r\n      '': 'e', '': 'yo', '': 'zh', '': 'z', '': 'i',\r\n      '': 'y', '': 'k', '': 'l', '': 'm', '': 'n',\r\n      '': 'o', '': 'p', '': 'r', '': 's', '': 't',\r\n      '': 'u', '': 'f', '': 'kh', '': 'ts', '': 'ch',\r\n      '': 'sh', '': 'shch', '': 'y', // '' maps to 'y'\r\n      '': 'y', '': 'i', // '' maps to 'i'\r\n      '': 'e', '': 'yu', '': 'ya'\r\n    };\r\n\r\n    // Convert the input string to Latin using the mapping\r\n    return input.split('').map(char => cyrillicToLatinMap[char] || char).join('');\r\n  }\r\n\r\n  // Function to convert Russian usernames\r\n  function convertRussianUsernameToLatin(username) {\r\n    // Use the conversion function on the username\r\n    return convertCyrillicToLatin(username);\r\n  }\r\n\r\n  // Skip reading the messages on page load to read them normally when the user is present and the page is stable\r\n  let isInitialized = false;\r\n  // Define the maximum number of messages per user\r\n  const maxMessagesPerUser = 5;\r\n\r\n  // Function to remove all messages from users in the ignored\r\n  function removeIgnoredUserMessages() {\r\n    document.querySelectorAll('.messages-content p').forEach(message => {\r\n      const usernameElement = message.querySelector('.username'); // Adjust selector if needed\r\n      const username = usernameElement?.textContent?.replace(/[<>]/g, '') || null;\r\n\r\n      if (username && _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.ignored.includes(username)) {\r\n        // console.log(`Hidden message from ignored user: ${username}`);\r\n        // Convert Cyrillic username to Latin\r\n        const latinUsername = convertRussianUsernameToLatin(username);\r\n        message.classList.add('ignored-user', latinUsername);\r\n        message.style.display = 'none'; // Hide the message\r\n      }\r\n    });\r\n  }\r\n\r\n  // Function to play sound as a notification for system message banned\r\n  function playSound() {\r\n    const marioGameOver = 'https://github.com/VimiummuimiV/Sounds/raw/refs/heads/main/Mario_Game_Over.mp3';\r\n    const audio = new Audio(marioGameOver);\r\n    audio.play();\r\n  }\r\n\r\n  // Function to detect a ban message based on the message text content\r\n  function isBanMessage(messageText) {\r\n    if (!messageText) return false; // Return false if messageText is null, undefined, or an empty string\r\n    return ['', '', ''].every(word => messageText.includes(word));\r\n  }\r\n\r\n  /**\r\n   * Normalizes the color of usernames and resets their filter based on the specified mode.\r\n   *\r\n   * @param {NodeList|Element} usernameElements - A NodeList of username elements or a single username element.\r\n   * @param {string} mode - The mode of operation; either 'one' to process a single username or 'all' to process multiple.\r\n   */\r\n  function normalizeAndResetUsernames(usernameElements, mode) {\r\n    if (!usernameElements) return; // Skip processing if undefined or null\r\n\r\n    if (mode === 'one') {\r\n      // Process a single username element.\r\n      const userSpan = usernameElements.querySelector('span[data-user]');\r\n      if (!userSpan) return; // Skip processing if child span is missing\r\n      const computedColor = getComputedStyle(usernameElements).color;\r\n      const normalizedColor = normalizeUsernameColor(computedColor);\r\n      usernameElements.style.setProperty('color', normalizedColor, 'important');\r\n      userSpan.style.setProperty('filter', 'invert(0)', 'important');\r\n    } else if (mode === 'all') {\r\n      // Process all username elements using forEach with return (which acts like continue)\r\n      Array.from(usernameElements).forEach(usernameElement => {\r\n        if (!usernameElement) return; // Skip this iteration if the element is falsy\r\n        const userSpan = usernameElement.querySelector('span[data-user]');\r\n        if (!userSpan) return; // Skip if child span is missing\r\n        const computedColor = getComputedStyle(usernameElement).color;\r\n        const normalizedColor = normalizeUsernameColor(computedColor);\r\n        usernameElement.style.setProperty('color', normalizedColor, 'important');\r\n        userSpan.style.setProperty('filter', 'invert(0)', 'important');\r\n      });\r\n    } else {\r\n      console.error(\"Invalid mode. Use 'one' or 'all'.\");\r\n    }\r\n  }\r\n\r\n  // Create a mutation observer to watch for new messages being added\r\n  const newMessagesObserver = new MutationObserver(async mutations => {\r\n    // If isInitialized is false, return without doing anything\r\n    if (!isInitialized) {\r\n      isInitialized = true;\r\n\r\n      // Normalize chat usernames color for dark theme\r\n      const allUsernameElements = document.querySelectorAll('.username'); // Get all username elements\r\n      normalizeAndResetUsernames(allUsernameElements, 'all'); // Process all username elements\r\n\r\n      return; // Stop processing further\r\n    }\r\n\r\n    for (let mutation of mutations) {\r\n      if (mutation.type === 'childList') {\r\n        for (let node of mutation.addedNodes) {\r\n          if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'P') {\r\n            const singleUsernameElement = node.querySelector('.username'); // Get a single username element\r\n            if (singleUsernameElement) normalizeAndResetUsernames(singleUsernameElement, 'one'); // Process the single username element\r\n\r\n            // Retrieve the previous message text from localStorage\r\n            const previousMessageText = localStorage.getItem('previousMessageText');\r\n\r\n            // Get the latest message data (returns only messageText and usernameText)\r\n            const latestMessageData = await getLatestMessageData();\r\n            const currentMessageText = latestMessageData?.messageText || null;\r\n            const currentMessageUsername = latestMessageData?.usernameText || null;\r\n            console.log(currentMessageText);\r\n\r\n            // Convert Cyrillic username to Latin\r\n            const latinUsername = convertRussianUsernameToLatin(currentMessageUsername);\r\n\r\n            // Check for a ban message and play sound if detected\r\n            if (isBanMessage(currentMessageText)) {\r\n              console.log('Ban message detected:', currentMessageText);\r\n              playSound();\r\n            }\r\n\r\n            // Hide message if the username is in the ignored list\r\n            if (currentMessageUsername && _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.ignored.includes(currentMessageUsername)) {\r\n              node.classList.add('ignored-user', latinUsername);\r\n              node.style.display = 'none';\r\n              continue;\r\n            }\r\n\r\n            // Get sound switcher and message mode elements\r\n            const soundSwitcher = document.querySelector('#voice, #beep, #silence');\r\n            const isVoice = soundSwitcher && soundSwitcher.id === 'voice';\r\n            const isBeep = soundSwitcher && soundSwitcher.id === 'beep';\r\n            const messageMode = document.querySelector('#every-message, #mention-message');\r\n            const isEveryMessageMode = messageMode && messageMode.id === 'every-message';\r\n            const isMentionMessageMode = messageMode && messageMode.id === 'mention-message';\r\n\r\n            // Check if the message contains a private indicator\r\n            const privateMessageIndicator = '[ ]';\r\n            const privateMessageContainer = node.querySelector('.room.private');\r\n            const isPrivateMessage = privateMessageContainer && privateMessageContainer.textContent.includes(privateMessageIndicator);\r\n\r\n            // If voice mode is enabled and the message is new, trigger text-to-speech\r\n            if (isVoice && isInitialized && currentMessageText && currentMessageText !== previousMessageText) {\r\n              localStorage.setItem('previousMessageText', currentMessageText);\r\n              if (currentMessageUsername && !currentMessageUsername.includes(_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.myNickname)) {\r\n                const shouldRead = isEveryMessageMode || (isMentionMessageMode && isMention) || isPrivateMessage;\r\n                if (shouldRead) {\r\n                  addNewMessage(currentMessageText);\r\n                }\r\n              }\r\n            }\r\n\r\n            // If beep mode is enabled and the message is new, play beep sound\r\n            if (isBeep && isInitialized && currentMessageText && currentMessageText !== previousMessageText) {\r\n              localStorage.setItem('previousMessageText', currentMessageText);\r\n              if (currentMessageUsername && !currentMessageUsername.includes(_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.myNickname)) {\r\n                const shouldBeep = isEveryMessageMode || (isMentionMessageMode && isMention) || isPrivateMessage;\r\n                if (shouldBeep) {\r\n                  const useMentionFrequency = !isEveryMessageMode || isMention;\r\n                  playBeep(useMentionFrequency ? mentionMessageFrequencies : usualMessageFrequencies, beepVolume);\r\n                  if (isMention) isMention = false;\r\n                }\r\n              }\r\n            }\r\n\r\n            // If the page is initialized, perform various UI updates and processing\r\n            if (isInitialized) {\r\n              attachEventsToMessages();\r\n              (0,_modules_image_converter_js__WEBPACK_IMPORTED_MODULE_1__.convertImageLinksToImage)('generalMessages');\r\n              (0,_modules_video_converter_js__WEBPACK_IMPORTED_MODULE_2__.convertVideoLinksToPlayer)('generalMessages');\r\n              (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.processEncodedLinks)('generalMessages');\r\n              applyChatMessageGrouping();\r\n              (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.scrollMessagesToBottom)();\r\n              banSpammer();\r\n              showPopupMessage();\r\n              (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.updatePersonalMessageCounts)();\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  // Observe changes to the messages container element\r\n  const messagesContainer = document.querySelector('.messages-content div');\r\n  newMessagesObserver.observe(messagesContainer, { childList: true, subtree: true });\r\n\r\n\r\n  // SOUND GRAPHICAL SWITCHER\r\n\r\n  // Declare variables for the sound switcher button and its icon\r\n  let soundSwitcher, soundSwitcherIcon;\r\n  // Declare variables for the message mode button and its icon\r\n  let messageMode, messageModeIcon;\r\n\r\n  function addJumpEffect(element, initialTranslateX = 0, initialTranslateY = 0) {\r\n    // Define keyframes with specified percentages, scale effect, and calc for Y translation\r\n    const keyframes = [\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}%)) scale(1)` }, // 0%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% - 60%)) scale(1.1)` }, // 20%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% + 15%)) scale(1)` }, // 40%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% - 20%)) scale(1.05)` }, // 60%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% + 8%)) scale(1)` }, // 75%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% - 10%)) scale(1.05)` }, // 85%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% + 4%)) scale(1)` }, // 92%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}%)) scale(1)` } // 100%\r\n    ];\r\n\r\n    // Animation options\r\n    const options = {\r\n      duration: 500, // Total animation duration in ms (adjust as needed)\r\n      easing: 'ease', // Smooth easing between keyframes\r\n      iterations: 1 // Play once\r\n    };\r\n\r\n    // Start the animation\r\n    const animation = element.animate(keyframes, options);\r\n\r\n    // Optional: Return a promise that resolves when animation completes\r\n    return animation.finished;\r\n  }\r\n\r\n  // Helper function to add shake effect\r\n  function addShakeEffect(element) {\r\n    element.classList.add('shake-effect');\r\n    setTimeout(() => {\r\n      element.classList.remove('shake-effect');\r\n    }, 500);\r\n  }\r\n\r\n  // CREATE SOUND SWITCHER BUTTON (START)\r\n\r\n  function createSoundSwitcherButton() {\r\n    // Create a new element with class 'sound-switcher-button' and id 'silence'\r\n    soundSwitcher = document.createElement('div');\r\n    // Retrieve the value from localStorage key \"messageNotificationState\"\r\n    const messageNotificationState = KG_Chat_Empowerment.messageSettings.messageNotificationState || 'silence';\r\n    // Add the class 'sound-switcher-button' to the 'soundSwitcher' element\r\n    soundSwitcher.classList.add(\"empowerment-button\", \"sound-switcher-button\");\r\n    // Initial button id if the localStorage key isn't created with assigned value by user\r\n    soundSwitcher.id = messageNotificationState;\r\n    // Retrieve the value from localStorage key \"messageNotificationTitle\"\r\n\r\n    // Retrieve the value from KG_Chat_Empowerment.messageSettings.messageNotificationTitle\r\n    const messageNotificationTitle = KG_Chat_Empowerment.messageSettings.messageNotificationTitle || 'Do not disturb';\r\n    // Assign title for the current notification state\r\n    soundSwitcher.title = messageNotificationTitle;\r\n\r\n    // Create sound switcher button icon container\r\n    soundSwitcherIcon = document.createElement('span');\r\n    // Add class to icon container\r\n    soundSwitcherIcon.classList.add('sound-switcher-icon');\r\n\r\n    // Append icon container inside sound switcher button\r\n    soundSwitcher.appendChild(soundSwitcherIcon);\r\n    // Append sound switcher button to chat buttons panel\r\n    empowermentButtonsPanel.appendChild(soundSwitcher);\r\n  } createSoundSwitcherButton();\r\n\r\n  // Add the isAltKeyPressed condition to the soundSwitcher event listener\r\n  soundSwitcher.addEventListener('click', function (event) {\r\n    // Only execute the code if both isCtrlKeyPressed and isAltKeyPressed are false\r\n    if (!_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed && !_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isAltKeyPressed) {\r\n\r\n      // Get progress bar elements if they exist in the DOM\r\n      let currentVoiceSpeed = document.querySelector('.current-voice-speed');\r\n      let currentVoicePitch = document.querySelector('.current-voice-pitch');\r\n\r\n      // Remove voice speed setting progress bar\r\n      if (currentVoiceSpeed) {\r\n        currentVoiceSpeed.remove();\r\n      }\r\n\r\n      // Remove voice pitch setting progress bar\r\n      if (currentVoicePitch) {\r\n        currentVoicePitch.remove();\r\n      }\r\n\r\n      // Add pulse effect for soundSwitcher\r\n      (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.addPulseEffect)(this);\r\n\r\n      switch (this.id) {\r\n        case 'silence':\r\n          this.id = 'beep';\r\n          this.title = 'Notify with beep signal';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationState = 'beep';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationTitle = 'Notify with beep signal';\r\n          break;\r\n        case 'beep':\r\n          this.id = 'voice';\r\n          this.title = 'Notify with voice API';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationState = 'voice';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationTitle = 'Notify with voice API';\r\n          break;\r\n        case 'voice':\r\n          this.id = 'silence';\r\n          this.title = 'Do not disturb';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationState = 'silence';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationTitle = 'Do not disturb';\r\n          break;\r\n      }\r\n      // Stringify KG_Chat_Empowerment before updating in localStorage\r\n      localStorage.setItem('KG_Chat_Empowerment', JSON.stringify(KG_Chat_Empowerment));\r\n\r\n      updateSoundSwitcherIcon();\r\n    }\r\n  });\r\n\r\n  function updateSoundSwitcherIcon() {\r\n    switch (soundSwitcher.id) {\r\n      case 'silence':\r\n        soundSwitcherIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.silenceSVG;\r\n        break;\r\n      case 'beep':\r\n        soundSwitcherIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.beepSVG;\r\n        break;\r\n      case 'voice':\r\n        soundSwitcherIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.voiceSVG;\r\n        break;\r\n    }\r\n  } updateSoundSwitcherIcon();\r\n\r\n  // This function combines the results of the above functions to return an object\r\n  // with both the speed and pitch percentages as strings with a \"%\" sign appended.\r\n  function getVoiceSettingsPercentage() {\r\n    const speedPercent = ((voiceSpeed - minVoiceSpeed) / (maxVoiceSpeed - minVoiceSpeed)) * 100;\r\n    const pitchPercent = ((voicePitch - minVoicePitch) / (maxVoicePitch - minVoicePitch)) * 100;\r\n\r\n    return {\r\n      speed: `${speedPercent}%`,\r\n      pitch: `${pitchPercent}%`,\r\n    };\r\n  }\r\n\r\n  /*\r\n  * Shows the current voice speed or pitch as a span element with appropriate styles.\r\n  * If the Ctrl key is pressed, displays the current voice speed.\r\n  * If the Alt key is pressed, displays the current voice pitch.\r\n  */\r\n  function showVoiceSettings() {\r\n    let voiceSettings = document.querySelector('.voice-settings');\r\n    let currentVoiceSpeed = document.querySelector('.current-voice-speed');\r\n    let currentVoicePitch = document.querySelector('.current-voice-pitch');\r\n\r\n    if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed) {\r\n      // Create voiceSettings if it doesn't exist\r\n      if (!voiceSettings) {\r\n        voiceSettings = document.createElement('div');\r\n        voiceSettings.classList.add('voice-settings');\r\n        soundSwitcher.appendChild(voiceSettings);\r\n        void voiceSettings.offsetWidth;\r\n        voiceSettings.style.opacity = '1';\r\n      }\r\n\r\n      // Remove currentVoicePitch if it exists\r\n      if (currentVoicePitch) {\r\n        currentVoicePitch.remove();\r\n      }\r\n\r\n      // Create currentVoiceSpeed if it doesn't exist\r\n      if (!currentVoiceSpeed) {\r\n        currentVoiceSpeed = document.createElement('span');\r\n        currentVoiceSpeed.classList.add('current-voice-speed');\r\n        voiceSettings.appendChild(currentVoiceSpeed);\r\n      }\r\n\r\n      // Create progress text info for voice speed\r\n      let voiceSpeedInfo = voiceSettings.querySelector('.current-voice-speed .voice-value-info');\r\n      if (!voiceSpeedInfo) {\r\n        voiceSpeedInfo = document.createElement('span');\r\n        voiceSpeedInfo.classList.add(\"voice-speed\", \"voice-value-info\");\r\n        voiceSettings.querySelector('.current-voice-speed').appendChild(voiceSpeedInfo);\r\n      }\r\n\r\n      if (voiceSpeedInfo) {\r\n        // Set the text content of voice speed\r\n        if (voiceSpeed <= minVoiceSpeed || voiceSpeed >= maxVoiceSpeed) {\r\n          voiceSpeedInfo.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.rangeIsOutSVG;\r\n        } else {\r\n          voiceSpeedInfo.innerHTML = `SPEED ${Number(voiceSpeed).toFixed(1)}`;\r\n        }\r\n      }\r\n\r\n      // Create a new progress element if it doesn't exist for speed\r\n      let voiceSpeedProgress = voiceSettings.querySelector('.current-voice-speed .voice-speed-progress');\r\n      if (!voiceSpeedProgress) {\r\n        voiceSpeedProgress = document.createElement('span');\r\n        voiceSpeedProgress.classList.add('voice-speed-progress');\r\n        // Create the progress fill element\r\n        let fill = document.createElement('span');\r\n        fill.classList.add('voice-speed-progress-fill');\r\n        // Append the fill element to the progress element\r\n        voiceSpeedProgress.appendChild(fill);\r\n        // Append the progress element to the current voice speed container\r\n        voiceSettings.querySelector('.current-voice-speed').appendChild(voiceSpeedProgress);\r\n      }\r\n\r\n      // Update progress fill width based on voice speed percentage\r\n      voiceSpeedProgress.querySelector('.voice-speed-progress-fill').style.width = getVoiceSettingsPercentage().speed;\r\n\r\n      // Clear any existing timeout on voiceSettings and set a new one\r\n      if (voiceSettings.timeoutId) {\r\n        clearTimeout(voiceSettings.timeoutId);\r\n      }\r\n\r\n      voiceSettings.timeoutId = setTimeout(() => {\r\n        voiceSettings.style.opacity = '0';\r\n        setTimeout(() => {\r\n          voiceSettings.remove();\r\n        }, 500);\r\n      }, 2000);\r\n\r\n    } else if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isAltKeyPressed) {\r\n      // Create voiceSettings if it doesn't exist\r\n      if (!voiceSettings) {\r\n        voiceSettings = document.createElement('div');\r\n        voiceSettings.classList.add('voice-settings');\r\n        soundSwitcher.appendChild(voiceSettings);\r\n        void voiceSettings.offsetWidth;\r\n        voiceSettings.style.opacity = '1';\r\n      }\r\n\r\n      // Remove currentVoiceSpeed if it exists\r\n      if (currentVoiceSpeed) {\r\n        currentVoiceSpeed.remove();\r\n      }\r\n\r\n      // Create currentVoicePitch if it doesn't exist\r\n      if (!currentVoicePitch) {\r\n        currentVoicePitch = document.createElement('span');\r\n        currentVoicePitch.classList.add('current-voice-pitch');\r\n        voiceSettings.appendChild(currentVoicePitch);\r\n      }\r\n\r\n      // Create progress text info for voice pitch\r\n      let voicePitchInfo = voiceSettings.querySelector('.current-voice-pitch .voice-value-info');\r\n      if (!voicePitchInfo) {\r\n        voicePitchInfo = document.createElement('span');\r\n        voicePitchInfo.classList.add(\"voice-pitch\", \"voice-value-info\");\r\n        voiceSettings.querySelector('.current-voice-pitch').appendChild(voicePitchInfo);\r\n      }\r\n\r\n      if (voicePitchInfo) {\r\n        // Set the text content of voice pitch\r\n        if (voicePitch <= minVoicePitch || voicePitch >= maxVoicePitch) {\r\n          voicePitchInfo.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.rangeIsOutSVG;\r\n        } else {\r\n          voicePitchInfo.innerHTML = `PITCH ${voicePitch.toFixed(1)}`;\r\n        }\r\n      }\r\n\r\n      // Create a new progress element if it doesn't exist for pitch\r\n      let pitchProgress = voiceSettings.querySelector('.current-voice-pitch .voice-pitch-progress');\r\n      if (!pitchProgress) {\r\n        pitchProgress = document.createElement('span');\r\n        pitchProgress.classList.add('voice-pitch-progress');\r\n        // Create the progress fill element\r\n        let fill = document.createElement('span');\r\n        fill.classList.add('voice-pitch-progress-fill');\r\n        // Append the fill element to the progress element\r\n        pitchProgress.appendChild(fill);\r\n        // Append the progress element to the current voice pitch container\r\n        voiceSettings.querySelector('.current-voice-pitch').appendChild(pitchProgress);\r\n      }\r\n\r\n      // Update progress fill width based on voice pitch percentage\r\n      pitchProgress.querySelector('.voice-pitch-progress-fill').style.width = getVoiceSettingsPercentage().pitch;\r\n\r\n      // Clear any existing timeout on voiceSettings and set a new one\r\n      if (voiceSettings.timeoutId) {\r\n        clearTimeout(voiceSettings.timeoutId);\r\n      }\r\n\r\n      voiceSettings.timeoutId = setTimeout(() => {\r\n        voiceSettings.style.opacity = '0';\r\n        setTimeout(() => {\r\n          voiceSettings.remove();\r\n        }, 500);\r\n      }, 2000);\r\n\r\n    } else {\r\n      // If neither Ctrl nor Alt is pressed, remove voiceSettings if it exists\r\n      if (voiceSettings) {\r\n        voiceSettings.remove();\r\n      }\r\n    }\r\n  }\r\n\r\n  let holdTimeout = null;\r\n  let holdInterval = null;\r\n\r\n  // Replace original click/contextmenu listeners with mousedown\r\n  soundSwitcher.addEventListener('mousedown', handleMouseDown);\r\n  soundSwitcher.addEventListener('contextmenu', (event) => event.preventDefault());\r\n\r\n  function handleMouseDown(event) {\r\n    event.preventDefault(); // Prevent context menu on right-click\r\n\r\n    const params = getAdjustmentParams(event);\r\n    if (!params) return;\r\n\r\n    const { prop, step } = params;\r\n    adjustValue(prop, step); // Initial adjustment\r\n\r\n    // Set up delayed repeat\r\n    holdTimeout = setTimeout(() => {\r\n      holdInterval = setInterval(() => {\r\n        const canContinue = adjustValue(prop, step);\r\n        if (!canContinue) clearInterval(holdInterval);\r\n      }, 100);\r\n    }, 500);\r\n\r\n    // Cleanup listeners\r\n    const stopHolding = () => {\r\n      clearTimeout(holdTimeout);\r\n      clearInterval(holdInterval);\r\n      soundSwitcher.removeEventListener('mouseup', stopHolding);\r\n      soundSwitcher.removeEventListener('mouseleave', stopHolding);\r\n    };\r\n\r\n    soundSwitcher.addEventListener('mouseup', stopHolding);\r\n    soundSwitcher.addEventListener('mouseleave', stopHolding);\r\n  }\r\n\r\n  function getAdjustmentParams(event) {\r\n    const isLeft = event.button === 0;\r\n    // const isRight = event.button === 2; // Unused declaration\r\n    const isCtrl = event.ctrlKey || event.metaKey;\r\n    const isAlt = event.altKey;\r\n\r\n    if (!isCtrl && !isAlt) return null;\r\n\r\n    const prop = isCtrl ? 'voiceSpeed' : 'voicePitch';\r\n    const step = isLeft ? -0.1 : 0.1;\r\n\r\n    // Boundary checks\r\n    const current = KG_Chat_Empowerment.voiceSettings[prop];\r\n    const [min, max] = prop === 'voiceSpeed'\r\n      ? [minVoiceSpeed, maxVoiceSpeed]\r\n      : [minVoicePitch, maxVoicePitch];\r\n\r\n    if ((step < 0 && current <= min) || (step > 0 && current >= max)) return null;\r\n\r\n    return { prop, step };\r\n  }\r\n\r\n  function adjustValue(prop, step) {\r\n    const current = parseFloat(KG_Chat_Empowerment.voiceSettings[prop]);\r\n    const [min, max] = prop === 'voiceSpeed'\r\n      ? [minVoiceSpeed, maxVoiceSpeed]\r\n      : [minVoicePitch, maxVoicePitch];\r\n\r\n    const newValue = current + step;\r\n    const clamped = Math.min(max, Math.max(min, newValue));\r\n\r\n    if (current === clamped) return false; // No change\r\n\r\n    updateVoiceSetting(prop, clamped);\r\n    return (step > 0 ? clamped < max : clamped > min);\r\n  }\r\n\r\n  // Function to update the voice setting, round the value, and update storage\r\n  function updateVoiceSetting(prop, value) {\r\n    // Round the value to one decimal place\r\n    const roundedValue = parseFloat(value.toFixed(1));\r\n    // Update the voice setting in the application state\r\n    KG_Chat_Empowerment.voiceSettings[prop] = roundedValue;\r\n    // Update voiceSpeed and voicePitch variables\r\n    if (prop === 'voiceSpeed') {\r\n      voiceSpeed = roundedValue;\r\n    } else if (prop === 'voicePitch') {\r\n      voicePitch = roundedValue;\r\n    }\r\n    // Store the updated state in localStorage\r\n    localStorage.setItem('KG_Chat_Empowerment', JSON.stringify(KG_Chat_Empowerment));\r\n    // Show the updated voice settings\r\n    showVoiceSettings();\r\n  }\r\n\r\n  // CREATE SOUND SWITCHER BUTTON (END)\r\n\r\n\r\n  // CREATE MESSAGE MODE BUTTON (START)\r\n\r\n  function createMessageModeButton() {\r\n    // Create a new element with class 'message-mode-button' and id 'every-messages'\r\n    messageMode = document.createElement('div');\r\n    // Retrieve the value from KG_Chat_Empowerment.messageSettings.messageModeState\r\n    const messageModeState = KG_Chat_Empowerment.messageSettings.messageModeState || 'every-message';\r\n    // Add the class 'message-mode-button' to the 'messagesMode' element\r\n    messageMode.classList.add(\"empowerment-button\", \"message-mode-button\");\r\n    // Initial button id if the localStorage key isn't created with assigned value by user\r\n    messageMode.id = messageModeState;\r\n\r\n    // Retrieve the value from KG_Chat_Empowerment.messageSettings.messageModeTitle\r\n    const messageModeTitle = KG_Chat_Empowerment.messageSettings.messageModeTitle || 'Notify about every message';\r\n    // Assign title for the current notification state\r\n    messageMode.title = messageModeTitle;\r\n\r\n    // Create message mode button icon container\r\n    messageModeIcon = document.createElement('span');\r\n    // Add class to icon container\r\n    messageModeIcon.classList.add('message-mode-icon');\r\n\r\n    // Append icon container inside message mode button\r\n    messageMode.appendChild(messageModeIcon);\r\n    // Append sound switcher button to chat buttons panel\r\n    empowermentButtonsPanel.appendChild(messageMode);\r\n  } createMessageModeButton();\r\n\r\n  // Add the isAltKeyPressed condition to the messagesMode event listener\r\n  messageMode.addEventListener('click', function (event) {\r\n    // Only execute when isCtrlKeyPressed or isAltKeyPressed are false\r\n    if (!_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed || !_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isAltKeyPressed) {\r\n\r\n      // Add pulse effect for messageMode\r\n      (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.addPulseEffect)(this);\r\n\r\n      switch (this.id) {\r\n        case 'every-message':\r\n          this.id = 'mention-message';\r\n          this.title = 'Notify about mention message';\r\n          KG_Chat_Empowerment.messageSettings.messageModeState = 'mention-message';\r\n          KG_Chat_Empowerment.messageSettings.messageModeTitle = 'Notify about mention message';\r\n          break;\r\n        case 'mention-message':\r\n          this.id = 'every-message';\r\n          this.title = 'Notify about every message';\r\n          KG_Chat_Empowerment.messageSettings.messageModeState = 'every-message';\r\n          KG_Chat_Empowerment.messageSettings.messageModeTitle = 'Notify about every message';\r\n          break;\r\n      }\r\n\r\n      // Stringify KG_Chat_Empowerment before updating in localStorage\r\n      localStorage.setItem('KG_Chat_Empowerment', JSON.stringify(KG_Chat_Empowerment));\r\n\r\n      updateMessageModeIcon();\r\n    }\r\n  });\r\n\r\n  function updateMessageModeIcon() {\r\n    switch (messageMode.id) {\r\n      case 'every-message':\r\n        messageModeIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.modeEverySVG;\r\n        break;\r\n      case 'mention-message':\r\n        messageModeIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.modeMentionSVG;\r\n        break;\r\n    }\r\n  } updateMessageModeIcon();\r\n\r\n  // CREATE MESSAGE MODE BUTTON (END)\r\n\r\n\r\n  // 1. CREATE CACHE (START)\r\n  (0,_modules_cache_js__WEBPACK_IMPORTED_MODULE_4__.createCacheButton)(empowermentButtonsPanel);\r\n  // CREATE CACHE (END)\r\n\r\n  // 2. CREATE PERSONAL MESSAGES (START)\r\n  (0,_modules_messages_js__WEBPACK_IMPORTED_MODULE_5__.createPersonalMessagesButton)(empowermentButtonsPanel);\r\n  // CREATE PERSONAL MESSAGES (END)\r\n\r\n  // 3. CREATE CHAT LOGS (START)\r\n  (0,_modules_chatlogs_js__WEBPACK_IMPORTED_MODULE_6__.createChatLogsButton)(empowermentButtonsPanel);\r\n  // CREATE CHAT LOGS (END)\r\n\r\n  // 4. CREATE SETTINGS (START)\r\n  (0,_modules_settings_js__WEBPACK_IMPORTED_MODULE_7__.createSettingsButton)(empowermentButtonsPanel);\r\n  // CREATE SETTINGS (END)\r\n\r\n\r\n  // Function to retrieve the chat input field and length popup container based on the current URL\r\n  function retrieveChatElementsByRoomType() {\r\n    const currentURL = window.location.href; // Get the current URL\r\n    let inputField, lengthPopupContainer;\r\n\r\n    if (currentURL.includes('gamelist')) {\r\n      inputField = document.querySelector('#chat-general .text'); // Selector for the general chat input\r\n      lengthPopupContainer = document.querySelector('#chat-general .messages'); // Selector for the general chat messages\r\n    } else if (currentURL.includes('gmid')) {\r\n      inputField = document.querySelector('[id^=\"chat-game\"] .text'); // Selector for the game chat input\r\n      lengthPopupContainer = document.querySelector('[id^=\"chat-game\"] .messages'); // Selector for the game chat messages\r\n    } else {\r\n      console.error('No matching room type found in the URL.');\r\n      return null; // Return null if no matching type is found\r\n    }\r\n\r\n    return { inputField, lengthPopupContainer }; // Return both the input field and the length popup container\r\n  }\r\n\r\n\r\n  // CHAT POPUP INDICATOR LENGTH (START)\r\n\r\n  // Select the input element and length popup container using the helper function\r\n  const { inputField: chatField, lengthPopupContainer } = retrieveChatElementsByRoomType();\r\n\r\n  const lengthPopup = document.createElement('div');\r\n  lengthPopup.className = 'length-field-popup';\r\n\r\n  lengthPopupContainer.appendChild(lengthPopup);\r\n\r\n  // Initialize once at startup\r\n  const textMeasurementCanvas = document.createElement('canvas');\r\n  const textMeasurementContext = textMeasurementCanvas.getContext('2d');\r\n\r\n  let isPopupVisible = false;\r\n  let previousLength = 0;\r\n  let hidePopupTimeout;\r\n\r\n  // Function to update the color of the length popup\r\n  function updateLengthPopupColor(length) {\r\n    if (!lengthPopup) {\r\n      console.error('lengthPopup is not defined');\r\n      return;\r\n    }\r\n\r\n    let textColor;\r\n\r\n    // Determine color based on the length\r\n    if (length === 0) {\r\n      textColor = 'hsl(200, 20%, 50%)'; // Light Blue\r\n    } else if (length >= 1 && length <= 90) {\r\n      textColor = 'hsl(120, 100%, 40%)'; // Bright Green\r\n    } else if (length > 90 && length <= 100) {\r\n      const factor = (length - 90) / 10;\r\n      const h = Math.round(120 + factor * (60 - 120)); // Interpolating hue\r\n      textColor = `hsl(${h}, 100%, 40%)`;\r\n    } else if (length > 100 && length <= 190) {\r\n      textColor = 'hsl(60, 100%, 50%)'; // Bright Yellow\r\n    } else if (length > 190 && length <= 200) {\r\n      const factor = (length - 190) / 10;\r\n      const h = Math.round(60 + factor * (30 - 60)); // Interpolating hue\r\n      textColor = `hsl(${h}, 100%, 50%)`;\r\n    } else if (length > 200 && length <= 250) {\r\n      textColor = 'hsl(40, 100%, 50%)'; // Orange (Updated)\r\n    } else if (length > 250 && length <= 300) {\r\n      const factor = (length - 250) / 50;\r\n      const h = Math.round(40 + factor * (0 - 40)); // Interpolating hue\r\n      textColor = `hsl(${h}, 100%, 70%)`;\r\n    } else {\r\n      textColor = 'hsl(0, 100%, 70%)'; // Red (Updated)\r\n    }\r\n\r\n    // Apply the text color to the length popup\r\n    lengthPopup.style.color = textColor;\r\n  }\r\n\r\n  // Then use them in your measurement function\r\n  function updatePopupMetrics(text) {\r\n    // Get current font from input field\r\n    const computedStyle = getComputedStyle(chatField);\r\n    textMeasurementContext.font = `${computedStyle.fontWeight} ${computedStyle.fontSize} ${computedStyle.fontFamily}`;\r\n\r\n    // Measure text\r\n    const textWidth = textMeasurementContext.measureText(text).width;\r\n\r\n    // Calculate position\r\n    const newLeft = chatField.offsetLeft + textWidth + 5;\r\n    const maxLeft = chatField.offsetLeft + chatField.offsetWidth - lengthPopup.offsetWidth;\r\n    lengthPopup.style.left = `${Math.min(newLeft, maxLeft)}px`;\r\n  }\r\n\r\n  // Only update content/position without animation\r\n  function updateLengthPopup(length) {\r\n    let displayText;\r\n\r\n    displayText = length > previousLength ? `${length} ` :\r\n      length < previousLength ? ` ${length}` :\r\n        `${length}`;\r\n\r\n    lengthPopup.textContent = displayText;\r\n    updateLengthPopupColor(length);\r\n    previousLength = length;\r\n  }\r\n\r\n  function togglePopup(show) {\r\n    if (isPopupVisible === show) return;\r\n    lengthPopup.classList.toggle('bounce-in', show);\r\n    lengthPopup.classList.toggle('bounce-out', !show);\r\n    isPopupVisible = show;\r\n    if (!show) setTimeout(() => lengthPopup.classList.remove('bounce-out'), 500);\r\n  }\r\n\r\n  function resetPopup() {\r\n    updateLengthPopup(0);\r\n    Object.assign(lengthPopup.style, { left: '0px', color: 'hsl(200, 20%, 50%)' });\r\n  }\r\n\r\n  chatField.addEventListener('input', () => {\r\n    clearTimeout(hidePopupTimeout);\r\n    updateLengthPopup(chatField.value.length);\r\n    updatePopupMetrics(chatField.value);\r\n    togglePopup(true);\r\n    hidePopupTimeout = setTimeout(() => togglePopup(false), 1000);\r\n  });\r\n\r\n  chatField.addEventListener('keydown', (e) => {\r\n    if (e.key !== 'Enter') return;\r\n    resetPopup();\r\n    togglePopup(true);\r\n    hidePopupTimeout = setTimeout(() => togglePopup(false), 1000);\r\n  });\r\n\r\n  // CHAT POPUP INDICATOR LENGTH (END)\r\n\r\n\r\n  // REMOVE UNWANTED MESSAGES\r\n\r\n  /*\r\n  ** This algorithm enables the removal of unpleasant messages in the chat that are unwanted.\r\n  ** The messages are saved in localStorage and remain there until they are visible in the chat.\r\n  ** Once a message is no longer visible in the chat, its corresponding value in localStorage is also removed.\r\n  ** This method is helpful in storing only necessary unwanted messages, preventing an overgrowth of values over time.\r\n  */\r\n\r\n  function executeMessageRemover() {\r\n    attachEventsToMessages();\r\n    createToggleButton();\r\n    wipeDeletedMessages();\r\n  } // executeMessageRemover function END\r\n\r\n  // Function to assign styles to the delete button\r\n  function assignDeleteButtonStyles(deleteButton, event) {\r\n    // Set the delete button styles\r\n    deleteButton.style.position = 'fixed';\r\n    deleteButton.style.top = `${event.clientY}px`;\r\n    deleteButton.style.left = `${event.clientX}px`;\r\n    deleteButton.style.zIndex = 999;\r\n    deleteButton.style.padding = '8px 16px';\r\n    deleteButton.style.backgroundColor = 'hsl(0, 50%, 20%)';\r\n    deleteButton.style.color = 'hsl(0, 60%, 70%)';\r\n    deleteButton.style.border = '1px solid hsl(0, 50%, 35%)';\r\n    deleteButton.style.transition = 'all 0.3s';\r\n    deleteButton.style.filter = 'brightness(1)';\r\n\r\n    // Set the hover styles\r\n    deleteButton.addEventListener('mouseenter', () => {\r\n      deleteButton.style.filter = 'brightness(1.5)';\r\n    });\r\n\r\n    // Set the mouse leave styles\r\n    deleteButton.addEventListener('mouseleave', () => {\r\n      deleteButton.style.filter = 'brightness(1)';\r\n    });\r\n  }\r\n\r\n  // Functions to assign selection to the messages\r\n  function assignMessageSelection(message) {\r\n    message.style.setProperty('background-color', 'hsla(0, 50%, 30%, .5)', 'important');\r\n    message.style.setProperty('box-shadow', 'inset 0px 0px 0px 1px rgb(191, 64, 64)', 'important');\r\n    message.style.setProperty('background-clip', 'padding-box', 'important');\r\n  }\r\n  // Clear the selection\r\n  function clearMessageSelection() {\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n    messages.forEach(message => {\r\n      message.style.removeProperty('background-color');\r\n      message.style.removeProperty('box-shadow');\r\n      message.style.removeProperty('background-clip');\r\n    });\r\n  }\r\n\r\n  // Declare a new Set to hold selected messages\r\n  const selectedMessages = new Set();\r\n  // To store the data of the right mouse button drag\r\n  let isDragging = false;\r\n  let isRightMouseButton = false;\r\n\r\n  // Function to attach events on every message what doesn't have any event assigned\r\n  function attachEventsToMessages() {\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n    // Store timeoutID to regulate it by multiple events\r\n    let timeoutId = null;\r\n\r\n    messages.forEach(message => {\r\n      // Check if the element has the 'contextmenu' id before adding a new event listener\r\n      if (!message.hasAttribute('id') || message.getAttribute('id') !== 'contextmenu') {\r\n\r\n        message.addEventListener('mousedown', event => {\r\n          isRightMouseButton = event.button === 2;\r\n          if (isRightMouseButton) {\r\n            isDragging = true;\r\n            clearTimeout(timeoutId);\r\n\r\n            // Extract content from various types of child nodes\r\n            const messageContent = getMessageContent(message);\r\n            if (!selectedMessages.has(messageContent)) {\r\n              selectedMessages.add(messageContent);\r\n              console.log('Added new message inside the selectedMessages Set:', messageContent);\r\n            }\r\n\r\n            assignMessageSelection(message);\r\n          }\r\n        });\r\n\r\n        message.addEventListener('mouseup', event => {\r\n          isRightMouseButton = event.button === 2;\r\n          if (isRightMouseButton) {\r\n            isDragging = false;\r\n          }\r\n        });\r\n\r\n        message.addEventListener('mouseover', event => {\r\n          if (isDragging && isRightMouseButton) {\r\n            // Extract content from various types of child nodes\r\n            const messageContent = getMessageContent(message);\r\n            if (!selectedMessages.has(messageContent)) {\r\n              selectedMessages.add(messageContent);\r\n              console.log('Added new message inside the selectedMessages Set:', messageContent);\r\n            }\r\n\r\n            assignMessageSelection(message);\r\n          }\r\n        });\r\n\r\n        // Add id contextmenu to check in the future if the element has the event\r\n        message.setAttribute('id', 'contextmenu');\r\n        // Add an event listener for right-clicks on messages\r\n        message.addEventListener('contextmenu', event => {\r\n          // Prevent the default context menu from appearing\r\n          event.preventDefault();\r\n          // Wrap the message into visible selection to visually know what message will be deleted\r\n          assignMessageSelection(message);\r\n\r\n          // Check if a delete-message button already exists in the document\r\n          const deleteButton = document.querySelector('.delete-message');\r\n\r\n          if (deleteButton) {\r\n            // If it exists, remove it\r\n            deleteButton.remove();\r\n          }\r\n\r\n          // Create a new delete-message button\r\n          const newDeleteButton = document.createElement('button');\r\n          newDeleteButton.innerText = 'Delete';\r\n          newDeleteButton.classList.add('delete-message');\r\n\r\n          // Attach event click to new delete-message button\r\n          newDeleteButton.addEventListener('click', () => {\r\n            deleteSelectedMessages(message);\r\n            newDeleteButton.remove();\r\n            createToggleButton();\r\n            selectedMessages.clear();\r\n          });\r\n\r\n          // Style the delete button\r\n          assignDeleteButtonStyles(newDeleteButton, event);\r\n\r\n          // Set the hover styles\r\n          newDeleteButton.addEventListener('mouseenter', () => {\r\n            newDeleteButton.style.filter = 'brightness(1.5)';\r\n          });\r\n\r\n          // Set the mouse leave styles\r\n          newDeleteButton.addEventListener('mouseleave', () => {\r\n            newDeleteButton.style.filter = 'brightness(1)';\r\n          });\r\n\r\n          // Append the new delete-message button to the document body\r\n          document.body.appendChild(newDeleteButton);\r\n\r\n          function hideDeleteButton() {\r\n            // Set a new timeout to remove the delete button\r\n            timeoutId = setTimeout(() => {\r\n              if (!newDeleteButton.matches(':hover')) {\r\n                newDeleteButton.remove();\r\n                clearMessageSelection(message);\r\n                selectedMessages.clear();\r\n              }\r\n            }, 1000);\r\n          }\r\n\r\n          hideDeleteButton();\r\n\r\n          // Add event listener for the mouseleave event on the delete button\r\n          newDeleteButton.addEventListener('mouseleave', () => {\r\n            hideDeleteButton();\r\n          });\r\n\r\n          // Add event listener for the mouseenter event on the delete button to clear the previous timeout\r\n          newDeleteButton.addEventListener('mouseenter', () => {\r\n            clearTimeout(timeoutId);\r\n          });\r\n\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  // Function to extract content from various types of child nodes within a message element\r\n  function getMessageContent(messageElement) {\r\n    // Query the .time and .username elements\r\n    const timeElement = messageElement.querySelector('.time');\r\n    const usernameElement = messageElement.querySelector('.username');\r\n\r\n    // Extract content from .time and .username elements\r\n    const timeContent = timeElement ? timeElement.textContent.trim() : '';\r\n    const usernameContent = usernameElement ? ` ${usernameElement.textContent.trim()} ` : '';\r\n\r\n    // Extract content from other types of child nodes\r\n    const otherContentArray = Array.from(messageElement.childNodes)\r\n      .filter(node => node !== timeElement && node !== usernameElement)\r\n      .map(node => {\r\n        if (node.nodeType === Node.TEXT_NODE) {\r\n          return node.textContent; // Handle #text node without trimming\r\n        } else if (node.tagName === 'A') {\r\n          return node.getAttribute('href').trim(); // Handle #anchor (link) node\r\n        } else if (node.tagName === 'IMG') {\r\n          return node.title.trim(); // Handle #img node\r\n        } else if (node.tagName === 'IFRAME') {\r\n          return node.getAttribute('src').trim(); // Handle #iframe node\r\n        }\r\n        return ''; // Return empty string for other node types\r\n      });\r\n\r\n    // Concatenate content while respecting the order of child nodes\r\n    const allContentArray = [timeContent, usernameContent, ...otherContentArray];\r\n\r\n    return allContentArray.join('');\r\n  }\r\n\r\n  function deleteSelectedMessages() {\r\n    // Retrieve and backup all current selectedMessages and convert into Array\r\n    const messagesToDelete = [...selectedMessages];\r\n\r\n    // Get all message elements\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n\r\n    // Loop over each selected message content\r\n    messagesToDelete.forEach((messageContent) => {\r\n      // Find the corresponding DOM element\r\n      const messageElement = Array.from(messages).find(message => getMessageContent(message) === messageContent);\r\n\r\n      // Check if the element is found before using it\r\n      if (messageElement) {\r\n        // Retrieve the stored deleted messages array, or create an empty array if none exist\r\n        const deletedMessages = JSON.parse(localStorage.getItem('deletedChatMessagesContent') || '[]');\r\n        // Add the deleted message content to the array if it doesn't already exist\r\n        if (!deletedMessages.includes(messageContent)) {\r\n          deletedMessages.push(messageContent);\r\n        }\r\n        // Store the updated deleted messages array in localStorage\r\n        localStorage.setItem('deletedChatMessagesContent', JSON.stringify(deletedMessages));\r\n        // Remove the message from the selectedMessages Set\r\n        selectedMessages.delete(messageContent);\r\n      }\r\n    });\r\n\r\n    // Hide all the messages that match the localStorage value\r\n    wipeDeletedMessages();\r\n  }\r\n\r\n  function wipeDeletedMessages() {\r\n    // Retrieve and parse the stored deleted messages\r\n    const deletedMessages = JSON.parse(localStorage.getItem('deletedChatMessagesContent') || '[]');\r\n\r\n    // If there are no deleted messages in localStorage, return early\r\n    if (deletedMessages.length === 0) return;\r\n\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n    // Convert the deleted messages into a Set for faster lookup\r\n    const deletedMessagesSet = new Set(deletedMessages);\r\n\r\n    // Collect the current messages content into an array for easy comparison\r\n    const currentMessagesContent = Array.from(messages).map(message => getMessageContent(message));\r\n\r\n    // Filter out the deleted messages that no longer exist in the current messages\r\n    const newDeletedMessages = deletedMessages.filter(content => currentMessagesContent.includes(content));\r\n\r\n    // Hide messages in the chat that match the deleted messages\r\n    messages.forEach(message => {\r\n      if (deletedMessagesSet.has(getMessageContent(message))) {\r\n        message.style.display = 'none';\r\n      }\r\n    });\r\n\r\n    // Store the updated deleted messages array in localStorage\r\n    localStorage.setItem('deletedChatMessagesContent', JSON.stringify(newDeletedMessages));\r\n  } // wipeDeletedMessages END\r\n\r\n  // Declare toggleButton variable outside of the function so it is a global variable\r\n  let toggleButton;\r\n\r\n  // Function to create the button only if localStorage \"deletedChatMessagesContent\" has at least one deleted message value\r\n  function createToggleButton() {\r\n    // Retrieve the stored deleted messages array\r\n    const deletedMessages = JSON.parse(localStorage.getItem('deletedChatMessagesContent') || '[]');\r\n\r\n    // Only create the toggle button if there are deleted messages to show/hide\r\n    if (deletedMessages.length > 0) {\r\n      // Check if the button already exists in the DOM\r\n      toggleButton = document.getElementById('toggleButton');\r\n      if (toggleButton === null) {\r\n        // Create the toggle button\r\n        toggleButton = document.createElement('button');\r\n        toggleButton.id = 'toggleButton';\r\n        toggleButton.classList.add(\"toggle-button-hidden\");\r\n        toggleButton.addEventListener('click', toggleHiddenMessages);\r\n        toggleButton.style.position = 'absolute';\r\n        toggleButton.style.top = '0';\r\n        toggleButton.style.right = '0';\r\n        toggleButton.style.padding = '8px 16px';\r\n        // Initial textContent if at least one message is hidden\r\n        toggleButton.innerText = 'Hidden';\r\n        // Initial styles for the Hidden button\r\n        toggleButton.style.transition = 'filter 300ms';\r\n        toggleButton.style.filter = 'hue-rotate(0) brightness(1)';\r\n        let backupTextContent = toggleButton.textContent;\r\n\r\n        // Set the hover styles\r\n        toggleButton.addEventListener('mouseenter', () => {\r\n          if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed) {\r\n            backupTextContent = toggleButton.textContent;\r\n            toggleButton.textContent = 'Restore';\r\n            toggleButton.style.filter = 'hue-rotate(180deg) brightness(2)';\r\n          } else {\r\n            toggleButton.style.filter = 'hue-rotate(0) brightness(2)';\r\n          }\r\n        });\r\n\r\n        // Set the mouse leave styles\r\n        toggleButton.addEventListener('mouseleave', () => {\r\n          const isRestore = toggleButton.textContent === 'Restore';\r\n          if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed || !_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed && isRestore) {\r\n            toggleButton.textContent = backupTextContent;\r\n          }\r\n          toggleButton.style.filter = 'hue-rotate(0) brightness(1)';\r\n        });\r\n\r\n        messagesContainer.appendChild(toggleButton);\r\n      }\r\n    }\r\n  } // createToggleButton END\r\n\r\n  // Function to toggle messages display state from \"NONE\" to \"BLOCK\" and reverse\r\n  function toggleHiddenMessages() {\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n    // Retrieve the stored deleted messages array\r\n    const deletedMessages = JSON.parse(localStorage.getItem('deletedChatMessagesContent') || '[]');\r\n\r\n    if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed) {\r\n      // Set deletedChatMessagesContent in local storage as an empty array\r\n      localStorage.setItem('deletedChatMessagesContent', JSON.stringify([]));\r\n\r\n      // Display all messages\r\n      messages.forEach(message => {\r\n        message.style.display = 'block';\r\n        message.style.removeProperty('background-color');\r\n        message.style.removeProperty('box-shadow');\r\n        message.style.removeProperty('background-clip');\r\n      });\r\n\r\n      toggleButton.remove();\r\n    }\r\n\r\n    if (!_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed) {\r\n\r\n      // Check if there are any deleted messages in the local storage\r\n      if (deletedMessages.length === 0) {\r\n        // Hide the toggle button if there are no deleted messages\r\n        toggleButton.style.display = 'none';\r\n        return;\r\n      } else {\r\n        // Show the toggle button if there are deleted messages\r\n        toggleButton.style.display = 'block';\r\n      }\r\n\r\n      // Toggle the display of each message that matches the key \"deletedChatMessagesContent\" data\r\n      messages.forEach(message => {\r\n        const messageContent = getMessageContent(message);\r\n\r\n        if (deletedMessages.includes(messageContent)) {\r\n          // Show hidden messages if innerText is \"Hidden\" and display equal \"NONE\"\r\n          if (toggleButton.innerText === 'Hidden') {\r\n            if (message.style.display === 'none') {\r\n              // Change display to \"BLOCK\"\r\n              message.style.display = 'block';\r\n              // Wrap the message into visible selection to visually know what message will be deleted\r\n              message.style.setProperty('background-color', 'hsla(0, 50%, 30%, .5)', 'important');\r\n              message.style.setProperty('box-shadow', 'inset 0px 0px 0px 1px rgb(191, 64, 64)', 'important');\r\n              message.style.setProperty('background-clip', 'padding-box', 'important');\r\n            }\r\n            // Show hidden messages if innerText is \"Show\" and display equal \"NONE\"\r\n          } else if (toggleButton.innerText === 'Show') {\r\n            if (message.style.display === 'none') {\r\n              message.style.display = 'block';\r\n              // Wrap the message into visible selection to visually know what message will be deleted\r\n              message.style.setProperty('background-color', 'hsla(0, 50%, 30%, .5)', 'important');\r\n              message.style.setProperty('box-shadow', 'inset 0px 0px 0px 1px rgb(191, 64, 64)', 'important');\r\n              message.style.setProperty('background-clip', 'padding-box', 'important');\r\n            }\r\n          } else if (toggleButton.innerText === 'Hide') {\r\n            if (message.style.display === 'block') {\r\n              message.style.display = 'none';\r\n              message.style.removeProperty('background-color');\r\n              message.style.removeProperty('box-shadow');\r\n              message.style.removeProperty('background-clip');\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      // Toggle the button text and style\r\n      if (toggleButton.innerText === 'Hide') {\r\n        toggleButton.innerText = 'Show';\r\n        toggleButton.className = 'toggle-button-show'; // Replace the class with the show style\r\n      } else {\r\n        toggleButton.innerText = 'Hide';\r\n        toggleButton.className = 'toggle-button-hide'; // Replace the class with the hide style\r\n      }\r\n\r\n    }\r\n\r\n  } // toggleHiddenMessages END\r\n\r\n  // create a new MutationObserver to wait for the chat to fully load with all messages\r\n  let waitForChatObserver = new MutationObserver(() => {\r\n    // Get the container for all chat messages\r\n    const messagesContainer = document.querySelector('.messages-content div');\r\n    // Get all the message elements from messages container\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n\r\n    // check if the chat element has been added to the DOM\r\n    if (document.contains(messagesContainer)) {\r\n\r\n      // check if there are at least 20 messages in the container\r\n      if (messages.length >= 20) {\r\n        // stop observing the DOM\r\n        waitForChatObserver.disconnect();\r\n        // Remove ignored users' messages if the page is not initialized\r\n        removeIgnoredUserMessages();\r\n        // Convert image links to visible image containers\r\n        (0,_modules_image_converter_js__WEBPACK_IMPORTED_MODULE_1__.convertImageLinksToImage)('generalMessages');\r\n        // Convert YouTube links to visible iframe containers\r\n        (0,_modules_video_converter_js__WEBPACK_IMPORTED_MODULE_2__.convertVideoLinksToPlayer)('generalMessages'); // For general chat\r\n        // Decodes links within the general messages section.\r\n        (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.processEncodedLinks)('generalMessages');\r\n        // Restore chat tab from localStorage\r\n        (0,_modules_chat_js__WEBPACK_IMPORTED_MODULE_9__.restoreChatTab)();\r\n        // Call the function with the selector for the input field\r\n        (0,_modules_chat_js__WEBPACK_IMPORTED_MODULE_9__.setupInputBackup)('#chat-general .text');\r\n        // Call the function eo re-highlight all the mention words of the messages\r\n        (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.highlightMentionWords)();\r\n        // Call the function to apply the chat message grouping\r\n        applyChatMessageGrouping();\r\n        // Call the function to scroll to the bottom of the chat\r\n        (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.scrollMessagesToBottom)();\r\n        // Call the function to refresh the user list and clear the cache if needed\r\n        (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.refreshFetchedUsers)(false, _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.cacheRefreshThresholdHours);\r\n        // Refresh experimental custom chat user list on old list changes\r\n        refreshUserList();\r\n        // Call the setChatFieldFocus function when the page loads\r\n        (0,_modules_chat_js__WEBPACK_IMPORTED_MODULE_9__.setChatFieldFocus)();\r\n        // Execute the function to trigger the process of chat cleaning after the youtube and images convertation to avoid issues\r\n        executeMessageRemover();\r\n        // Initialize the input field listener to handle message sending when Enter is pressed\r\n        (0,_modules_chat_js__WEBPACK_IMPORTED_MODULE_9__.setupChatInputListener)();\r\n      }\r\n    }\r\n  });\r\n\r\n  // start observing the DOM for changes\r\n  waitForChatObserver.observe(document, { childList: true, subtree: true });\r\n})();\n\n//# sourceURL=webpack://tampermonkey-script/./src/main.js?");

/***/ }),

/***/ "./src/modules/cache.js":
/*!******************************!*\
  !*** ./src/modules/cache.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCacheButton: () => (/* binding */ createCacheButton),\n/* harmony export */   updateUserCountText: () => (/* binding */ updateUserCountText)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/modules/helpers.js\");\n/* harmony import */ var _notifications_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./notifications.js */ \"./src/modules/notifications.js\");\n/* harmony import */ var _icons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons.js */ \"./src/modules/icons.js\");\n/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./definitions.js */ \"./src/modules/definitions.js\");\n// helpers && helpers definitions\r\n\r\n\r\n// notifications\r\n\r\n\r\n// icons\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Array to store user IDs and their status titles\r\nlet fetchedUsers = JSON.parse(localStorage.getItem('fetchedUsers')) || {};\r\n\r\n// Rank order mapping\r\nconst rankOrder = {\r\n  '': 1,\r\n  '': 2,\r\n  '': 3,\r\n  '': 4,\r\n  '': 5,\r\n  '': 6,\r\n  '': 7,\r\n  '': 8,\r\n  '': 9\r\n};\r\n\r\n// Rank color mapping\r\nconst rankColors = {\r\n  '': '#06B4E9', // Light Blue\r\n  '': '#5681ff', // Medium Blue\r\n  '': '#B543F5', // Purple\r\n  '': '#DA0543', // Red\r\n  '': '#FF8C00', // Orange\r\n  '': '#C1AA00', // Yellow\r\n  '': '#2DAB4F', // Green\r\n  '': '#61B5B3', // Light Cyan\r\n  '': '#AFAFAF' // Grey\r\n};\r\n\r\n\r\n// Global function to prepend an emoticon to the visits element in the cache panel.\r\nfunction updateVisitsEmoticon(visitsElement) {\r\n  // Convert content to number; exit if invalid\r\n  const count = Number(visitsElement.textContent);\r\n  if (isNaN(count)) return console.warn('Invalid visits count!');\r\n\r\n  // Select emoticon: 010: , 1120: , 2130: , above 30: \r\n  const emoticon = count <= 10 ? '' : count <= 20 ? '' : count <= 30 ? '' : '';\r\n\r\n  visitsElement.textContent = `${emoticon} ${count}`;\r\n}\r\n\r\n// Function to display the cached user list panel\r\nfunction showCachePanel() {\r\n  // Check if the panel already exists\r\n  const existingPanel = document.querySelector('.cached-users-panel');\r\n  if (existingPanel) {\r\n    existingPanel.remove(); // Remove the settings panel\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)('hide');\r\n    return; // Return immediately to prevent further execution\r\n  }\r\n\r\n  // Remove any previous panel before creating a new one\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removePreviousPanel)();\r\n\r\n  // Initialize users by parsing fetched data or setting as empty object\r\n  let users = fetchedUsers;\r\n\r\n  // Create a container div with class 'cached-users-panel'\r\n  const cachedUsersPanel = document.createElement('div');\r\n  cachedUsersPanel.className = 'cached-users-panel popup-panel';\r\n\r\n  // Define the event handler function for the cache panel\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_3__.state.panelsEvents.handleCacheKeydown = (event) => { // Assign the function to the object\r\n    if (event.key === 'Escape') {\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerTargetElement)(cachedUsersPanel, 'hide');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)('hide');\r\n      document.removeEventListener('keydown', _definitions_js__WEBPACK_IMPORTED_MODULE_3__.state.panelsEvents.handleCacheKeydown); // Remove the event listener\r\n    }\r\n  };\r\n\r\n  // Attach the event listener\r\n  document.addEventListener('keydown', _definitions_js__WEBPACK_IMPORTED_MODULE_3__.state.panelsEvents.handleCacheKeydown);\r\n\r\n  // Create a container div with class 'panel-header'\r\n  const panelHeaderContainer = document.createElement('div');\r\n  panelHeaderContainer.className = 'panel-header';\r\n\r\n  // Create a container div with class 'drop-time'\r\n  const dropTime = document.createElement('div');\r\n  dropTime.className = 'drop-time';\r\n\r\n  // Create span with description for threshold time element\r\n  const dropTimeThresholdDescription = document.createElement('span');\r\n  dropTimeThresholdDescription.className = 'drop-time-threshold-description';\r\n  dropTimeThresholdDescription.textContent = ' Threshold';\r\n\r\n  const dropTimeThreshold = document.createElement('span');\r\n  dropTimeThreshold.className = 'drop-time-threshold';\r\n\r\n  // Get the value from the localStorage key 'cacheRefreshThresholdHours'\r\n  const storedThresholdTime = localStorage.getItem('cacheRefreshThresholdHours');\r\n  // Update the innerHTML with the stored value (default to '00:00:00' if the key is not set)\r\n  dropTimeThreshold.innerHTML = storedThresholdTime || '00:00:00';\r\n  // Attach click event to the dropTimeThreshold element\r\n  dropTimeThreshold.addEventListener('click', setCacheRefreshTime);\r\n\r\n  // Create span with description for expiration time element\r\n  const dropTimeExpirationDescription = document.createElement('span');\r\n  dropTimeExpirationDescription.className = 'drop-time-expiration-description';\r\n  dropTimeExpirationDescription.textContent = ' Countdown';\r\n\r\n  const dropTimeExpiration = document.createElement('span');\r\n  dropTimeExpiration.className = 'drop-time-expiration';\r\n\r\n  // Function to prompt the user for a cache refresh time and update the content\r\n  function setCacheRefreshTime() {\r\n    let isValidInput = false;\r\n\r\n    // Keep prompting the user until valid input is provided or they click \"Cancel\"\r\n    while (!isValidInput) {\r\n      // Prompt the user for a time\r\n      const userInput = prompt('Enter a cache refresh time (e.g., HH, HH:mm, or HH:mm:ss):');\r\n\r\n      // Get the dropTimeThreshold element\r\n      const dropTimeThreshold = document.querySelector('.drop-time-threshold');\r\n\r\n      // Validate the user input\r\n      const timeRegex = /^([0-9]+|[01][0-9]|2[0-4])(:([0-5]?[0-9])(:([0-5]?[0-9]))?)?$/; // HH, HH:mm, or HH:mm:ss\r\n\r\n      if (userInput === null) {\r\n        // User clicked \"Cancel,\" exit the loop\r\n        isValidInput = true;\r\n      } else if (timeRegex.test(userInput)) {\r\n        // Valid input, extract hours and set default values for minutes and seconds if not provided\r\n        const formattedInput = userInput.split(':');\r\n        const hours = ('0' + formattedInput[0]).slice(-2);\r\n        const minutes = ('0' + (formattedInput[1] || '00')).slice(-2);\r\n        const seconds = ('0' + (formattedInput[2] || '00')).slice(-2);\r\n\r\n        // Update the content of the dropTimeThreshold element\r\n        dropTimeThreshold.textContent = `${hours}:${minutes}:${seconds}`;\r\n\r\n        // Combine the values and store in localStorage with the key 'cacheRefreshThresholdHours'\r\n        const formattedTime = `${hours}:${minutes}:${seconds}`;\r\n        localStorage.setItem('cacheRefreshThresholdHours', formattedTime);\r\n\r\n        // Remove fetchedUsers, lastClearTime, and nextClearTime keys\r\n        localStorage.removeItem('fetchedUsers');\r\n        localStorage.removeItem('lastClearTime');\r\n        localStorage.removeItem('nextClearTime');\r\n\r\n        // Reload the current page after (N) time after changing the cache threshold\r\n        setTimeout(() => location.reload(), 1000);\r\n\r\n        // Set isValidInput to true to exit the loop\r\n        isValidInput = true;\r\n      } else {\r\n        // Alert the user for invalid input\r\n        alert('Invalid time format. Please enter a valid time in the format HH, HH:mm, or HH:mm:ss.');\r\n      }\r\n    }\r\n  }\r\n\r\n  // Append the childs to the drop time parent element\r\n  dropTime.appendChild(dropTimeThresholdDescription);\r\n  dropTime.appendChild(dropTimeThreshold);\r\n  dropTime.appendChild(dropTimeExpirationDescription);\r\n  dropTime.appendChild(dropTimeExpiration);\r\n\r\n  // Append the drop time element to the panel header container\r\n  panelHeaderContainer.appendChild(dropTime);\r\n\r\n  // Create a container div for the search input\r\n  const cacheSearchContainer = document.createElement('div');\r\n  cacheSearchContainer.className = 'search-for-cached-users';\r\n\r\n  // Create the input field for searching users\r\n  const cacheSearchInput = document.createElement('input');\r\n  cacheSearchInput.className = 'cached-users-search-input';\r\n  cacheSearchInput.type = 'text';\r\n\r\n  // Append search input to the search container\r\n  cacheSearchContainer.appendChild(cacheSearchInput);\r\n\r\n  // Add click event listener to clear the search input by LMB click with Ctrl key pressed\r\n  cacheSearchInput.addEventListener('click', () => _helpers_js__WEBPACK_IMPORTED_MODULE_0__.isCtrlKeyPressed && (cacheSearchInput.value = ''));\r\n\r\n  // Add event listener to listen for keydown events\r\n  cacheSearchInput.addEventListener('keydown', async (event) => {\r\n    const oldUsersContainer = document.querySelector('.old-users');\r\n    const newUsersContainer = document.querySelector('.new-users');\r\n    const fetchedUsersContainer = document.querySelector('.fetched-users');\r\n\r\n    // Handle Backspace key\r\n    if (event.key === 'Backspace' && event.target.value.length === 0) {\r\n      oldUsersContainer.style.display = 'grid';\r\n      newUsersContainer.style.display = 'grid';\r\n\r\n      const searchResultsContainer = document.querySelector('.search-results');\r\n      if (searchResultsContainer && fetchedUsersContainer) {\r\n        fetchedUsersContainer.removeChild(searchResultsContainer);\r\n      }\r\n    }\r\n    // Handle Enter key\r\n    else if (event.key === 'Enter') {\r\n      const inputValue = event.target.value.trim();\r\n\r\n      // If input is empty, set it to 'user '\r\n      if (inputValue.length === 0) {\r\n        event.preventDefault(); // Prevent the default behavior\r\n        event.target.value = 'user '; // Set input to 'user '\r\n      }\r\n    }\r\n  });\r\n\r\n  // Create a function to handle the search process\r\n  const handleSearch = async (username) => {\r\n    const oldUsersContainer = document.querySelector('.old-users');\r\n    const newUsersContainer = document.querySelector('.new-users');\r\n    const fetchedUsersContainer = document.querySelector('.fetched-users');\r\n\r\n    if (username) {\r\n      // Temporarily hide old and new user containers\r\n      oldUsersContainer.style.display = 'none';\r\n      newUsersContainer.style.display = 'none';\r\n\r\n      // Find or create the search results container\r\n      let searchResultsContainer = document.querySelector('.search-results');\r\n      if (!searchResultsContainer) {\r\n        searchResultsContainer = createUserContainer('search-results');\r\n        fetchedUsersContainer.appendChild(searchResultsContainer); // Append if it's newly created\r\n      } else {\r\n        // Clear previous search results if the container already exists\r\n        searchResultsContainer.innerHTML = null; // Clear existing elements\r\n      }\r\n\r\n      const userElements = []; // Initialize userElements array\r\n\r\n      try {\r\n        // Fetch user IDs by username\r\n        const userIds = await (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getUserIDsByName)(username);\r\n\r\n        // Iterate over each user ID and retrieve profile data\r\n        await Promise.all(userIds.map(async (userId) => {\r\n          // Retrieve the user's profile data once\r\n          const profileData = await (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getUserProfileData)(userId, false); // Do not touch localStorage key \"fetchedUsers\"\r\n\r\n          // Create user element data using the retrieved profile data\r\n          const userData = {\r\n            rank: profileData.rank, // Assign rank directly\r\n            login: profileData.login,\r\n            registered: profileData.registeredDate, // Set registered to registeredDate\r\n            bestSpeed: profileData.bestSpeed,\r\n            ratingLevel: profileData.ratingLevel,\r\n            friends: profileData.friends,\r\n            cars: profileData.cars,\r\n            avatarTimestamp: profileData.avatarTimestamp,\r\n            avatar: profileData.avatar // Include avatar in userData\r\n          };\r\n\r\n          // Create the user element with userId and userData\r\n          const userElementData = createCachePanelUserElement(userId, userData);\r\n          if (userElementData) {\r\n            userElements.push(userElementData);\r\n          }\r\n        }));\r\n\r\n        // Sort userElements by rank and best speed\r\n        userElements.sort((a, b) =>\r\n          a.order !== b.order ? a.order - b.order : b.bestSpeed - a.bestSpeed\r\n        );\r\n\r\n        // Append user elements to the search results container\r\n        userElements.forEach(({ userElement }) => {\r\n          searchResultsContainer.appendChild(userElement);\r\n        });\r\n\r\n        // Create and append the description for search results\r\n        const searchDescription = createDescription(`Search Results for: ${username}`, 'search-results-description');\r\n        searchResultsContainer.prepend(searchDescription); // Append description as the first element\r\n\r\n      } catch (error) {\r\n        console.error('Error fetching user profile:', error);\r\n\r\n        // Create an error message element and append it to the container\r\n        const errorMessage = document.createElement('div');\r\n        errorMessage.className = 'error-message';\r\n        errorMessage.textContent = `Error fetching user profile: ${error.message}`;\r\n        searchResultsContainer.appendChild(errorMessage);\r\n      }\r\n    }\r\n  };\r\n\r\n  // Debounce the handleSearch function to prevent excessive calls\r\n  cacheSearchInput.addEventListener(\r\n    'input',\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.debounce)((event) => {\r\n      const inputValue = event.target.value.trim();\r\n      const searchMode = localStorage.getItem('cachePanelSearchMode');\r\n\r\n      // Extract username if input starts with 'user ', or use input directly in 'fetch' mode\r\n      const username = inputValue.startsWith('user ')\r\n        ? inputValue.substring(5).trim()\r\n        : (searchMode === 'fetch' ? inputValue : '');\r\n\r\n      // Trigger search if a valid username exists\r\n      if (username) handleSearch(username);\r\n    }, _definitions_js__WEBPACK_IMPORTED_MODULE_3__.debounceTimeout)\r\n  );\r\n\r\n  // Append the search container to the panel header container\r\n  panelHeaderContainer.appendChild(cacheSearchContainer);\r\n\r\n  // Use a mutation observer to wait for the element to appear in the DOM\r\n  const observer = new MutationObserver(mutations => {\r\n    if (mutations.some(mutation => mutation.type === 'childList' && mutation.addedNodes.length > 0)) {\r\n      const cachePanelSearchInput = document.querySelector('.cached-users-search-input');\r\n      const cachePanelLogins = Array.from(document.querySelectorAll('.fetched-users .login'));\r\n\r\n      // Fuzzy match scoring function\r\n      const getFuzzyMatchScore = (query, text) => {\r\n        let score = 0, queryIndex = 0;\r\n        for (const char of text.toLowerCase()) {\r\n          if (queryIndex < query.length && char === query[queryIndex].toLowerCase()) {\r\n            score += 2; // Increment score for matching character\r\n            queryIndex++; // Increment index for the next character\r\n          }\r\n        }\r\n        return queryIndex === query.length ? score : 0;\r\n      };\r\n\r\n      // Filter items based on input query\r\n      const filterItems = query => {\r\n        cachePanelLogins.forEach(item => {\r\n          const userContainer = item.closest('.user-item');\r\n          userContainer.style.display = (!query || getFuzzyMatchScore(query, item.textContent) > 0) ? 'grid' : 'none';\r\n        });\r\n      };\r\n\r\n      // Set focus to the search input field\r\n      cachePanelSearchInput.focus();\r\n\r\n      // Add input event listener to filter items as the user types\r\n      cachePanelSearchInput.addEventListener('input', () => filterItems(cachePanelSearchInput.value.trim()));\r\n\r\n      observer.disconnect();\r\n    }\r\n  });\r\n\r\n  // Start observing the panel header container for changes\r\n  observer.observe(panelHeaderContainer, { childList: true, subtree: true });\r\n\r\n  // Create a container div with class 'panel-control-buttons'\r\n  const panelControlButtons = document.createElement('div');\r\n  panelControlButtons.className = 'panel-control-buttons';\r\n  panelControlButtons.style.display = 'flex';\r\n\r\n  // Create cache panel search mode button with the provided SVG icon\r\n  const cachePanelSearchMode = document.createElement('div');\r\n  cachePanelSearchMode.className = 'large-button user-mode-button';\r\n  cachePanelSearchMode.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_2__.usersSVG;\r\n\r\n  // Set the initial value or existing for cachePanelSearchMode if it doesn't exist\r\n  const currentSearchMode = localStorage.getItem('cachePanelSearchMode') || (localStorage.setItem('cachePanelSearchMode', 'cache'), 'cache');\r\n\r\n  // Set the title dynamically\r\n  cachePanelSearchMode.title = `Current active mode: ${currentSearchMode}`;\r\n\r\n  // Function to update styles based on the current mode\r\n  function updateStyles(mode) {\r\n    const button = cachePanelSearchMode;\r\n\r\n    // Toggle classes by removing and adding the appropriate class\r\n    button.classList.toggle('cache-mode-button', mode === 'cache');\r\n    button.classList.toggle('fetch-mode-button', mode !== 'cache');\r\n  }\r\n\r\n  // Initial mode setup based on the current mode\r\n  updateStyles(currentSearchMode);\r\n\r\n  // Add click event listener to the cache panel search mode button\r\n  cachePanelSearchMode.addEventListener('click', () => {\r\n    // Toggle between 'cache' and 'fetch' values\r\n    const currentMode = localStorage.getItem('cachePanelSearchMode');\r\n    const newMode = currentMode === 'cache' ? 'fetch' : 'cache';\r\n    // Set new mode in localStorage\r\n    localStorage.setItem('cachePanelSearchMode', newMode);\r\n    // Update styles based on the new mode\r\n    updateStyles(newMode);\r\n    // Set the title dynamically based on the new mode\r\n    cachePanelSearchMode.title = `Current active mode: ${newMode}`;\r\n    // Optional: Log the current mode for debugging\r\n    // console.log(`Current mode: ${newMode}`);\r\n  });\r\n\r\n  // Append the search mode button to the panel header container\r\n  panelControlButtons.appendChild(cachePanelSearchMode);\r\n\r\n  // Create a clear cache button with the provided SVG icon\r\n  const clearCacheButton = document.createElement('div');\r\n  clearCacheButton.className = 'large-button panel-header-clear-button';\r\n  clearCacheButton.title = 'Clear cache';\r\n  clearCacheButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_2__.trashSVG;\r\n\r\n  // Add a click event listener to the clear cache button\r\n  clearCacheButton.addEventListener('click', () => {\r\n    // Call the helper function to hide and remove the cachedUsersPanel\r\n    hideCachePanel();\r\n    // Clear the cache manually and reset the timer\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.refreshFetchedUsers)(true, _definitions_js__WEBPACK_IMPORTED_MODULE_3__.cacheRefreshThresholdHours);\r\n\r\n    // Set the user count element to 0\r\n    const userCountElement = document.querySelector('.cache-panel-load-button .cache-user-count');\r\n    if (userCountElement) userCountElement.textContent = '0'; // Set the user count to 0\r\n  });\r\n\r\n  // Append the clear cache button to the panel header container\r\n  panelControlButtons.appendChild(clearCacheButton);\r\n\r\n  // Create a close button with the provided SVG icon\r\n  const closePanelButton = document.createElement('div');\r\n  closePanelButton.className = 'large-button panel-header-close-button';\r\n  closePanelButton.title = 'Close panel';\r\n  closePanelButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_2__.closeSVG;\r\n\r\n  // Add a click event listener to the close panel button\r\n  closePanelButton.addEventListener('click', () => {\r\n    // Remove the cached-users-panel when the close button is clicked\r\n    hideCachePanel();\r\n  });\r\n\r\n  // Append the close button to the panel header container\r\n  panelControlButtons.appendChild(closePanelButton);\r\n\r\n  // Append the panel control buttons element inside the panel header container\r\n  panelHeaderContainer.appendChild(panelControlButtons);\r\n\r\n  // Create a container div with class 'fetched-users'\r\n  const fetchedUsersContainer = document.createElement('div');\r\n  fetchedUsersContainer.className = 'fetched-users';\r\n\r\n  // Function to create a user container with common styles\r\n  function createUserContainer(isOldUser) {\r\n    const userContainer = document.createElement('div');\r\n    userContainer.className = 'users-container';\r\n    // Add a modifier class based on whether it's an old or new user\r\n    userContainer.classList.add(isOldUser ? 'old-users' : 'new-users');\r\n    return userContainer;\r\n  }\r\n\r\n  // Create containers for old and new users\r\n  const oldUsersContainer = createUserContainer(true);\r\n  const newUsersContainer = createUserContainer(false);\r\n\r\n  // Function to create a description with customizable text and class\r\n  function createDescription(text, className) {\r\n    const description = document.createElement('span');\r\n    description.className = `description ${className}`; // Add common 'description' class with the specific className\r\n    description.textContent = text;\r\n    return description;\r\n  }\r\n\r\n  // Create descriptions\r\n  const oldUsersDescription = createDescription('Active Users', 'old-users-description');\r\n  const newUsersDescription = createDescription('New Registrations', 'new-users-description');\r\n\r\n  // Append descriptions to their respective containers\r\n  oldUsersContainer.appendChild(oldUsersDescription); // Append description to old users container\r\n  newUsersContainer.appendChild(newUsersDescription); // Append description to new users container\r\n\r\n  // Append containers to the fetchedUsersContainer\r\n  fetchedUsersContainer.appendChild(oldUsersContainer);\r\n  fetchedUsersContainer.appendChild(newUsersContainer);\r\n\r\n  // Create an array to hold user elements\r\n  const userElements = [];\r\n\r\n  // Flag to control if action log processing should continue\r\n  let shouldProcessActionLog = true;\r\n\r\n  // Get current date for comparison\r\n  const currentDate = new Date();\r\n\r\n  // Helper function to check if registered date is within the last 24 hours\r\n  const isNewUser = (registered) => {\r\n    const registeredDate = new Date(registered);\r\n    const timeDifference = currentDate - registeredDate; // Difference in milliseconds\r\n    return timeDifference <= 24 * 60 * 60 * 1000; // 24 hours in milliseconds\r\n  };\r\n\r\n  // This function creates a user element for the cache panel with detailed user information and metrics.\r\n  const createCachePanelUserElement = (userId, userData) => {\r\n    // Create the main container for the user.\r\n    const userElement = document.createElement('div');\r\n    userElement.className = 'user-item';\r\n\r\n    // Create an avatar container.\r\n    const avatarElement = document.createElement('div');\r\n    avatarElement.className = 'avatar';\r\n\r\n    // Handle avatar URL and display logic.\r\n    const avatarTimestamp = fetchedUsers[userId]?.avatarTimestamp;\r\n    const bigAvatarUrl = `/storage/avatars/${userId}_big.png`;\r\n\r\n    if ((avatarTimestamp && avatarTimestamp !== '00') || (userData.avatar && Object.keys(userData.avatar).length > 0)) {\r\n      const finalAvatarUrl = `${bigAvatarUrl}?updated=${avatarTimestamp}`;\r\n      const imgElement = document.createElement('img');\r\n      imgElement.src = finalAvatarUrl;\r\n      imgElement.alt = `${userData.login}'s avatar`;\r\n      imgElement.style.objectFit = 'cover';\r\n      avatarElement.appendChild(imgElement);\r\n    } else {\r\n      // Display a random emoji avatar if no avatar is available.\r\n      avatarElement.innerHTML = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getRandomEmojiAvatar)();\r\n    }\r\n\r\n    // Create the user data container and append login and rank elements.\r\n    const userDataElement = document.createElement('div');\r\n    userDataElement.className = 'user-data';\r\n\r\n    // Create a container to hold the login and visits elements\r\n    const loginContainer = document.createElement('div');\r\n    loginContainer.className = 'login-container';\r\n\r\n    // Create the login element with a link to the user's profile\r\n    const loginElement = document.createElement('a');\r\n    loginElement.className = 'login';\r\n    loginElement.textContent = userData.login;\r\n    loginElement.href = `https://klavogonki.ru/profile/${userId}`;\r\n\r\n    // Append the login element to the container\r\n    loginContainer.appendChild(loginElement);\r\n\r\n    // Define the URL for user profile messaging\r\n    const profileUrl = _definitions_js__WEBPACK_IMPORTED_MODULE_3__.profileBaseUrl + userId;\r\n    const messageInProfile = `${_definitions_js__WEBPACK_IMPORTED_MODULE_3__.profileBaseUrl}${_definitions_js__WEBPACK_IMPORTED_MODULE_3__.myUserId}/messages/${userId}/`;\r\n\r\n    // Attach a click event listener to the loginElement element\r\n    loginElement.addEventListener('click', function (event) {\r\n      event.preventDefault(); // Prevent the default link action\r\n\r\n      // Check if both Ctrl and Shift keys are pressed during the click event\r\n      if (event.ctrlKey && event.shiftKey) {\r\n        const newTab = window.open(messageInProfile, '_blank'); // Open the messaging page in a new window\r\n        if (newTab) newTab.focus(); // Attempt to make the new tab active\r\n      }\r\n      // Check if only the Ctrl key is pressed\r\n      else if (event.ctrlKey) {\r\n        loadProfileIntoIframe(messageInProfile); // Load the messaging profile into the iframe\r\n      }\r\n      // If Ctrl is not pressed, load the regular profile into the iframe\r\n      else {\r\n        loadProfileIntoIframe(profileUrl); // Load the regular profile into the iframe\r\n      }\r\n    });\r\n\r\n    // Assuming 'userData' and 'userId' are available\r\n    if (userData.visits !== undefined) {\r\n      const visitsElement = document.createElement('span');\r\n      visitsElement.className = 'visits';\r\n      // Add dynamic class based on whether the user is tracked or untracked\r\n      visitsElement.classList.add(userData.tracked ? 'tracked' : 'untracked');\r\n      visitsElement.textContent = userData.visits;\r\n      visitsElement.dataset.userId = userId;\r\n      // Call the function to prepend an emoticon\r\n      updateVisitsEmoticon(visitsElement);\r\n\r\n      // Add the visitsElement to the fetchedUsersContainer\r\n      loginContainer.appendChild(visitsElement);\r\n\r\n      // Add click event listener to visitsElement\r\n      visitsElement.addEventListener('click', (event) => {\r\n        shouldProcessActionLog = true; // Set back to true to resume processing the action log\r\n        const userId = visitsElement.dataset.userId; // Get the userId from the dataset\r\n        const user = fetchedUsers[userId]; // Retrieve the user data\r\n        const actionLog = user ? user.actionLog : null; // Access actionLog if user exists\r\n\r\n        if (user) {\r\n          // Check if the action log container already exists\r\n          let actionLogContainer = document.querySelector('.action-log');\r\n          if (!actionLogContainer) {\r\n            // Create a container for the action log display if it doesn't exist\r\n            actionLogContainer = document.createElement('div');\r\n            actionLogContainer.className = 'action-log';\r\n\r\n            // Append the action log container to the specific container (fetchedUsersContainer)\r\n            fetchedUsersContainer.appendChild(actionLogContainer);\r\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.adjustVisibility)(actionLogContainer, 'show', 1);\r\n          } else {\r\n            // Clear all child elements using replaceChildren (it's an empty operation for now)\r\n            actionLogContainer.replaceChildren();\r\n          }\r\n\r\n          if (actionLog && shouldProcessActionLog) {\r\n            for (let index = 0; index < actionLog.length; index++) {\r\n              if (!shouldProcessActionLog) break;\r\n              const action = actionLog[index];\r\n              if (typeof action !== \"object\" || action === null) continue;\r\n              const { type, timestamp } = action;\r\n              const userAction = userData?.login || \"Unknown User\";\r\n              const actionIconType = type === 'enter' ? _icons_js__WEBPACK_IMPORTED_MODULE_2__.enterSVG : _icons_js__WEBPACK_IMPORTED_MODULE_2__.leaveSVG;\r\n              const userPresence = type === 'enter';\r\n              // Use IIFE to capture the current value of shouldProcessActionLog\r\n              ((currentShouldProcess) => {\r\n                setTimeout(() => {\r\n                  if (currentShouldProcess) {\r\n                    (0,_notifications_js__WEBPACK_IMPORTED_MODULE_1__.createStaticNotification)(userAction, actionIconType, timestamp, userPresence, 'cachePanel');\r\n                  }\r\n                }, 10 * (index + 1));\r\n              })(shouldProcessActionLog);\r\n            }\r\n          }\r\n\r\n          const closeActionLog = (e) => {\r\n            if (!actionLogContainer.contains(e.target) || e.code === 'Space') {\r\n              if (e.code === 'Space') e.preventDefault(); // Prevent the default space key behavior\r\n              (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.adjustVisibility)(actionLogContainer, 'hide', 0);\r\n              shouldProcessActionLog = false;\r\n              ['click', 'keydown'].forEach(event => document.removeEventListener(event, closeActionLog));\r\n            }\r\n          };\r\n\r\n          ['click', 'keydown'].forEach(event => document.addEventListener(event, closeActionLog));\r\n\r\n          // Prevent the click on visitsElement from propagating, so it doesn't close immediately\r\n          event.stopPropagation();\r\n        } else {\r\n          console.error('User data not found');\r\n        }\r\n      });\r\n    }\r\n\r\n    // Append login container to user data element\r\n    userDataElement.appendChild(loginContainer);\r\n\r\n    const rankElement = document.createElement('div');\r\n    rankElement.className = 'rank';\r\n    rankElement.textContent = userData.rank || 'N/A';\r\n    rankElement.style.color = rankColors[userData.rank] || 'white';\r\n\r\n    // Append rank element to the user data element\r\n    userDataElement.appendChild(rankElement);\r\n\r\n    // Add a registered date element with hover behavior.\r\n    const registeredElement = document.createElement('div');\r\n    registeredElement.className = 'registered';\r\n    registeredElement.textContent = userData.registered || 'N/A';\r\n\r\n    let hoverTimer;\r\n    const originalContent = registeredElement.textContent;\r\n\r\n    registeredElement.addEventListener('mouseover', () => {\r\n      clearTimeout(hoverTimer);\r\n      hoverTimer = setTimeout(() => {\r\n        registeredElement.textContent = calculateTimeOnSite(userData.registered);\r\n      }, 300);\r\n    });\r\n\r\n    registeredElement.addEventListener('mouseout', () => {\r\n      clearTimeout(hoverTimer);\r\n      registeredElement.textContent = originalContent;\r\n    });\r\n\r\n    // Append registered element to user data element\r\n    userDataElement.appendChild(registeredElement);\r\n\r\n    // Helper function to create metric elements (speed, rating, etc.).\r\n    const createMetricElement = (className, color, icon, value, title, url) => {\r\n      const element = document.createElement('span');\r\n      element.className = className;\r\n      element.style.color = color;\r\n      element.innerHTML = `${icon}${value || 0}&nbsp;&nbsp;`;\r\n      element.title = title;\r\n      element.style.cursor = 'pointer';\r\n      element.addEventListener('click', () => loadProfileIntoIframe(url));\r\n      return element;\r\n    };\r\n\r\n    // Create individual metric elements for the user.\r\n    const bestSpeedElement = createMetricElement(\r\n      'best-speed',\r\n      'cyan',\r\n      '',\r\n      userData.bestSpeed,\r\n      'Best speed',\r\n      `https://klavogonki.ru/u/#/${userId}/stats/normal/`\r\n    );\r\n\r\n    const ratingLevelElement = createMetricElement(\r\n      'rating-level',\r\n      'gold',\r\n      '',\r\n      userData.ratingLevel,\r\n      'Rating level',\r\n      `https://klavogonki.ru/top/rating/today?s=${userData.login}`\r\n    );\r\n\r\n    const carsElement = createMetricElement(\r\n      'cars-count',\r\n      'lightblue',\r\n      '',\r\n      userData.cars,\r\n      'Cars count',\r\n      `https://klavogonki.ru/u/#/${userId}/car/`\r\n    );\r\n\r\n    const friendsElement = createMetricElement(\r\n      'friends-count',\r\n      'lightgreen',\r\n      '',\r\n      userData.friends,\r\n      'Friends count',\r\n      `https://klavogonki.ru/u/#/${userId}/friends/list/`\r\n    );\r\n\r\n    // Group all metrics into a container.\r\n    const userMetrics = document.createElement('div');\r\n    userMetrics.className = 'user-metrics';\r\n\r\n    // Append metrics elements into metrics wrapper\r\n    userMetrics.append(bestSpeedElement, ratingLevelElement, carsElement, friendsElement);\r\n\r\n    // Append all the groups of elements\r\n    userElement.append(avatarElement, userDataElement, userMetrics);\r\n\r\n    // Return the created user element and its relevant data.\r\n    return {\r\n      userElement,\r\n      order: rankOrder[userData.rank] || 10,\r\n      bestSpeed: userData.bestSpeed || 0,\r\n      registered: userData.registered\r\n    };\r\n  };\r\n\r\n  // Check if the current mode is 'cache'\r\n  if (localStorage.getItem('cachePanelSearchMode') === 'cache') {\r\n    // Iterate through each user\r\n    Object.keys(users).forEach(async (userId) => {\r\n      const userData = users[userId];\r\n      const userElementData = createCachePanelUserElement(userId, userData);\r\n      userElements.push(userElementData);\r\n    });\r\n\r\n    // Sort userElements by rank and best speed\r\n    userElements.sort((a, b) =>\r\n      // First by rank, then by speed\r\n      a.order !== b.order ? a.order - b.order : b.bestSpeed - a.bestSpeed\r\n    );\r\n\r\n    // Distribute userElements into new or old users containers\r\n    userElements.forEach(({ userElement, registered }) => {\r\n      // Choose container\r\n      const targetContainer = isNewUser(registered) ? newUsersContainer : oldUsersContainer;\r\n      // Append userElement\r\n      targetContainer.appendChild(userElement);\r\n    });\r\n  }\r\n\r\n  // Append the panel-header container to the cached-users-panel\r\n  cachedUsersPanel.appendChild(panelHeaderContainer);\r\n  // Append the fetched-users container to the cached-users-panel\r\n  cachedUsersPanel.appendChild(fetchedUsersContainer);\r\n  // Append the cached-users-panel to the body\r\n  document.body.appendChild(cachedUsersPanel);\r\n\r\n  // Create and append scroll buttons\r\n  const {\r\n    scrollButtonsContainer\r\n  } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.createScrollButtons)(fetchedUsersContainer);\r\n  cachedUsersPanel.appendChild(scrollButtonsContainer);\r\n\r\n  // Fade in the cached users panel\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerTargetElement)(cachedUsersPanel, 'show');\r\n\r\n  // Show the dimming background\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)('show');\r\n\r\n  // Function to update the remaining time\r\n  function updateRemainingTime() {\r\n    const lastClearTime = localStorage.getItem('lastClearTime');\r\n    const nextClearTime = localStorage.getItem('nextClearTime');\r\n    const dropTimeExpiration = document.querySelector('.drop-time-expiration');\r\n\r\n    if (lastClearTime && nextClearTime && dropTimeExpiration) {\r\n      const currentTime = new Date().getTime();\r\n\r\n      // Calculate the remaining time until the next cache clear\r\n      const remainingTime = nextClearTime - currentTime;\r\n\r\n      // If remaining time is zero or less, execute the refreshFetchedUsers function\r\n      remainingTime <= 0\r\n        ? (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.refreshFetchedUsers)(true, _definitions_js__WEBPACK_IMPORTED_MODULE_3__.cacheRefreshThresholdHours)\r\n        : updatedropTimeExpiration(dropTimeExpiration, remainingTime);\r\n    }\r\n  }\r\n\r\n  // Create a mapping of seconds to clock emojis\r\n  const emojiMap = {\r\n    0: '',\r\n    5: '',\r\n    10: '',\r\n    15: '',\r\n    20: '',\r\n    25: '',\r\n    30: '',\r\n    35: '',\r\n    40: '',\r\n    45: '',\r\n    50: '',\r\n    55: '',\r\n  };\r\n\r\n  // Function to update the drop-time-expiration span\r\n  function updatedropTimeExpiration(dropTimeExpiration, remainingTime) {\r\n    // Calculate hours, minutes, and seconds\r\n    const hours = String(Math.floor(remainingTime / (60 * 60 * 1000))).padStart(2, '0');\r\n    const minutes = String(Math.floor((remainingTime % (60 * 60 * 1000)) / (60 * 1000))).padStart(2, '0');\r\n    const seconds = String(Math.floor((remainingTime % (60 * 1000)) / 1000)).padStart(2, '0');\r\n\r\n    // Create the formatted time string\r\n    const remainingTimeString = `${hours}:${minutes}:${seconds}`;\r\n\r\n    // Determine the current seconds\r\n    const parsedSeconds = parseInt(seconds, 10);\r\n\r\n    // Use the parsed seconds to find the emoji index, moving one forward\r\n    const nextInterval = Math.ceil(parsedSeconds / 5) * 5; // Move to the next 5-second mark\r\n    const currentEmoji = emojiMap[nextInterval] || emojiMap[0]; // Default to 00 if not found\r\n\r\n    // Update the drop-time-expiration span with the time and emoji\r\n    dropTimeExpiration.textContent = `${remainingTimeString} ${currentEmoji}`;\r\n  }\r\n\r\n  // Call the function to update the remaining time every second\r\n  setInterval(updateRemainingTime, 1000);\r\n\r\n  // Initial update\r\n  updateRemainingTime();\r\n} // showCachePanel END\r\n\r\n// Global function to smoothly hide and remove the cachedUsersPanel\r\nfunction hideCachePanel() {\r\n  const cachedUsersPanel = document.querySelector('.cached-users-panel');\r\n\r\n  if (cachedUsersPanel) {\r\n    // Call the fade function for the cachedUsersPanel\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerTargetElement)(cachedUsersPanel, 'hide');\r\n    // Call the fade function for the dimming element\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)('hide');\r\n  }\r\n} // hideCachePanel END\r\n\r\nfunction createCacheButton(panel) {\r\n  // Create a new element with class 'cache-panel-load-button'\r\n  const showUserListCacheButton = document.createElement('div');\r\n\r\n  // Add the classes to the button\r\n  showUserListCacheButton.classList.add(\"empowerment-button\", \"cache-panel-load-button\");\r\n\r\n  // Apply cache-specific styles\r\n  showUserListCacheButton.style.position = 'relative';\r\n  showUserListCacheButton.style.zIndex = '3';\r\n\r\n  // Set the inner HTML with the icon (using the global variable or later fix)\r\n  showUserListCacheButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_2__.userlistCacheSVG; // Adjust this later as needed\r\n\r\n  // Create the small indicator for user count\r\n  const cacheUserCount = document.createElement('div');\r\n  cacheUserCount.classList.add('cache-user-count');\r\n\r\n  // Initially set the count based on localStorage\r\n  const cacheUserCountValue = Object.keys(fetchedUsers).length;\r\n  cacheUserCount.textContent = cacheUserCountValue;\r\n\r\n  showUserListCacheButton.appendChild(cacheUserCount);\r\n\r\n  // Assign a title to the button\r\n  showUserListCacheButton.title = 'Show Cache Panel';\r\n\r\n  // Add a click event listener to the button\r\n  showUserListCacheButton.addEventListener('click', function () {\r\n    // Add pulse effect for the button (ensure addPulseEffect is defined or imported)\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addPulseEffect)(showUserListCacheButton);\r\n\r\n    // Call showCachePanel to show the cache panel (ensure showCachePanel is defined or imported)\r\n    showCachePanel();\r\n  });\r\n\r\n  // Append the button to the provided panel\r\n  panel.appendChild(showUserListCacheButton);\r\n}\r\n\r\n// Function to update the user count displayed near the cache button based on localStorage\r\nfunction updateUserCountText() {\r\n  const userCountElement = document.querySelector('.cache-panel-load-button .cache-user-count');\r\n  if (!userCountElement) return; // Ensure the element exists\r\n\r\n  // Get count from state instead of localStorage\r\n  const newUserCount = Object.keys(fetchedUsers).length.toString();\r\n\r\n  // Update the text content and add pulse effect if the count has changed\r\n  if (newUserCount !== userCountElement.textContent) {\r\n    userCountElement.textContent = newUserCount;\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addPulseEffect)(userCountElement);\r\n  }\r\n}\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/cache.js?");

/***/ }),

/***/ "./src/modules/chat.js":
/*!*****************************!*\
  !*** ./src/modules/chat.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getChatElements: () => (/* binding */ getChatElements),\n/* harmony export */   getChatSystemMessage: () => (/* binding */ getChatSystemMessage),\n/* harmony export */   restoreChatTab: () => (/* binding */ restoreChatTab),\n/* harmony export */   setChatFieldFocus: () => (/* binding */ setChatFieldFocus),\n/* harmony export */   setupChatInputListener: () => (/* binding */ setupChatInputListener),\n/* harmony export */   setupInputBackup: () => (/* binding */ setupInputBackup)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/modules/helpers.js\");\n// helpers\r\n\r\n\r\n// ========================================================================\r\n// DEFINITIONS\r\n// ========================================================================\r\n\r\nconst currentLocationIncludes = part => window.location.href.includes(part);\r\n\r\nconst extraTimeout = 5000;\r\nconst minimalTimeout = 1000;\r\n\r\nconst blockedChatMessage = '    ';\r\nconst lostConnectionMessage = '   ';\r\n\r\n// ========================================================================\r\n// HELPER FUNCTIONS\r\n// ========================================================================\r\n\r\n// ---- DOM Utilities ----\r\n// Dynamically retrieves the current chat elements based on the active tab.\r\nconst getChatElements = () => {\r\n  const activeTab = localStorage.getItem('activeChatTab');\r\n  const isGameLocation = window.location.href.includes('gmid');\r\n\r\n  // Default to general chat elements\r\n  const chatFieldSelector = isGameLocation\r\n    ? (activeTab === 'game' ? '[id^=\"chat-game\"] .text' : '#chat-general .text')\r\n    : '#chat-general .text';\r\n\r\n  const chatSendSelector = isGameLocation\r\n    ? (activeTab === 'game' ? '[id^=\"chat-game\"] .send' : '#chat-general .send')\r\n    : '#chat-general .send';\r\n\r\n  // Get the currently active tab based on localStorage's activeTab value (used for restore)\r\n  const activeChatTab = document.querySelector(\r\n    isGameLocation\r\n      ? (activeTab === 'game' ? '.game.c' : '.general.c') // Select the active tab (game or general)\r\n      : (activeTab === 'general' ? '.general.c' : '.game.c') // If activeTab is general, select general\r\n  );\r\n\r\n  // Get next tab to switch (either general or game)\r\n  const nextChatTab = document.querySelector(\r\n    isGameLocation\r\n      ? (document.querySelector('.game.c.active') ? '.general.c' : '.game.c')\r\n      : (document.querySelector('.general.c.active') ? '.game.c' : '.general.c')\r\n  );\r\n\r\n  return {\r\n    chatField: document.querySelector(chatFieldSelector),\r\n    chatSend: document.querySelector(chatSendSelector),\r\n    activeChatTab, // Return the currently active tab element (either general or game)\r\n    nextChatTab, // Return the next tab to switch to\r\n    chatHidden: document.querySelector('#chat-wrapper.chat-hidden')\r\n  };\r\n};\r\n\r\n// ---- Chat System Helpers ----\r\n// Extracts a system message from the chat field's value.\r\n// Returns the message string if found, or null otherwise.\r\nfunction getChatSystemMessage(chatField) {\r\n  if (!chatField) return null;\r\n  const value = chatField.value;\r\n  if (value.includes(blockedChatMessage)) return blockedChatMessage;\r\n  if (value.includes(lostConnectionMessage)) return lostConnectionMessage;\r\n  return null;\r\n}\r\n\r\n// ========================================================================\r\n// CHAT CONNECTION RESTORATION AND UNBLOCK HANDLER\r\n// ========================================================================\r\nif (currentLocationIncludes('gamelist')) {\r\n  // Function to handle changes when the chat field is disabled.\r\n  function handleChatStateChange(timeout, chatField, chatSend) {\r\n    if (chatField.disabled) {\r\n      const systemMessage = getChatSystemMessage(chatField);\r\n      if (systemMessage === blockedChatMessage) {\r\n        // Re-enable the chat field and send button, and update their styles.\r\n        chatField.disabled = chatSend.disabled = false;\r\n        chatSend.style.setProperty('background-color', 'rgb(160, 35, 35)', 'important');\r\n        chatSend.style.setProperty(\r\n          'background-image',\r\n          `url(\"data:image/svg+xml,${encodeURIComponent(icons.deniedSVG)}\")`,\r\n          'important'\r\n        );\r\n        chatSend.style.setProperty('background-repeat', 'no-repeat', 'important');\r\n        chatSend.style.setProperty('background-position', 'center', 'important');\r\n        chatSend.style.setProperty('color', 'transparent', 'important');\r\n        chatField.value = null;\r\n        console.log('Chat field was blocked, re-enabled.');\r\n      } else if (systemMessage === lostConnectionMessage) {\r\n        // Schedule a reload using timeout.\r\n        console.log('Lost connection, reloading...');\r\n        setTimeout(() => {\r\n          window.location.reload();\r\n        }, timeout);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Create a MutationObserver to watch for attribute changes.\r\n  const observer = new MutationObserver(() => {\r\n    // Get updated chat elements.\r\n    const { chatField, chatSend } = getChatElements();\r\n    // Handle the change when the 'disabled' attribute is modified.\r\n    handleChatStateChange(extraTimeout, chatField, chatSend);\r\n  });\r\n\r\n  // Get the chat field element.\r\n  const { chatField: chatInputText } = getChatElements();\r\n  // Start observing the chatField for changes to the 'disabled' attribute.\r\n  if (chatInputText)\r\n    observer.observe(chatInputText, { attributes: true, attributeFilter: ['disabled'] });\r\n\r\n  // Compact visibilitychange event: When the document becomes visible,\r\n  // set a shorter timeout duration and check the chat state.\r\n  document.addEventListener('visibilitychange', () => {\r\n    if (document.visibilityState === 'visible') {\r\n      const { chatField, chatSend } = getChatElements();\r\n      handleChatStateChange(minimalTimeout, chatField, chatSend);\r\n    }\r\n  });\r\n}\r\n\r\n// ========================================================================\r\n// CHAT FOCUS\r\n// ========================================================================\r\n\r\n// Function to set focus on the chat input field based on the active tab.\r\nfunction setChatFieldFocus() {\r\n  const { chatHidden, chatField } = getChatElements(); // Get chat field elements\r\n\r\n  if (!chatHidden && chatField) {\r\n    chatField.focus(); // Set focus on the chat input field\r\n  }\r\n}\r\n\r\n// ========================================================================\r\n// CHAT SWITCHER  \r\n// ========================================================================\r\n\r\nfunction switchChatByKeydown() {\r\n  const { nextChatTab, chatField, chatHidden } = getChatElements();\r\n\r\n  if (!chatHidden && nextChatTab) {\r\n    nextChatTab.click();\r\n    chatField?.focus();\r\n  }\r\n}\r\n\r\nfunction switchChatByClick(event) {\r\n  console.log('Clicked element:', event.target);\r\n  const activeTab = event.target.classList.contains('general') ? 'general' : 'game';\r\n  localStorage.setItem('activeChatTab', activeTab);\r\n}\r\n\r\n// Function to restore the active chat tab and set focus on the chat input.\r\nfunction restoreChatTab() {\r\n  const { activeChatTab, chatField } = getChatElements();\r\n  activeChatTab?.click();\r\n  chatField?.focus();\r\n}\r\n\r\n// ========================================================================\r\n// CHAT EVENTS & LISTENERS\r\n// ========================================================================\r\n\r\n\r\n[...document.querySelectorAll('.general.c, .game.c')].forEach(tab =>\r\n  tab.addEventListener('click', switchChatByClick)\r\n);\r\n\r\ndocument.addEventListener('keydown', event => {\r\n  if (event.key === 'Tab') {\r\n    switchChatByKeydown();\r\n    event.preventDefault();\r\n  }\r\n});\r\n\r\n// ========================================================================\r\n// INPUT BACKUP & RESTORATION\r\n// ========================================================================\r\n\r\nfunction setupInputBackup() {\r\n  const { chatField } = getChatElements();\r\n  if (chatField) {\r\n    chatField.value = localStorage.getItem('inputBackup') || '';\r\n\r\n    chatField.addEventListener('input', (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.debounce)(() => {\r\n      if (!getChatSystemMessage(chatField)) localStorage.setItem('inputBackup', chatField.value);\r\n    }, 250));\r\n\r\n    chatField.addEventListener('keydown', event => {\r\n      if (event.key === 'Enter') localStorage.removeItem('inputBackup');\r\n    });\r\n  }\r\n}\r\n\r\n// ========================================================================\r\n// MESSAGE SENDING\r\n// ========================================================================\r\n\r\n// Compact function to break text into pieces of up to 300 characters.\r\nfunction breakSentence(text) {\r\n  const maxLength = 300;\r\n  return text.split(' ').reduce((acc, word) => {\r\n    const last = acc[acc.length - 1];\r\n    return (last + ' ' + word).trim().length > maxLength\r\n      ? [...acc, word]\r\n      : [...acc.slice(0, -1), (last + ' ' + word).trim()];\r\n  }, ['']);\r\n}\r\n\r\nasync function sendMessageInParts(message) {\r\n  const pieces = breakSentence(message);\r\n  const { chatField, chatSend } = getChatElements();\r\n  const isLongMessage = message.length > 300;\r\n\r\n  if (isLongMessage) {\r\n    chatField.disabled = true;\r\n  }\r\n\r\n  for (let index = 0; index < pieces.length; index++) {\r\n    const fullMessage = pieces[index];\r\n    chatField.value = fullMessage;\r\n    console.log(`Sending piece ${index + 1}: \"${fullMessage}\" (Length: ${fullMessage.length})`);\r\n    chatSend.click();\r\n\r\n    if (index < pieces.length - 1) {\r\n      const randomDelay = Math.floor(Math.random() * 500) + 500;\r\n      console.log(`Waiting for ${randomDelay} ms before sending the next piece.`);\r\n      await new Promise(resolve => setTimeout(resolve, randomDelay));\r\n    }\r\n  }\r\n\r\n  if (isLongMessage) {\r\n    chatField.disabled = false;\r\n  }\r\n}\r\n\r\n// ========================================================================\r\n// CHAT INPUT EVENTS\r\n// ========================================================================\r\n\r\nfunction setupChatInputListener() {\r\n  const { chatField } = getChatElements();\r\n  chatField.setAttribute('maxlength', '1000');\r\n\r\n  chatField.addEventListener('paste', event => {\r\n    event.preventDefault();\r\n    const pastedValue = event.clipboardData.getData('text');\r\n    let processedValue = pastedValue;\r\n\r\n    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isValidEncodedURL)(pastedValue)) {\r\n      processedValue = decodeURL(pastedValue);\r\n    }\r\n\r\n    const start = chatField.selectionStart;\r\n    const end = chatField.selectionEnd;\r\n    chatField.value = chatField.value.slice(0, start) + processedValue + chatField.value.slice(end);\r\n    chatField.setSelectionRange(start + processedValue.length, start + processedValue.length);\r\n  });\r\n\r\n  chatField.addEventListener('keydown', event => {\r\n    const message = chatField.value;\r\n    if (event.key === 'Enter') {\r\n      if (message.length > 300) {\r\n        event.preventDefault();\r\n        sendMessageInParts(message);\r\n        console.log(`Long message processed: \"${message}\"`);\r\n        chatField.value = '';\r\n      } else {\r\n        console.log(`Short message processed: \"${message}\"`);\r\n      }\r\n    }\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/chat.js?");

/***/ }),

/***/ "./src/modules/chatlogs.js":
/*!*********************************!*\
  !*** ./src/modules/chatlogs.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createChatLogsButton: () => (/* binding */ createChatLogsButton)\n/* harmony export */ });\n/* harmony import */ var _image_converter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-converter.js */ \"./src/modules/image-converter.js\");\n/* harmony import */ var _video_converter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./video-converter.js */ \"./src/modules/video-converter.js\");\n/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons */ \"./src/modules/icons.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.js */ \"./src/modules/helpers.js\");\n/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./definitions.js */ \"./src/modules/definitions.js\");\n // image converter\r\n // video converter\r\n\r\n// icons\r\n\r\n\r\n// helpers\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Define dynamic variables\r\nlet {\r\n  panelsEvents,\r\n  isCtrlKeyPressed\r\n} = _definitions_js__WEBPACK_IMPORTED_MODULE_4__.state;\r\n\r\n// Function to create the button for opening chat logs\r\nfunction createChatLogsButton(panel) {\r\n  const showChatLogsButton = document.createElement('div');\r\n  showChatLogsButton.classList.add(\"empowerment-button\", \"chat-logs-button\");\r\n\r\n  showChatLogsButton.style.position = 'relative';\r\n  showChatLogsButton.style.zIndex = '1';\r\n  showChatLogsButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.chatLogsSVG; // Add icon\r\n\r\n  showChatLogsButton.title = 'Show Chat Logs';\r\n\r\n  showChatLogsButton.addEventListener('click', async function () {\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.addPulseEffect)(showChatLogsButton); // Add pulse effect\r\n    await showChatLogsPanel();\r\n  });\r\n\r\n  panel.appendChild(showChatLogsButton);\r\n}\r\n\r\n// Function to fetch chat logs from the specified URL for a given date\r\nconst fetchChatLogs = async (date, messagesContainer) => {\r\n  // Clear the messagesContainer if it exists\r\n  messagesContainer && (messagesContainer.innerHTML = '');\r\n\r\n  // Generate a random 20-digit number\r\n  const randomParam = Math.floor(Math.random() * 10 ** 20);\r\n\r\n  // Construct the URL to fetch chat logs for the specified date with the random parameter\r\n  const url = `https://klavogonki.ru/chatlogs/${date}.html?rand=${randomParam}`;\r\n\r\n  // Function to parse the HTML and extract chat log entries\r\n  const parseChatLog = (html) => {\r\n    const doc = new DOMParser().parseFromString(html, 'text/html');\r\n\r\n    return [...doc.querySelectorAll('.ts')].map((timeElement) => {\r\n      const usernameElement = timeElement.nextElementSibling;\r\n      const messageNode = usernameElement?.nextSibling;\r\n\r\n      const extractMessageText = (node) => {\r\n        if (!node) return '';\r\n        return [...node.childNodes].reduce((acc, child) => {\r\n          if (child.nodeType === Node.TEXT_NODE) {\r\n            acc += child.textContent;\r\n          } else if (child.nodeType === Node.ELEMENT_NODE) {\r\n            if (child.tagName === 'A') {\r\n              acc += child.getAttribute('href');\r\n            } else if (child.tagName === 'BR') {\r\n              return acc;\r\n            }\r\n          }\r\n          return acc;\r\n        }, '').trim();\r\n      };\r\n\r\n      if (usernameElement?.classList.contains('mn') && messageNode) {\r\n        let messageText = '';\r\n\r\n        if (messageNode.nodeType === Node.ELEMENT_NODE) {\r\n          messageText = extractMessageText(messageNode);\r\n        } else if (messageNode.nodeType === Node.TEXT_NODE) {\r\n          const nextSibling = usernameElement.nextElementSibling;\r\n          if (nextSibling && nextSibling.tagName === 'A') {\r\n            messageText = `${messageNode.textContent.trim()} ${nextSibling.getAttribute('href')}`;\r\n          } else {\r\n            messageText = messageNode.textContent.trim();\r\n          }\r\n        }\r\n\r\n        if (!messageText) {\r\n          const combinedText = extractMessageText(usernameElement.nextSibling);\r\n          messageText = combinedText;\r\n        }\r\n\r\n        return {\r\n          time: timeElement.textContent.trim().replace(/[\\[\\]]/g, ''),\r\n          username: usernameElement.textContent.trim().replace(/<|>/g, ''),\r\n          message: messageText || null,\r\n        };\r\n      }\r\n\r\n      // Handle case where username is not found, and instead, `mne` class is present (system message)\r\n      const systemMessageElement = timeElement.nextElementSibling;\r\n      if (systemMessageElement && systemMessageElement.classList.contains('mne')) {\r\n        // Extract the text directly from the <font> element\r\n        const messageText = systemMessageElement.textContent.trim();\r\n        return {\r\n          time: timeElement.textContent.trim().replace(/[\\[\\]]/g, ''),\r\n          username: 'SYSTEM', // Set username as 'SYSTEM' for system messages\r\n          message: messageText || null,\r\n        };\r\n      }\r\n\r\n      return null;\r\n    }).filter(Boolean);\r\n  };\r\n\r\n  try {\r\n    // Fetch chat logs from the URL\r\n    const response = await fetch(url);\r\n    if (!response.ok) {\r\n      throw new Error('Network response was not ok');\r\n    }\r\n\r\n    // Get the HTML content\r\n    const html = await response.text();\r\n\r\n    // Limit the size of the HTML to 5KB\r\n    const sizeLimitKB = 1000; // Set the size limit in KB\r\n    const sizeLimitBytes = sizeLimitKB * 1024; // Convert KB to bytes\r\n    const htmlContent = html.length > sizeLimitBytes ? html.slice(0, sizeLimitBytes) : html;\r\n\r\n    // Parse the HTML and extract chat logs\r\n    const chatlogs = parseChatLog(htmlContent);\r\n\r\n    const limitReached = html.length > sizeLimitBytes;\r\n\r\n    // Step 1: Remove consecutive duplicate messages\r\n    const noSpamMessages = [];\r\n    let lastMessage = null;\r\n\r\n    for (const log of chatlogs) {\r\n      const isDifferentMessage = log.message !== lastMessage?.message;\r\n      const isDifferentUser = log.username !== lastMessage?.username;\r\n\r\n      // Include the message if:\r\n      // - It's the first message, or\r\n      // - It's a different message or from a different user\r\n      if (isDifferentMessage || isDifferentUser) {\r\n        noSpamMessages.push(log);\r\n        lastMessage = log;\r\n      }\r\n    }\r\n\r\n    // Step 2: Filter out messages from ignored users\r\n    const finalChatlogs = noSpamMessages.filter((log) => !_definitions_js__WEBPACK_IMPORTED_MODULE_4__.ignored.includes(log.username));\r\n\r\n    // Return the filtered chat logs, size of HTML, URL, and info\r\n    return {\r\n      chatlogs: finalChatlogs,\r\n      url: url,\r\n      size: htmlContent.length,\r\n      info: limitReached,\r\n      error: null,\r\n    }\r\n  } catch (error) {\r\n    // Handle other errors (e.g., parsing errors)\r\n    return {\r\n      chatlogs: [],\r\n      url: url,\r\n      size: 0,\r\n      error: error.message,\r\n    }\r\n  }\r\n}\r\n\r\nconst minDate = '2012-02-12'; // Define the minimum date\r\n\r\nfunction getRandomDateInRange() {\r\n  const startDate = new Date(minDate); // Start date\r\n  const endDate = new Date(); // Current date\r\n\r\n  // Calculate the difference in milliseconds\r\n  const dateDifference = endDate - startDate;\r\n\r\n  // Generate a random number of milliseconds between 0 and dateDifference\r\n  const randomMilliseconds = Math.floor(Math.random() * dateDifference);\r\n\r\n  // Create a random date by adding the random milliseconds to the start date\r\n  const randomDate = new Date(startDate.getTime() + randomMilliseconds);\r\n\r\n  // Format the date to 'YYYY-MM-DD' using Intl.DateTimeFormat\r\n  const formattedDate = new Intl.DateTimeFormat('en-CA').format(randomDate);\r\n\r\n  return formattedDate;\r\n}\r\n\r\n// Function to get user ID by username (with caching in localStorage)\r\nasync function getUserId(username) {\r\n  const userIdsCache = JSON.parse(localStorage.getItem('userIdsCache') || '{}');\r\n\r\n  // If the user ID is cached, return it\r\n  if (userIdsCache[username]) return userIdsCache[username];\r\n\r\n  try {\r\n    // Fetch the user ID\r\n    const userId = await getExactUserIdByName(username);\r\n    if (userId) {\r\n      userIdsCache[username] = userId;\r\n      localStorage.setItem('userIdsCache', JSON.stringify(userIdsCache));\r\n      return userId;\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fetching user ID for ${username}:`, error);\r\n  }\r\n\r\n  return null; // Return null if no user found\r\n}\r\n\r\n// Initialize the visibility state for media and mention messages\r\nlet visibleMessages = { media: false, mention: false };\r\n\r\n// Function to reset the visibleMessages object\r\nconst resetVisibleMessages = () => { visibleMessages = { media: false, mention: false }; };\r\n\r\n// Function to toggle the visibility of message items based on the given selector\r\nasync function toggleMessagesVisibility(selector) {\r\n  // Determine if the selector is 'media' or 'mention' and update visibility states\r\n  const isMedia = selector === 'media';\r\n  const isMention = selector === 'mention';\r\n\r\n  // Update the visibility state: toggle the selected type and reset the other\r\n  visibleMessages = {\r\n    media: isMedia ? !visibleMessages.media : false, // Toggle media visibility\r\n    mention: isMention ? !visibleMessages.mention : false // Toggle mention visibility\r\n  };\r\n\r\n  // Iterate over all message items and apply the corresponding visibility rules\r\n  document.querySelectorAll('.message-item').forEach(item => {\r\n    // Check if the message item contains media or mention content\r\n    const hasMediaClass = item.querySelector('.media');\r\n    const hasMentionClass = item.querySelector('.mention');\r\n\r\n    // Case: Showing only media elements (when 'media' is toggled)\r\n    if (visibleMessages.media) {\r\n      item.style.contentVisibility = hasMediaClass ? 'visible' : 'hidden'; // Show/hide based on media class\r\n      item.style.fontSize = hasMediaClass ? '' : '0'; // Adjust font size based on visibility\r\n    }\r\n    // Case: Showing only mention elements (when 'mention' is toggled)\r\n    else if (visibleMessages.mention) {\r\n      item.style.contentVisibility = hasMentionClass ? 'visible' : 'hidden'; // Show/hide based on mention class\r\n      item.style.fontSize = hasMentionClass ? '' : '0'; // Adjust font size based on visibility\r\n    }\r\n    // Case: Show all messages when neither 'media' nor 'mention' is toggled\r\n    else {\r\n      item.style.contentVisibility = 'visible'; // Ensure the message is visible\r\n      item.style.fontSize = ''; // Reset font size to default\r\n    }\r\n  });\r\n}\r\n\r\n//   Function to display the chat logs panel\r\n// Load initially with default date or date given by personal messages panel with parameter date\r\nasync function showChatLogsPanel(personalMessagesDate) {\r\n  // Check if the panel already exists\r\n  const existingPanel = document.querySelector('.chat-logs-panel');\r\n  if (existingPanel) {\r\n    existingPanel.remove(); // Remove the settings panel\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n    return; // Return immediately to prevent further execution\r\n  }\r\n\r\n  // Remove any previous panel before creating a new one\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.removePreviousPanel)();\r\n\r\n  // Create a container div with class 'chat-logs-panel'\r\n  const chatLogsPanel = document.createElement('div');\r\n  chatLogsPanel.className = 'chat-logs-panel popup-panel';\r\n\r\n  // Create a container div for the panel header\r\n  const panelHeaderContainer = document.createElement('div');\r\n  panelHeaderContainer.className = 'panel-header';\r\n\r\n  // Create a container div with class 'panel-control-buttons'\r\n  const panelControlButtons = document.createElement('div');\r\n  panelControlButtons.className = 'panel-control-buttons';\r\n\r\n  // Create a container div for the search input\r\n  const chatlogsSearchContainer = document.createElement('div');\r\n  chatlogsSearchContainer.className = 'search-for-chatlogs-messages';\r\n\r\n  // Create the input field for searching users\r\n  const chatlogsSearchInput = document.createElement('input');\r\n  chatlogsSearchInput.className = 'chatlogs-search-input';\r\n  chatlogsSearchInput.type = 'text';\r\n\r\n  // Append search input to the search container\r\n  chatlogsSearchContainer.appendChild(chatlogsSearchInput);\r\n  // Append the search container to the panel header container\r\n  panelHeaderContainer.appendChild(chatlogsSearchContainer);\r\n\r\n  // Add input event listener to filter items as the user types\r\n  chatlogsSearchInput.addEventListener('input', () => filterItems(chatlogsSearchInput.value));\r\n\r\n  // Clears the input when the left mouse button (LMB) is clicked while holding the Ctrl key\r\n  // Also updates the filtered items accordingly\r\n  chatlogsSearchInput.addEventListener('click', (event) => {\r\n    if (event.ctrlKey) {\r\n      chatlogsSearchInput.value = '';\r\n      // Call the function to update the filtered items based on the cleared input\r\n      filterItems(chatlogsSearchInput.value);\r\n    }\r\n  });\r\n\r\n  // Add keydown event listener to handle date format and validity check\r\n  chatlogsSearchInput.addEventListener('keydown', async (event) => {\r\n    const inputValue = chatlogsSearchInput.value;\r\n\r\n    if (event.key === 'Enter') {\r\n      let normalizedDate = inputValue;\r\n\r\n      // Handle 8-digit and 6-digit date formats\r\n      if (/^\\d{8}$/.test(inputValue)) {\r\n        normalizedDate = inputValue.length === 6 ? '20' + inputValue : inputValue;\r\n        normalizedDate = normalizedDate.replace(/(\\d{4})(\\d{2})(\\d{2})/, '$1-$2-$3');\r\n      } else if (/^\\d{6}$/.test(inputValue)) {\r\n        normalizedDate = '20' + inputValue.replace(/(\\d{2})(\\d{2})(\\d{2})/, '$1-$2-$3');\r\n      }\r\n\r\n      // Check if the normalized input matches either 'yyyy:mm:dd' or 'yyyy-mm-dd' format\r\n      const isValidFormat = /^\\d{2,4}[:\\-]\\d{2}[:\\-]\\d{2}$/.test(normalizedDate.replace(/:/g, '-'));\r\n\r\n      // Check if the normalized date is a valid date\r\n      const isValidDate = isValidFormat && !isNaN(new Date(normalizedDate.replace(/:/g, '-')).getTime());\r\n\r\n      if (isValidDate) {\r\n        await loadChatLogs(normalizedDate); // Load chat logs for the determined date\r\n        showDateInput(dateInput);\r\n      } else {\r\n        alert('Please enter a valid date.\\n\\nValid formats include:\\n' +\r\n          '1. yyyy-mm-dd\\n' +\r\n          '2. yyyy:mm:dd\\n' +\r\n          '3. yy-mm-dd\\n' +\r\n          '4. yy:mm:dd\\n' +\r\n          '5. yyyymmdd\\n' +\r\n          '6. yymmdd\\n\\n');\r\n      }\r\n\r\n      // Clear the input value after processing the \"Enter\" key\r\n      chatlogsSearchInput.value = '';\r\n    }\r\n  });\r\n\r\n  // Focus on the search input using requestAnimationFrame\r\n  function focusOnSearchField() { requestAnimationFrame(function () { chatlogsSearchInput.focus(); }); } focusOnSearchField();\r\n\r\n  // Create a date input toggle with similar styles as the close button\r\n  const dateInputToggle = document.createElement('div');\r\n  dateInputToggle.className = \"large-button panel-header-date-button\";\r\n  dateInputToggle.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.calendarSVG;\r\n\r\n  // Function to toggle visibility of an element\r\n  function toggleDateInputVisibility(element) {\r\n    element.style.display = element.style.display === 'none' ? 'flex' : 'none';\r\n  }\r\n\r\n  // Function to show the date input if it is currently hidden\r\n  function showDateInput(element) {\r\n    if (element.style.display === 'none') element.style.display = 'flex';\r\n  }\r\n\r\n  // Toggle the visibility of the date input when the toggle is clicked\r\n  dateInputToggle.addEventListener('click', () => {\r\n    toggleDateInputVisibility(dateInput);\r\n  });\r\n\r\n  // Create the date input field\r\n  const dateInput = document.createElement('input');\r\n  dateInput.type = 'date';\r\n  dateInput.className = 'chatlogs-date-input';\r\n  dateInput.style.display = \"none\";\r\n\r\n  // Append the date button and input field to the control buttons container\r\n  panelControlButtons.appendChild(dateInputToggle);\r\n  panelControlButtons.appendChild(dateInput);\r\n\r\n  // Create a toggle mention messages component\r\n  const toggleMentionMessages = document.createElement('div');\r\n  toggleMentionMessages.className = \"large-button toggle-mention-messages-button\";\r\n  // Set the inner HTML of the toggle component with a suitable SVG or text\r\n  toggleMentionMessages.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.personalMessagesSVG;\r\n  toggleMentionMessages.title = 'Toggle Mention Messages';\r\n\r\n  // Add a click event listener to toggle the visibility of messages without mentions\r\n  toggleMentionMessages.addEventListener('click', async () => {\r\n    await toggleMessagesVisibility('mention');\r\n  });\r\n\r\n  // Create a new div element for the toggle mention messages counter\r\n  const toggleMentionMessagesCounter = document.createElement('div');\r\n  // Assign a class name to the element\r\n  toggleMentionMessagesCounter.className = 'toggle-mention-messages-counter';\r\n  toggleMentionMessagesCounter.textContent = '0'; // Set as default value before assign\r\n\r\n  // Append the counter inside the toggleMentionMessages component\r\n  toggleMentionMessages.appendChild(toggleMentionMessagesCounter);\r\n  // Append the toggle mention messages component to the control panel\r\n  panelControlButtons.appendChild(toggleMentionMessages);\r\n\r\n  // Create a toggle media messages component\r\n  const toggleMediaMessages = document.createElement('div');\r\n  toggleMediaMessages.className = \"large-button panel-header-toggle-media-messages\";\r\n  // Set the inner HTML of the toggle component with a suitable SVG or text\r\n  toggleMediaMessages.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.mediaMessagesSVG;\r\n  toggleMediaMessages.title = 'Toggle Media Messages';\r\n  // Apply common styles to the component\r\n  // applyHeaderButtonStyles(toggleMediaMessages, 'darkslategray');\r\n\r\n  // Add a click event listener to toggle the visibility of media messages\r\n  toggleMediaMessages.addEventListener('click', async () => {\r\n    await toggleMessagesVisibility('media');\r\n  });\r\n\r\n  // Create a new div element for the toggle media messages counter\r\n  const toggleMediaMessagesCounter = document.createElement('div');\r\n  // Assign a class name to the element\r\n  toggleMediaMessagesCounter.className = 'toggle-media-messages-counter';\r\n  toggleMediaMessagesCounter.textContent = '0'; // Set as default value before assign\r\n\r\n  // Append the counter inside the toggleMediaMessages component\r\n  toggleMediaMessages.appendChild(toggleMediaMessagesCounter);\r\n\r\n  // Append the toggle media messages component to the control panel\r\n  panelControlButtons.appendChild(toggleMediaMessages);\r\n\r\n  // Function to update the media and mention counters\r\n  function updateMediaAndMentionCounters() {\r\n    // Update the media counter\r\n    toggleMediaMessagesCounter.textContent = document.querySelectorAll('.chat-logs-container .media').length;\r\n    // Update the mention counter\r\n    toggleMentionMessagesCounter.textContent = document.querySelectorAll('.chat-logs-container .mention').length;\r\n  }\r\n\r\n  // Create a copy chatlogs button element\r\n  const copyChatLogsUrl = document.createElement('div');\r\n  copyChatLogsUrl.className = \"large-button panel-header-copy-button\";\r\n  // Set the inner HTML of the copy chat logs element with the clipboard SVG\r\n  copyChatLogsUrl.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.clipboardSVG;\r\n  copyChatLogsUrl.title = 'Copy Chat Logs Url';\r\n  // Apply common styles to the button element\r\n  // applyHeaderButtonStyles(copyChatLogsUrl, 'steelblue');\r\n\r\n  // Helper function to extract date from the URL\r\n  const extractDateFromUrl = (url) => {\r\n    const chatlogsDateRegex = /(\\d{4}-\\d{2}-\\d{2})/;\r\n    const match = url.match(chatlogsDateRegex);\r\n    return match ? match[1] : null; // Return the date if match is found, else return null\r\n  };\r\n\r\n  // Function to create and populate chat log links\r\n  function createChatLogLinks(savedChatlogs, chatLogsLinksContainer) {\r\n    // Check if the container exists and return if not\r\n    if (!chatLogsLinksContainer) return;\r\n    // Clear the container before repopulating it\r\n    chatLogsLinksContainer.replaceChildren();\r\n\r\n    savedChatlogs.forEach(({ url, title }) => {\r\n      const date = extractDateFromUrl(url); // Extract date from URL\r\n\r\n      // Create the wrapper container for each link\r\n      const logWrapper = document.createElement('div');\r\n      logWrapper.classList.add('saved-chatlog-url-wrapper');\r\n\r\n      // Create the log link element\r\n      const logLink = document.createElement('a');\r\n      logLink.classList.add('saved-chatlog-url');\r\n      logLink.textContent = date; // Display the date\r\n      logLink.href = url; // Store the URL in the href attribute\r\n\r\n      logLink.addEventListener('click', async (event) => {\r\n        event.preventDefault(); // Prevent the default link behavior\r\n\r\n        if (event.ctrlKey) {\r\n          const urlToRemove = event.target.href;\r\n          // Find the exact match in the savedChatlogs array and remove it\r\n          const updatedChatlogs = savedChatlogs.filter(log => log.url !== urlToRemove);\r\n\r\n          // If there was a change, update localStorage and remove the link\r\n          if (updatedChatlogs.length !== savedChatlogs.length) {\r\n            savedChatlogs = updatedChatlogs;\r\n            localStorage.setItem('savedChatlogs', JSON.stringify(savedChatlogs));\r\n            const targetLink = event.target;\r\n            targetLink.closest('.saved-chatlog-url-wrapper').remove(); // Remove the wrapper\r\n          }\r\n        } else {\r\n          // Handle when Ctrl is not pressed\r\n          await loadChatLogs(date);\r\n        }\r\n      });\r\n\r\n      // Create the title element\r\n      const logTitle = document.createElement('span');\r\n      logTitle.classList.add('saved-chatlog-url-title');\r\n      logTitle.textContent = title || ''; // Display the title (or an empty string if none provided)\r\n\r\n      // Add click event listener to the title\r\n      logTitle.addEventListener('click', () => {\r\n        const newTitle = prompt('Enter a new title for this chat log:', logTitle.textContent);\r\n\r\n        if (newTitle !== null && newTitle !== logTitle.textContent) {\r\n          // Update the title displayed on the page\r\n          logTitle.textContent = newTitle;\r\n\r\n          // Find the log by URL in the savedChatlogs array and update its title\r\n          const logIndex = savedChatlogs.findIndex(log => log.url === url);\r\n          if (logIndex !== -1) {\r\n            savedChatlogs[logIndex].title = newTitle; // Update the title in the saved object\r\n            localStorage.setItem('savedChatlogs', JSON.stringify(savedChatlogs)); // Save the updated list to localStorage\r\n          }\r\n        }\r\n      });\r\n\r\n      // Append the elements to the wrapper\r\n      logWrapper.appendChild(logLink);\r\n      logWrapper.appendChild(logTitle);\r\n\r\n      // Append the wrapper to the container\r\n      chatLogsLinksContainer.appendChild(logWrapper);\r\n    });\r\n  }\r\n\r\n  // Add a click event listener to copy chatLogsUrlForCopy to the clipboard\r\n  copyChatLogsUrl.addEventListener('click', (event) => {\r\n    let chatLogsLinksContainer = document.querySelector('.saved-chatlog-container');\r\n\r\n    !chatLogsLinksContainer && !event.shiftKey && addJumpEffect(copyChatLogsUrl, 0, 0);\r\n\r\n    if (chatLogsLinksContainer && !event.ctrlKey && !chatLogsLinksContainer.contains(event.target)) {\r\n      chatLogsLinksContainer.remove();\r\n    }\r\n\r\n    let savedChatlogs = JSON.parse(localStorage.getItem('savedChatlogs')) || [];\r\n\r\n    if (event.ctrlKey && !event.target.closest('.saved-chatlog-url')) {\r\n      const currentUrlDate = extractDateFromUrl(chatLogsUrlForCopy);\r\n      if (!currentUrlDate) return;\r\n\r\n      // Ask for title input\r\n      const title = prompt('Enter a title for this chat log:', '');\r\n\r\n      // Check if the URL with the same date already exists\r\n      const urlExists = savedChatlogs.some(log => extractDateFromUrl(log.url) === currentUrlDate);\r\n\r\n      if (!urlExists) {\r\n        // Add the new URL and title if no match was found for the date\r\n        savedChatlogs.push({ url: chatLogsUrlForCopy, title: title || '' });\r\n\r\n        // Sort the saved URLs based on the date extracted from the URL\r\n        savedChatlogs.sort((a, b) => {\r\n          const dateA = extractDateFromUrl(a.url);\r\n          const dateB = extractDateFromUrl(b.url);\r\n          return new Date(dateA) - new Date(dateB);\r\n        });\r\n\r\n        // Store the updated list back in localStorage\r\n        localStorage.setItem('savedChatlogs', JSON.stringify(savedChatlogs));\r\n      }\r\n      createChatLogLinks(savedChatlogs, chatLogsLinksContainer);\r\n    } else if (event.shiftKey) {\r\n      if (savedChatlogs.length > 0 && !chatLogsLinksContainer) {\r\n        chatLogsLinksContainer = document.createElement('div');\r\n        chatLogsLinksContainer.classList.add('saved-chatlog-container');\r\n        createChatLogLinks(savedChatlogs, chatLogsLinksContainer);\r\n\r\n        copyChatLogsUrl.appendChild(chatLogsLinksContainer);\r\n      }\r\n    } else {\r\n      navigator.clipboard.writeText(chatLogsUrlForCopy)\r\n        .catch(err => console.error('Failed to copy: ', err));\r\n    }\r\n  });\r\n\r\n  panelControlButtons.appendChild(copyChatLogsUrl);\r\n\r\n  // Retrieve `shouldShowActiveUsers` from localStorage or set it to 'shown' if it doesn't exist\r\n  const shouldShowActiveUsers = localStorage.getItem('shouldShowActiveUsers') || (localStorage.setItem('shouldShowActiveUsers', 'shown'), 'shown');\r\n\r\n  // Create a toggle active users button\r\n  const toggleActiveUsers = document.createElement('div');\r\n  toggleActiveUsers.className = \"large-button panel-header-toggle-button\";\r\n  updateActiveUsersToggle(shouldShowActiveUsers); // Set initial SVG based on stored state\r\n\r\n  // Set initial title based on stored state\r\n  toggleActiveUsers.title = shouldShowActiveUsers === 'shown' ? 'Hide User List' : 'Show User List';\r\n\r\n  // Function to update the toggle button's SVG and title based on current state\r\n  function updateActiveUsersToggle(state) {\r\n    toggleActiveUsers.innerHTML = state === 'shown' ? _icons__WEBPACK_IMPORTED_MODULE_2__.toggleLeftSVG : _icons__WEBPACK_IMPORTED_MODULE_2__.toggleRightSVG; // Toggle between SVGs\r\n    toggleActiveUsers.title = state === 'shown' ? 'Hide User List' : 'Show User List'; // Update title based on state\r\n  }\r\n\r\n  // Function to toggle active users and update localStorage, SVG, and title\r\n  function toggleActiveUsersState() {\r\n    const newState = localStorage.getItem('shouldShowActiveUsers') === 'shown' ? 'hidden' : 'shown'; // Determine new state\r\n    localStorage.setItem('shouldShowActiveUsers', newState); // Update localStorage\r\n    updateActiveUsersToggle(newState); // Update the displayed SVG and title\r\n\r\n    if (newState === 'shown') {\r\n      // Call renderActiveUsers to update the display of active users based on their message counts\r\n      renderActiveUsers(usernameMessageCountMap, chatLogsPanel);\r\n    } else {\r\n      // Remove the active users container if the state is hidden\r\n      const activeUsersContainer = chatLogsPanel.querySelector('.active-users');\r\n      if (activeUsersContainer) {\r\n        chatLogsPanel.removeChild(activeUsersContainer);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add click event to toggle active users\r\n  toggleActiveUsers.addEventListener('click', toggleActiveUsersState);\r\n\r\n  // Append the toggle active users to the panel control buttons\r\n  panelControlButtons.appendChild(toggleActiveUsers);\r\n\r\n  // Create and style the chevron left button\r\n  const oneDayBackward = document.createElement('div');\r\n  oneDayBackward.className = \"large-button panel-header-one-day-back-button\";\r\n  oneDayBackward.title = 'Previous Day';\r\n  oneDayBackward.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.chevronLeftSVG; // Assuming you have chevronLeftSVG defined\r\n  // applyHeaderButtonStyles(oneDayBackward, 'darkcyan');\r\n\r\n  // Create and style the chevron right button\r\n  const oneDayForward = document.createElement('div');\r\n  oneDayForward.className = \"large-button panel-header-one-day-forward-button\";\r\n  oneDayForward.title = 'Next Day';\r\n  oneDayForward.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.chevronRightSVG; // Assuming you have chevronRightSVG defined\r\n  // applyHeaderButtonStyles(oneDayForward, 'darkcyan');\r\n\r\n  // Create and style the shuffle button\r\n  const randomDay = document.createElement('div');\r\n  randomDay.className = \"large-button panel-header-shuffle-button\";\r\n  randomDay.title = 'Random Date';\r\n  randomDay.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.shuffleSVG; // Assuming you have shuffleSVG defined\r\n  // applyHeaderButtonStyles(randomDay, 'darkslateblue');\r\n\r\n  // Function to get current date or fallback to today's date\r\n  function getEffectiveDate() {\r\n    return dateInput.value ? new Date(dateInput.value) : new Date(); // Use dateInput value or today's date\r\n  }\r\n\r\n  // Function to update the date input and title\r\n  const updateDateInputAndTitle = (newDate) => {\r\n    dateInput.value = newDate; // Update the date input\r\n    dateInputToggle.title = `Current date: ${newDate}`; // Update title\r\n  };\r\n\r\n  // Event listener for the chevron left button\r\n  oneDayBackward.addEventListener('click', async () => {\r\n    const currentDate = getEffectiveDate(); // Get the effective date\r\n    currentDate.setDate(currentDate.getDate() - 1); // Go one day back\r\n    await loadChatLogs(currentDate); // Load chat logs for the updated date\r\n    showDateInput(dateInput);\r\n    focusOnSearchField();\r\n    resetVisibleMessages();\r\n  });\r\n\r\n  // Event listener for the chevron right button\r\n  oneDayForward.addEventListener('click', async () => {\r\n    const currentDate = getEffectiveDate(); // Get the effective date\r\n    currentDate.setDate(currentDate.getDate() + 1); // Go one day forward\r\n    await loadChatLogs(currentDate); // Load chat logs for the updated date\r\n    showDateInput(dateInput);\r\n    focusOnSearchField();\r\n    resetVisibleMessages();\r\n  });\r\n\r\n  // Event listener for the shuffle button\r\n  randomDay.addEventListener('click', async () => {\r\n    const randomDate = getRandomDateInRange(); // Get a random date\r\n    await loadChatLogs(randomDate); // Load chat logs for the random date\r\n    showDateInput(dateInput);\r\n    focusOnSearchField();\r\n    resetVisibleMessages();\r\n  });\r\n\r\n  // Append buttons to the control buttons container\r\n  panelControlButtons.appendChild(oneDayBackward);\r\n  panelControlButtons.appendChild(oneDayForward);\r\n  panelControlButtons.appendChild(randomDay);\r\n\r\n  // Create a close button with the provided SVG icon\r\n  const closePanelButton = document.createElement('div');\r\n  closePanelButton.className = \"large-button panel-header-close-button\";\r\n  closePanelButton.title = 'Close panel';\r\n  closePanelButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.closeSVG;\r\n\r\n  // Add a click event listener to the close panel button\r\n  closePanelButton.addEventListener('click', () => {\r\n    // Fade out the chat logs panel when the close button is clicked\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(chatLogsPanel, 'hide');\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n  });\r\n\r\n  // Append close button to control buttons, and control buttons to header\r\n  panelControlButtons.appendChild(closePanelButton);\r\n  panelHeaderContainer.appendChild(panelControlButtons);\r\n\r\n  // Create a container for the chat logs\r\n  const chatLogsContainer = document.createElement('div');\r\n  chatLogsContainer.className = 'chat-logs-container';\r\n\r\n  // Append the header and chat logs container to the chat logs panel\r\n  chatLogsPanel.appendChild(panelHeaderContainer);\r\n  chatLogsPanel.appendChild(chatLogsContainer);\r\n\r\n  // Create and append scroll buttons\r\n  const { scrollButtonsContainer } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.createScrollButtons)(chatLogsContainer);\r\n  chatLogsPanel.appendChild(scrollButtonsContainer);\r\n\r\n  // Append the chat logs panel to the body\r\n  document.body.appendChild(chatLogsPanel);\r\n\r\n  // Fade in the chat logs panel and dimming background\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(chatLogsPanel, 'show');\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('show');\r\n\r\n  // Define an object to store the hue for each username\r\n  const usernameHueMap = {};\r\n  const hueStep = 15;\r\n  let lastDisplayedUsername = null; // Variable to track the last displayed username\r\n  // Initialize a map to track message counts for unique usernames\r\n  const usernameMessageCountMap = new Map();\r\n  // Store the current chat logs URL for clipboard copy.\r\n  let chatLogsUrlForCopy = ''; // Store the current chat logs URL for copying\r\n\r\n  // Function to load the total message count into the placeholder without replacing the existing text\r\n  function loadTotalMessageCount() {\r\n    if (chatLogsContainer.childElementCount > 0) {\r\n      chatlogsSearchInput.placeholder += ` | Total messages: ${chatLogsContainer.childElementCount}`;\r\n    }\r\n  }\r\n\r\n  // Function to load and display chat logs into the container\r\n  const loadChatLogs = async (date) => {\r\n    // Normalize date input to 'yyyy-mm-dd' format, supporting 'yyyy:mm:dd' format as well\r\n    const normalizeDate = date => /^\\d{4}:\\d{2}:\\d{2}$/.test(date) ? date.replace(/:/g, '-') : date;\r\n    // Normalize and format the date\r\n    const formattedDate = new Intl.DateTimeFormat('en-CA').format(new Date(normalizeDate(date)));\r\n\r\n    // Check if the provided date is out of bounds (less than minDate or greater than today)\r\n    if (formattedDate < minDate || formattedDate > _definitions_js__WEBPACK_IMPORTED_MODULE_4__.today) {\r\n      alert(formattedDate < minDate ? `The selected date cannot be earlier than ${minDate}.` : \"You cannot load a future date.\");\r\n      return; // Exit the function if the date is invalid\r\n    }\r\n\r\n    // Call the updateDateInputAndTitle function with the formattedDate\r\n    updateDateInputAndTitle(formattedDate);\r\n\r\n    // Fetch chat logs and pass the chatLogsContainer as the parent container\r\n    const { chatlogs, url, size, info, error } = await fetchChatLogs(formattedDate, chatLogsContainer);\r\n\r\n    // Convert size to KB\r\n    const sizeInKB = (size / 1024).toFixed(2);\r\n\r\n    // Set placeholder for size in KB, info, or error\r\n    chatlogsSearchInput.placeholder = error ? `Error: ${error}` : (info ? `Limit reached: ${sizeInKB} KB` : info || `Size: ${sizeInKB} KB`);\r\n\r\n    // Assign the fetched URL to the chatLogsUrlForCopy variable\r\n    chatLogsUrlForCopy = url;\r\n\r\n    // Clear previous counts\r\n    usernameMessageCountMap.clear();\r\n\r\n    chatlogs.forEach(async ({ time, username, message }) => {\r\n      // Update message count for each unique username\r\n      usernameMessageCountMap.set(username, (usernameMessageCountMap.get(username) || 0) + 1);\r\n\r\n      // Create a container for each message\r\n      const messageContainer = document.createElement('div');\r\n      messageContainer.classList.add('message-item');\r\n\r\n      // Attach click event to scroll the chat logs container to the middle of the parent container on LMB click\r\n      messageContainer.addEventListener('click', async (event) => {\r\n        // If the clicked element or one of its parents is an anchor, exit early.\r\n        if (event.target.closest('a')) return;\r\n        // Call toggleMessagesVisibility to show all messages and scroll when a message is clicked on visibleMentionMessages is true\r\n        if (visibleMessages) await toggleMessagesVisibility();\r\n        chatlogsSearchInput.value.length > 0 && (chatlogsSearchInput.value = '');\r\n        // Use helper function to scroll the chat logs container to the middle of the parent container\r\n        await scrollMessagesToMiddle(chatLogsContainer, messageContainer);\r\n      });\r\n\r\n      // Create time element\r\n      const timeElement = document.createElement('span');\r\n      timeElement.className = 'message-time';\r\n      // Update the timeElement's text content with the adjusted time\r\n      timeElement.textContent = time;\r\n\r\n      // Open the chat log URL on click\r\n      timeElement.addEventListener('click', function () {\r\n        const url = `https://klavogonki.ru/chatlogs/${date}.html#${time}`;\r\n        window.open(url, '_blank', 'noopener,noreferrer');\r\n      });\r\n\r\n      // Create username element\r\n      const usernameElement = document.createElement('span');\r\n      usernameElement.className = 'message-username';\r\n      usernameElement.textContent = username; // Use the original username for display\r\n\r\n      // Add click event to navigate to the user's profile or shake the username if userId is not found\r\n      usernameElement.addEventListener('click', async () => {\r\n        const userId = await getUserId(username); // Fetch the user ID on click\r\n\r\n        if (userId) {\r\n          const url = `https://klavogonki.ru/u/#/${userId}/`;\r\n          window.open(url, '_blank', 'noopener,noreferrer');\r\n        } else {\r\n          // Add shake effect if userId doesn't exist\r\n          addShakeEffect(usernameElement); // Define this function for the shake effect\r\n        }\r\n      });\r\n\r\n      // Check if the hue for this username is already stored\r\n      let hueForUsername = usernameHueMap[username]; // Use the original username as the key\r\n\r\n      // If the hue is not stored, generate a new random hue with the specified step\r\n      if (!hueForUsername) {\r\n        hueForUsername = Math.floor(Math.random() * (210 / hueStep)) * hueStep; // Limit hue to a maximum of 210\r\n        // Store the generated hue for this username\r\n        usernameHueMap[username] = hueForUsername; // Store hue using the original username as the key\r\n      }\r\n\r\n      // Apply the hue color to the username element\r\n      usernameElement.style.color = `hsl(${hueForUsername}, 80%, 50%)`;\r\n\r\n      // Create message text element\r\n      const messageTextElement = document.createElement('span');\r\n      messageTextElement.className = 'message-text';\r\n\r\n      // Replace smiley codes with <img> tags, and then wrap links with <a> tags\r\n      messageTextElement.innerHTML = message\r\n        // Replace smiley codes like :word: with <img> tags\r\n        .replace(/:(?=\\w*[a-zA-Z])(\\w+):/g,\r\n          (_, word) => `<img src=\"/img/smilies/${word}.gif\" alt=\":${word}:\" title=\":${word}:\" class=\"smile\">`\r\n        )\r\n        // Wrap http and https links with <a> tags\r\n        .replace(/(https?:\\/\\/[^\\s]+)/gi,\r\n          (url) => `<a href=\"${url}\" target=\"_blank\" rel=\"noopener noreferrer\">${url}</a>`\r\n        );\r\n\r\n      // Apply margin for the first message of a new user\r\n      messageContainer.style.marginTop = lastDisplayedUsername !== username ? '0.6em' : '';\r\n\r\n      // Update the last displayed username\r\n      lastDisplayedUsername = username;\r\n\r\n      // Append elements to the message container\r\n      messageContainer.appendChild(timeElement);\r\n      messageContainer.appendChild(usernameElement);\r\n      messageContainer.appendChild(messageTextElement);\r\n\r\n      // Append the message container to the chat logs container\r\n      chatLogsContainer.appendChild(messageContainer);\r\n    });\r\n\r\n    // Call renderActiveUsers to update the display of active users based on their message counts\r\n    renderActiveUsers(usernameMessageCountMap, chatLogsPanel, chatlogsSearchInput);\r\n\r\n    requestAnimationFrame(() => {\r\n      (0,_image_converter_js__WEBPACK_IMPORTED_MODULE_0__.convertImageLinksToImage)('chatlogsMessages');\r\n      (0,_video_converter_js__WEBPACK_IMPORTED_MODULE_1__.convertVideoLinksToPlayer)('chatlogsMessages');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processEncodedLinks)('chatlogsMessages'); // Decodes links within the chat logs section.\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.highlightMentionWords)('chatlogsMessages');\r\n      chatLogsContainer.scrollTop = chatLogsContainer.scrollHeight; // Scroll to the very bottom\r\n\r\n      // Update the media and mention counters\r\n      updateMediaAndMentionCounters();\r\n      // Call the function to load the total message count once\r\n      loadTotalMessageCount();\r\n      // Call the filter function with the updated input value\r\n      chatlogsSearchInput.value.length > 0 && filterItems(chatlogsSearchInput.value);\r\n    });\r\n\r\n  };\r\n\r\n  // Renders the active users based on their message counts from the provided map\r\n  function renderActiveUsers(usernameMessageCountMap, parentContainer, searchField) {\r\n    // Check if active users should be shown\r\n    if (localStorage.getItem('shouldShowActiveUsers') === 'shown') {\r\n      // Check if the activeUsers container already exists\r\n      let activeUsers = parentContainer.querySelector('.active-users');\r\n\r\n      // If it doesn't exist, create it\r\n      if (!activeUsers) {\r\n        activeUsers = document.createElement('div');\r\n        activeUsers.className = 'active-users';\r\n\r\n        // Append the newly created activeUsers container to the parent container\r\n        parentContainer.appendChild(activeUsers);\r\n      }\r\n\r\n      // Sort usernames by message count in descending order\r\n      const sortedUsernames = Array.from(usernameMessageCountMap.entries())\r\n        .sort(([, countA], [, countB]) => countB - countA); // Sort in descending order\r\n\r\n      // Clear previous user list in the activeUsers container\r\n      activeUsers.innerHTML = ''; // Clear previous user list\r\n\r\n      // Append sorted users to the activeUsers container\r\n      sortedUsernames.forEach(([username, count]) => {\r\n        // Create a user element\r\n        const userElement = document.createElement('div');\r\n        userElement.className = 'active-user-item';\r\n\r\n        // Add click event to populate the search input with the clicked username\r\n        userElement.addEventListener('click', () => {\r\n          const currentValue = chatlogsSearchInput.value.trim();\r\n          const usernameEntry = isCtrlKeyPressed ? `, ${username}` : username;\r\n\r\n          // Toggle input value: clear if same username clicked, otherwise add or replace\r\n          chatlogsSearchInput.value = (currentValue === username)\r\n            ? ''\r\n            : (isCtrlKeyPressed && !currentValue.includes(username))\r\n              ? currentValue + usernameEntry\r\n              : username;\r\n\r\n          // Call the filter function with the updated input value\r\n          filterItems(chatlogsSearchInput.value);\r\n        });\r\n\r\n        // Create nickname element\r\n        const nicknameElement = document.createElement('span');\r\n        nicknameElement.className = 'active-user-name';\r\n        nicknameElement.textContent = username;\r\n\r\n        // Fetch the color for the username from the hue map\r\n        const userHue = usernameHueMap[username] || 0; // Fallback to 0 if hue not found\r\n        nicknameElement.style.color = `hsl(${userHue}, 80%, 50%)`; // Apply the hue color\r\n\r\n        // Create message count element\r\n        const messageCountElement = document.createElement('span');\r\n        messageCountElement.className = 'active-user-messages-count';\r\n        messageCountElement.textContent = count;\r\n        messageCountElement.style.color = `hsl(${userHue}, 80%, 50%)`; // Apply the hue color\r\n        messageCountElement.style.backgroundColor = `hsla(${userHue}, 80%, 50%, 0.2)`;\r\n\r\n        // Append elements to user element\r\n        userElement.appendChild(messageCountElement);\r\n        userElement.appendChild(nicknameElement);\r\n\r\n        // Append user element to activeUsers container\r\n        activeUsers.appendChild(userElement);\r\n      });\r\n    }\r\n  }\r\n\r\n  // Load chat logs based on the provided date or default to today's date\r\n  const dateToLoad = personalMessagesDate || _definitions_js__WEBPACK_IMPORTED_MODULE_4__.today; // Use personalMessagesDate if available\r\n  await loadChatLogs(dateToLoad); // Load chat logs for the determined date\r\n  // Check if personalMessagesDate is given as parameter or null to show the date input field\r\n  if (personalMessagesDate) showDateInput(dateInput); // Show the date input field\r\n\r\n  // Set the max attribute to today's date\r\n  dateInput.max = _definitions_js__WEBPACK_IMPORTED_MODULE_4__.today; // Set the maximum value to today's date\r\n  // Set the min attribute to '2012-02-12'\r\n  dateInput.min = minDate; // Assign the minimum date\r\n  dateInput.value = dateToLoad; // Set the value to the date to load\r\n  dateInputToggle.title = `Current date: ${dateToLoad}`; // Update the title with the selected date\r\n\r\n  // Add an event listener for the date input change\r\n  dateInput.addEventListener('change', async (event) => {\r\n    const selectedDate = event.target.value; // Get the selected date\r\n    await loadChatLogs(selectedDate); // Load chat logs for the selected date\r\n    dateInputToggle.title = `Current date: ${selectedDate}`; // Update the title with the selected date\r\n  });\r\n\r\n  // Retrieves details from message items including usernames and message text.\r\n  function getMessageDetails(messageItems) {\r\n    // Cache message details including text, username, and message content\r\n    return messageItems.map(item => {\r\n      const usernameElement = item.querySelector('.message-username');\r\n      const username = usernameElement ? usernameElement.textContent.toLowerCase().trim() : ''; // Get username text, if available\r\n      const messageTextElement = item.querySelector('.message-text');\r\n      const messageText = messageTextElement ? messageTextElement.textContent.toLowerCase().trim() : ''; // Get message text, if available\r\n      return { username, messageText };\r\n    });\r\n  }\r\n\r\n  // Filters message items based on the provided query and displays matching messages.\r\n  function filterItems(query) {\r\n    // If the query contains only digits, hyphens, or colons, do nothing\r\n    if (/^[\\d-:]+$/.test(query.trim())) return;\r\n\r\n    // Helper function to replace underscores and hyphens with spaces and convert to lowercase\r\n    function normalizeText(text) {\r\n      return text.replace(/[_-]/g, ' ').toLowerCase(); // Replaces _ and - with spaces\r\n    }\r\n\r\n    // Normalize query by removing underscores and hyphens, then trimming spaces\r\n    const queryWithoutSymbols = normalizeText(query).trim();\r\n\r\n    // Retrieve message items within the filterItems function\r\n    const messageItems = Array.from(document.querySelectorAll('.chat-logs-container > .message-item'));\r\n\r\n    const messageDetails = getMessageDetails(messageItems); // Get the message details\r\n    const isEmptyQuery = !queryWithoutSymbols;\r\n\r\n    // Split query by commas and trim parts\r\n    const queryParts = queryWithoutSymbols.split(',').map(part => part.trim()).filter(Boolean);\r\n\r\n    // Count matching usernames\r\n    const matchingUsernamesCount = queryParts.filter(part =>\r\n      messageDetails.some(detail => normalizeText(detail.username) === part)\r\n    ).length;\r\n\r\n    // Determine if User Mode is active (2 or more matching usernames)\r\n    const isUserMode = matchingUsernamesCount >= 2;\r\n\r\n    // Filter message items based on the query\r\n    messageItems.forEach((item, index) => {\r\n      const messageContainer = item.closest('.message-item'); // Get the closest message item container\r\n      const messageDetailsItem = messageDetails[index];\r\n\r\n      let shouldDisplay = false;\r\n\r\n      // Normalize underscores and hyphens in the username and message text\r\n      const normalizedUsername = normalizeText(messageDetailsItem.username);\r\n      const normalizedMessageText = normalizeText(messageDetailsItem.messageText);\r\n\r\n      if (isEmptyQuery) {\r\n        // Display all messages if the query is empty\r\n        shouldDisplay = true;\r\n      } else if (isUserMode) {\r\n        // User Mode: Match only by username\r\n        shouldDisplay = queryParts.some(part => normalizedUsername === part);\r\n      } else {\r\n        // Simple Mode: Treat the entire query (including commas) as part of the text search\r\n        shouldDisplay = normalizedUsername.includes(queryWithoutSymbols) ||\r\n          normalizedMessageText.includes(queryWithoutSymbols);\r\n      }\r\n\r\n      // Toggle visibility based on shouldDisplay using content visibility and font size\r\n      messageContainer.style.contentVisibility = shouldDisplay ? 'visible' : 'hidden';\r\n      // Set font size to 0 for hidden messages to maintain layout or remove the font size property\r\n      messageContainer.style.fontSize = shouldDisplay ? '' : '0';\r\n    });\r\n  }\r\n\r\n  // Define the event handler function for chat logs panel\r\n  panelsEvents.handleChatLogsKeydown = (event) => { // Assign the function to the object\r\n    if (event.key === 'Escape') {\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(chatLogsPanel, 'hide');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n      document.removeEventListener('keydown', panelsEvents.handleChatLogsKeydown); // Remove the event listener\r\n    }\r\n  };\r\n\r\n  // Attach the event listener\r\n  document.addEventListener('keydown', panelsEvents.handleChatLogsKeydown);\r\n}\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/chatlogs.js?");

/***/ }),

/***/ "./src/modules/definitions.js":
/*!************************************!*\
  !*** ./src/modules/definitions.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheRefreshThresholdHours: () => (/* binding */ cacheRefreshThresholdHours),\n/* harmony export */   debounceTimeout: () => (/* binding */ debounceTimeout),\n/* harmony export */   dynamicChatNotificationTimeout: () => (/* binding */ dynamicChatNotificationTimeout),\n/* harmony export */   emojiFaces: () => (/* binding */ emojiFaces),\n/* harmony export */   ignored: () => (/* binding */ ignored),\n/* harmony export */   mentionKeywords: () => (/* binding */ mentionKeywords),\n/* harmony export */   moderator: () => (/* binding */ moderator),\n/* harmony export */   myNickname: () => (/* binding */ myNickname),\n/* harmony export */   myUserId: () => (/* binding */ myUserId),\n/* harmony export */   profileBaseUrl: () => (/* binding */ profileBaseUrl),\n/* harmony export */   state: () => (/* binding */ state),\n/* harmony export */   today: () => (/* binding */ today),\n/* harmony export */   toggle: () => (/* binding */ toggle),\n/* harmony export */   trustedDomains: () => (/* binding */ trustedDomains),\n/* harmony export */   usernameReplacements: () => (/* binding */ usernameReplacements),\n/* harmony export */   usersToTrack: () => (/* binding */ usersToTrack)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/modules/helpers.js\");\n// helpers\r\n\r\n\r\nconst debounceTimeout = 300;\r\n\r\n// Define the base URL for user profiles\r\nconst profileBaseUrl = 'https://klavogonki.ru/u/#/';\r\n// Actual nickname to use it as an exclusion for the message beep and voice notifications\r\nconst myNickname = document.querySelector('.userpanel .user-block .user-dropdown .name span').textContent;\r\n// Extract the user ID from the href attribute of the mail link for chat, direct profile, or messaging navigation\r\nconst myUserId = document.querySelector('a.drop-btn.mail')?.href?.match(/\\/u\\/#\\/(\\d+)\\/messages\\//)?.[1];\r\n// create today's date in the format 'YYYY-MM-DD'\r\nconst today = new Intl.DateTimeFormat('en-CA').format(new Date());\r\n\r\n// Define the users to track and notify with popup and audio\r\nlet usersToTrack = [\r\n  { name: '', gender: 'Male', pronunciation: '', state: 'thawed' }\r\n];\r\n\r\n// Notify if someone addresses me using these aliases (case-insensitive)\r\nlet mentionKeywords = [];\r\n\r\n// Define username replacements for pronunciation\r\nlet usernameReplacements = [];\r\n\r\n// Define a list of moderator whose new user nicknames in the chat list should have a shield icon.\r\nlet moderator = [];\r\n\r\n// Define user list of users whose messages should be hidden\r\nlet ignored = [];\r\n\r\n// Define empty array for the toggle settings\r\nlet toggle = [];\r\n\r\nconst emojiFaces = [\r\n  // People Emojis (Facial expressions)\r\n  '', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '',\r\n  '', '', '', '', '',\r\n\r\n  // Cat Emojis (Expressive faces of cats)\r\n  '', '', '', '', '', '', '', '', '', '',\r\n\r\n  // Other Animal Emojis (Various animals' faces)\r\n  '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '',\r\n  '', '', '', '', ''\r\n];\r\n\r\nconst state = {\r\n  // Variable to store the last selected emoji\r\n  lastEmojiAvatar: null,\r\n  // Tracks the last focused textarea within the iframe to manage input interactions\r\n  lastFocusedIframeTextarea: null,\r\n  // Object to store event handlers for big image\r\n  bigImageEvents: {},\r\n  // Define an object to store event handlers\r\n  panelsEvents: {},\r\n  fetchedUsers: JSON.parse(localStorage.getItem('fetchedUsers')) || {}\r\n}\r\n\r\n// Timeout before the dynamicChatNotification should be removed\r\nconst dynamicChatNotificationTimeout = 5000;\r\n\r\nconst defaultCacheRefreshThresholdHours = 24;\r\nconst cacheRefreshThresholdHours = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.convertToSingleHours)(\r\n  localStorage.getItem('cacheRefreshThresholdHours') ||\r\n  (localStorage.setItem('cacheRefreshThresholdHours', defaultCacheRefreshThresholdHours), defaultCacheRefreshThresholdHours)\r\n);\r\n\r\n// List of trusted domains\r\nconst trustedDomains = [\r\n  'klavogonki.ru',\r\n  'youtube.com', // youtube main\r\n  'youtu.be', // youtube share\r\n  'imgur.com',\r\n  'pikabu.ru',\r\n  'userapi.com', // vk.com\r\n  'ibb.co', // imgbb.com\r\n  'yaplakal.com',\r\n  'freepik.com'\r\n];\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/definitions.js?");

/***/ }),

/***/ "./src/modules/helpers.js":
/*!********************************!*\
  !*** ./src/modules/helpers.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addBigImageEventListeners: () => (/* binding */ addBigImageEventListeners),\n/* harmony export */   addPulseEffect: () => (/* binding */ addPulseEffect),\n/* harmony export */   adjustVisibility: () => (/* binding */ adjustVisibility),\n/* harmony export */   convertToSingleHours: () => (/* binding */ convertToSingleHours),\n/* harmony export */   createScrollButtons: () => (/* binding */ createScrollButtons),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   decodeURL: () => (/* binding */ decodeURL),\n/* harmony export */   fetchJSON: () => (/* binding */ fetchJSON),\n/* harmony export */   getCurrentTimeFormatted: () => (/* binding */ getCurrentTimeFormatted),\n/* harmony export */   getExactUserIdByName: () => (/* binding */ getExactUserIdByName),\n/* harmony export */   getRandomEmojiAvatar: () => (/* binding */ getRandomEmojiAvatar),\n/* harmony export */   getUserChatDuration: () => (/* binding */ getUserChatDuration),\n/* harmony export */   getUserIDsByName: () => (/* binding */ getUserIDsByName),\n/* harmony export */   getUserProfileData: () => (/* binding */ getUserProfileData),\n/* harmony export */   highlightMentionWords: () => (/* binding */ highlightMentionWords),\n/* harmony export */   isAltKeyPressed: () => (/* binding */ isAltKeyPressed),\n/* harmony export */   isCtrlKeyPressed: () => (/* binding */ isCtrlKeyPressed),\n/* harmony export */   isTrustedDomain: () => (/* binding */ isTrustedDomain),\n/* harmony export */   isValidEncodedURL: () => (/* binding */ isValidEncodedURL),\n/* harmony export */   loadProfileIntoIframe: () => (/* binding */ loadProfileIntoIframe),\n/* harmony export */   processEncodedLinks: () => (/* binding */ processEncodedLinks),\n/* harmony export */   refreshFetchedUsers: () => (/* binding */ refreshFetchedUsers),\n/* harmony export */   removeAllPanelEventListeners: () => (/* binding */ removeAllPanelEventListeners),\n/* harmony export */   removeBigImageEventListeners: () => (/* binding */ removeBigImageEventListeners),\n/* harmony export */   removePreviousPanel: () => (/* binding */ removePreviousPanel),\n/* harmony export */   scrollMessagesToBottom: () => (/* binding */ scrollMessagesToBottom),\n/* harmony export */   scrollMessagesToMiddle: () => (/* binding */ scrollMessagesToMiddle),\n/* harmony export */   shouldEnableSetting: () => (/* binding */ shouldEnableSetting),\n/* harmony export */   triggerDimmingElement: () => (/* binding */ triggerDimmingElement),\n/* harmony export */   triggerTargetElement: () => (/* binding */ triggerTargetElement),\n/* harmony export */   updatePersonalMessageCounts: () => (/* binding */ updatePersonalMessageCounts),\n/* harmony export */   updateScrollButtonOpacity: () => (/* binding */ updateScrollButtonOpacity),\n/* harmony export */   updateScrollButtonsVisibility: () => (/* binding */ updateScrollButtonsVisibility)\n/* harmony export */ });\n/* harmony import */ var _icons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icons.js */ \"./src/modules/icons.js\");\n/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definitions.js */ \"./src/modules/definitions.js\");\n// icons\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Define dynamic variables\r\nlet {\r\n  panelsEvents,\r\n  bigImageEvents,\r\n  lastFocusedIframeTextarea,\r\n  lastEmojiAvatar\r\n} = _definitions_js__WEBPACK_IMPORTED_MODULE_1__.state;\r\n\r\n// Initialize global variables to track the state of Ctrl and Alt keys\r\nlet isCtrlKeyPressed = false, isAltKeyPressed = false;\r\n// Helper function to update key states\r\nconst setKeyState = (key, value) => {\r\n  if (key === 'Control') isCtrlKeyPressed = value;\r\n  if (key === 'Alt') isAltKeyPressed = value;\r\n};\r\n\r\n// Listen for keydown and keyup events\r\n['keydown', 'keyup'].forEach(eventType =>\r\n  document.addEventListener(eventType, event => setKeyState(event.key, eventType === 'keydown'))\r\n);\r\n\r\n// Reset key states when focus or blur events occur\r\n['blur', 'focus'].forEach(eventType =>\r\n  document.addEventListener(eventType, () => {\r\n    if (isCtrlKeyPressed || isAltKeyPressed) {\r\n      console.log(`${isCtrlKeyPressed ? 'Ctrl ' : ''}${isAltKeyPressed ? 'Alt ' : ''}key was true`);\r\n      isCtrlKeyPressed = false;\r\n      isAltKeyPressed = false;\r\n    }\r\n  })\r\n);\r\n\r\nfunction addPulseEffect(element) {\r\n  element.classList.add('pulse-effect');\r\n  setTimeout(() => {\r\n    element.classList.remove('pulse-effect');\r\n  }, 500);\r\n}\r\n\r\n// Function to remove all event listeners from the panel\r\nfunction removeAllPanelEventListeners() {\r\n  Object.values(panelsEvents).forEach((handler) => {\r\n    document.removeEventListener('keydown', handler);\r\n  });\r\n\r\n  // Remove all keys without reassigning the object\r\n  Object.keys(panelsEvents).forEach((key) => delete panelsEvents[key]);\r\n}\r\n\r\nfunction addBigImageEventListeners() {\r\n  Object.entries(bigImageEvents).forEach(([event, handler]) => {\r\n    document.addEventListener(event, handler);\r\n  })\r\n}\r\n\r\nfunction removeBigImageEventListeners() {\r\n  Object.entries(bigImageEvents).forEach(([event, handler]) => {\r\n    document.removeEventListener(event, handler);\r\n  })\r\n}\r\n\r\n// Function to remove the previous panel if it exists\r\nfunction removePreviousPanel() {\r\n  removeAllPanelEventListeners();\r\n  const existingPanel = document.querySelector('.popup-panel');\r\n  if (existingPanel) existingPanel.remove();\r\n}\r\n\r\n// Function to update button opacity\r\nfunction updateScrollButtonOpacity({ container, buttons }) {\r\n  const tolerance = 3,\r\n    isAtTop = container.scrollTop === 0,\r\n    isAtBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - tolerance;\r\n\r\n  [buttons.fullScrollUpButton, buttons.partialScrollUpButton].forEach(button => {\r\n    button.style.opacity = isAtTop ? '0.3' : '1';\r\n    button.style.pointerEvents = isAtTop ? 'none' : 'auto';\r\n  });\r\n\r\n  [buttons.fullScrollDownButton, buttons.partialScrollDownButton].forEach(button => {\r\n    button.style.opacity = isAtBottom ? '0.3' : '1';\r\n    button.style.pointerEvents = isAtBottom ? 'none' : 'auto';\r\n  });\r\n}\r\n\r\n// Function to update the visibility of the scroll buttons container\r\nfunction updateScrollButtonsVisibility({ container, scrollButtonsContainer }) {\r\n  if (container.scrollHeight > container.clientHeight) {\r\n    scrollButtonsContainer.style.display = 'flex';\r\n  } else {\r\n    scrollButtonsContainer.style.display = 'none';\r\n  }\r\n}\r\n\r\n// Function to create scroll buttons for a container\r\nfunction createScrollButtons(container) {\r\n  const scrollButtonsContainer = document.createElement('div');\r\n  scrollButtonsContainer.className = 'scroll-buttons-container';\r\n\r\n  const fullScrollUpButton = document.createElement('div');\r\n  fullScrollUpButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.chevronsUpSVG;\r\n  fullScrollUpButton.title = 'Scroll Up (Full)';\r\n\r\n  const partialScrollUpButton = document.createElement('div');\r\n  partialScrollUpButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.chevronUpSVG;\r\n  partialScrollUpButton.title = 'Scroll Up (Partial)';\r\n\r\n  const partialScrollDownButton = document.createElement('div');\r\n  partialScrollDownButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.chevronDownSVG;\r\n  partialScrollDownButton.title = 'Scroll Down (Partial)';\r\n\r\n  const fullScrollDownButton = document.createElement('div');\r\n  fullScrollDownButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.chevronsDownSVG;\r\n  fullScrollDownButton.title = 'Scroll Down (Full)';\r\n\r\n  const buttons = {\r\n    fullScrollUpButton,\r\n    partialScrollUpButton,\r\n    partialScrollDownButton,\r\n    fullScrollDownButton\r\n  };\r\n\r\n  Object.values(buttons).forEach(button => {\r\n    button.classList.add(\"large-button\", \"scroll-button\");\r\n    scrollButtonsContainer.appendChild(button);\r\n  });\r\n\r\n  function scrollContainer(direction, isFullScroll) {\r\n    const scrollAmount = isFullScroll ? container.scrollHeight : container.clientHeight;\r\n    container.scrollBy({\r\n      top: direction === 'up' ? -scrollAmount : scrollAmount,\r\n      behavior: 'smooth'\r\n    });\r\n    updateScrollButtonOpacity({ container, buttons });\r\n  }\r\n\r\n  fullScrollUpButton.addEventListener('click', () => scrollContainer('up', true));\r\n  partialScrollUpButton.addEventListener('click', () => scrollContainer('up', false));\r\n  partialScrollDownButton.addEventListener('click', () => scrollContainer('down', false));\r\n  fullScrollDownButton.addEventListener('click', () => scrollContainer('down', true));\r\n\r\n  updateScrollButtonOpacity({ container, buttons });\r\n  updateScrollButtonsVisibility({ container, scrollButtonsContainer });\r\n\r\n  container.addEventListener('scroll', () => {\r\n    updateScrollButtonOpacity({ container, buttons });\r\n    updateScrollButtonsVisibility({ container, scrollButtonsContainer });\r\n  });\r\n\r\n  return { scrollButtonsContainer };\r\n}\r\n\r\nconst debounce = (func, delay = 300) => {\r\n  let timeoutId;\r\n  return function (...args) {\r\n    clearTimeout(timeoutId);\r\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\r\n  };\r\n};\r\n\r\n// Adjust element visibility with smooth opacity transition\r\nfunction adjustVisibility(element, action, opacity) {\r\n  if (!element) return; // Exit if element doesn't exist\r\n\r\n  // Force reflow to ensure initial state is recognized\r\n  void element.offsetHeight;\r\n\r\n  element.style.transition = 'opacity 0.3s'; // Apply smooth transition for both show and hide\r\n  element.style.opacity = action === 'show' ? opacity : '0'; // Set target opacity\r\n\r\n  // If hiding, wait for transition to finish before removing the element\r\n  if (action === 'hide') {\r\n    element.addEventListener('transitionend', () => {\r\n      if (element.style.opacity === '0') element.remove(); // Remove only when opacity reaches 0\r\n    }, { once: true }); // Ensure the event runs only once\r\n  }\r\n}\r\n\r\n// Function to create and fade the dimming element\r\nfunction triggerDimmingElement(action) {\r\n  // Check if the dimming element already exists\r\n  let dimming = document.querySelector('.dimming-background');\r\n  // Check if the scaled thumbnail already exists\r\n  let scaledThumbnail = document.querySelector('.scaled-thumbnail');\r\n\r\n  // If the action is 'hide' and the dimming element doesn't exist, return\r\n  if (action === 'hide' && !dimming) return;\r\n\r\n  // Create the dimming element only if it doesn't exist\r\n  if (!dimming) {\r\n    dimming = document.createElement('div');\r\n    dimming.classList.add('dimming-background');\r\n\r\n    // Append the dimming element to the body\r\n    document.body.appendChild(dimming);\r\n\r\n    // Add click event listener to remove the dimming element and the upper element\r\n    dimming.addEventListener('click', function () {\r\n      // First, check for .popup-panel, then check for previousElementSibling\r\n      const elementToRemove = document.querySelector('.popup-panel') || dimming.previousElementSibling;\r\n      if (elementToRemove) adjustVisibility(elementToRemove, 'hide', 0); // Fade out and remove element\r\n      triggerDimmingElement('hide');\r\n      if (scaledThumbnail) removeBigImageEventListeners(); // Remove all bigImage event listeners\r\n    });\r\n  }\r\n\r\n  // Adjust the visibility of an element with a dimming effect, setting opacity to 0.5\r\n  adjustVisibility(dimming, action, 0.5);\r\n\r\n  // If the action is 'hide', check for and remove the .scaled-thumbnail using triggerTargetElement\r\n  if (action === 'hide') {\r\n    if (scaledThumbnail) {\r\n      removeBigImageEventListeners(); // Remove all bigImage event listeners\r\n      triggerTargetElement(scaledThumbnail, 'hide'); // Use triggerTargetElement to fade out and remove the scaled-thumbnail\r\n    }\r\n  }\r\n}\r\n\r\n// Function to gradually fade a target element to show or hide it\r\nfunction triggerTargetElement(element, action) {\r\n  if (!element) return; // Return if the element does not exist\r\n\r\n  // Adjust the visibility of a specific element, setting opacity to 1 (fully visible)\r\n  adjustVisibility(element, action, 1);\r\n\r\n  // Add a double click event listener to hide the element\r\n  element.addEventListener('dblclick', (event) => {\r\n    // Check if any panel is open\r\n    const isPanelOpen = document.querySelector('.popup-panel');\r\n    // If any panel is open and the double-clicked target is the scaled image, do not hide the dimming element\r\n    if (!isPanelOpen || !event.target.closest('.scaled-thumbnail')) {\r\n      triggerDimmingElement('hide'); // Hide the dimming element on double click, unless the target is a scaled image and a panel is open\r\n    }\r\n\r\n    triggerTargetElement(element, 'hide'); // Always hide the target element on double click\r\n  });\r\n}\r\n\r\n// Function to check if a URL is valid and contains encoded characters\r\nfunction isValidEncodedURL(url) {\r\n  const urlPattern = /^https?:\\/\\//; // Regex pattern to check if the value is a URL\r\n  const encodedPattern = /%[0-9A-Fa-f]{2}/; // Regex pattern to check if the URL is encoded\r\n  return urlPattern.test(url) && encodedPattern.test(url);\r\n}\r\n\r\n// Function to decode a URL and replace spaces with underscores\r\nfunction decodeURL(url) {\r\n  const [base] = url.split('#'); // Split at the '#' symbol and take the base part\r\n  return decodeURIComponent(base).replace(/ /g, '_'); // Decode and replace spaces with underscores\r\n}\r\n\r\nfunction processEncodedLinks(type) {\r\n  // Select the appropriate container based on the 'type' parameter\r\n  document.querySelector(({\r\n    generalMessages: \".messages-content div\", // General messages container\r\n    chatlogsMessages: \".chat-logs-container\", // Chat logs container\r\n    personalMessages: \".messages-container-wrapper\" // Personal messages container\r\n  })[type])?.querySelectorAll('a:not(.media):not(.decoded)').forEach(link => { // Select all <a> links that haven't been decoded yet\r\n    try {\r\n      // Ensure the link is a valid encoded URL before decoding\r\n      if (isValidEncodedURL(link.href)) {\r\n        let decoded = decodeURL(link.href); // Decode the URL\r\n        link.href = link.textContent = decoded; // Set the decoded URL as both the link href and text content\r\n        link.classList.add('decoded'); // Mark the link as decoded by adding the 'decoded' class\r\n      }\r\n    } catch (error) {\r\n      // If an error occurs during the decoding process, log the error and the link's href\r\n      console.error('Error decoding link:', error, link.href); // Log error and link.href for debugging\r\n    }\r\n  });\r\n}\r\n\r\n// Creates and manages an iframe modal for profile content\r\nconst loadProfileIntoIframe = (url) => {\r\n  // Create iframe element and configure basic attributes\r\n  const profileIframe = document.createElement('iframe');\r\n  profileIframe.classList.add('profile-iframe-container');\r\n  profileIframe.src = url;\r\n\r\n  document.body.appendChild(profileIframe);\r\n  adjustVisibility(profileIframe, 'show', 1);\r\n\r\n  // Cleanup function for removing the iframe and event listeners\r\n  const removeIframe = () => {\r\n    adjustVisibility(profileIframe, 'hide', 0);\r\n    document.removeEventListener('keydown', handleEvents);\r\n    document.removeEventListener('mousedown', handleEvents);\r\n  };\r\n\r\n  // Unified event handler for closure interactions\r\n  const handleEvents = (event) => {\r\n    // Spacebar handling: prevent default closure when textarea is focused\r\n    if (event.type === 'keydown' && event.code === 'Space') {\r\n      if (lastFocusedIframeTextarea) {\r\n        event.stopPropagation();\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n      removeIframe();\r\n    }\r\n    // Close iframe when clicking outside\r\n    if (event.type === 'mousedown' && !profileIframe.contains(event.target)) {\r\n      removeIframe();\r\n    }\r\n  };\r\n\r\n  // Attach global event listeners for closure triggers\r\n  document.addEventListener('keydown', handleEvents);\r\n  document.addEventListener('mousedown', handleEvents);\r\n\r\n  // Configure iframe content interactions after load\r\n  profileIframe.onload = () => {\r\n    try {\r\n      const iframeWindow = profileIframe.contentWindow;\r\n      const iframeDoc = iframeWindow.document;\r\n\r\n      // Track focused textareas within iframe\r\n      iframeDoc.addEventListener('focusin', (e) => {\r\n        if (e.target.tagName === 'TEXTAREA') {\r\n          lastFocusedIframeTextarea = e.target;\r\n        }\r\n      });\r\n\r\n      // Clear textarea focus tracking when leaving input\r\n      iframeDoc.addEventListener('focusout', () => {\r\n        setTimeout(() => {  // Delay to check new active element\r\n          if (!iframeDoc.activeElement || iframeDoc.activeElement.tagName !== 'TEXTAREA') {\r\n            lastFocusedIframeTextarea = null;\r\n          }\r\n        }, 0);\r\n      });\r\n\r\n      // Attach internal iframe closure triggers\r\n      iframeWindow.addEventListener('keydown', handleEvents);\r\n      iframeWindow.addEventListener('dblclick', removeIframe);\r\n\r\n      // Monitor DOM changes for automatic closure conditions\r\n      new MutationObserver((mutations, observer) => {\r\n        // Close iframe when specific UI elements are removed\r\n        if (mutations.some(m => [...m.removedNodes].some(n =>\r\n          n.nodeType === 1 && (n.classList.contains('dimming-background') || n.classList.contains('cached-users-panel'))\r\n        ))) {\r\n          removeIframe();\r\n          observer.disconnect();\r\n        }\r\n      }).observe(document.body, { childList: true, subtree: true });\r\n\r\n    } catch (error) {\r\n      // Handle cross-origin policy restrictions\r\n      console.warn(\"Unable to access iframe contents:\", error);\r\n    }\r\n  };\r\n};\r\n\r\n// Helper function to get a random emoji avatar\r\nfunction getRandomEmojiAvatar() {\r\n  let newEmoji;\r\n  do {\r\n    newEmoji = _definitions_js__WEBPACK_IMPORTED_MODULE_1__.emojiFaces[Math.floor(Math.random() * _definitions_js__WEBPACK_IMPORTED_MODULE_1__.emojiFaces.length)];\r\n  } while (newEmoji === lastEmojiAvatar);\r\n\r\n  lastEmojiAvatar = newEmoji;\r\n  return newEmoji;\r\n}\r\n\r\n// Helper to fetch JSON and validate response\r\nasync function fetchJSON(url) {\r\n  const response = await fetch(url);\r\n  if (!response.ok) throw new Error(`Failed to fetch ${url}`);\r\n  return response.json();\r\n}\r\n\r\n// Helper function to get Exact user ID by username via the search API\r\nasync function getExactUserIdByName(userName) {\r\n  // Define the search API URL\r\n  const searchApiUrl = `https://klavogonki.ru/api/profile/search-users?query=${userName}`;\r\n\r\n  // Get search results from the API\r\n  const searchResults = await fetchJSON(searchApiUrl);\r\n\r\n  // Ensure search results exist and contain data\r\n  if (!searchResults.all?.length) throw new Error(`User ${userName} not found.`);\r\n\r\n  // Return the ID of the user with the exact matching login\r\n  const user = searchResults.all.find(user => user.login === userName);\r\n  if (!user) throw new Error(`Exact match for user ${userName} not found.`);\r\n\r\n  return user.id;\r\n}\r\n\r\n// Helper function to get all user IDs by username via the search API\r\nasync function getUserIDsByName(userName) {\r\n  const searchApiUrl = `https://klavogonki.ru/api/profile/search-users?query=${userName}`;\r\n  const searchResults = await fetchJSON(searchApiUrl);\r\n\r\n  const foundUsers = searchResults.all; // Get all search results\r\n  if (!foundUsers || foundUsers.length === 0) throw new Error(`User ${userName} not found.`);\r\n\r\n  // Return an array of user IDs\r\n  return foundUsers.map(user => user.id);\r\n}\r\n\r\n// Function to validate required user data\r\nfunction validateUserData(user) {\r\n  const requiredFields = ['rank', 'login', 'registered', 'bestSpeed', 'ratingLevel', 'friends', 'cars', 'avatarTimestamp'];\r\n  return user && typeof user === 'object' && requiredFields.every(field => user?.[field] !== undefined);\r\n}\r\n\r\n// Function to convert seconds to a human-readable date format\r\nfunction convertSecondsToDate(seconds) {\r\n  const date = new Date(seconds * 1000);\r\n  return date.toISOString().slice(0, 19).replace('T', ' '); // Converts to 'YYYY-MM-DD HH:mm:ss' format\r\n}\r\n\r\n// Function to convert sec and usec to the 'updated' timestamp\r\nfunction convertToUpdatedTimestamp(sec, usec) {\r\n  // Create the full timestamp by combining sec and usec (in microseconds)\r\n  return sec.toString() + Math.floor(usec / 1000).toString();\r\n}\r\n\r\n// Function to get profile summary and registration data\r\nasync function getUserProfileData(userId, useLocalStorage = true) {\r\n  return new Promise(async (resolve, reject) => {\r\n    let cachedUserInfo = useLocalStorage ? JSON.parse(localStorage.getItem('fetchedUsers')) || {} : {};\r\n    const user = cachedUserInfo[userId];\r\n\r\n    // Validate if user data exists and has the required properties\r\n    if (useLocalStorage && validateUserData(user)) {\r\n      // If all data is cached, resolve with the cached data\r\n      resolve({\r\n        rank: user.rank,\r\n        login: user.login,\r\n        registeredDate: user.registered,\r\n        bestSpeed: user.bestSpeed,\r\n        ratingLevel: user.ratingLevel,\r\n        friends: user.friends, // Use cached friends count\r\n        cars: user.cars, // Use cached cars count\r\n        avatar: user.avatar, // Get avatar availability state\r\n        avatarTimestamp: user.avatarTimestamp // Cached avatar timestamp\r\n      });\r\n    } else {\r\n      try {\r\n        // Fetch profile summary and registered date\r\n        const summaryApiUrl = `https://klavogonki.ru/api/profile/get-summary?id=${userId}`;\r\n        const profileApiUrl = `https://klavogonki.ru/api/profile/get-index-data?userId=${userId}`;\r\n\r\n        // Fetch both profile summary and registration data in parallel\r\n        const [summaryResponse, profileResponse] = await Promise.all([\r\n          fetch(summaryApiUrl),\r\n          fetch(profileApiUrl),\r\n        ]);\r\n\r\n        // Check if both responses are successful\r\n        if (!summaryResponse.ok || !profileResponse.ok) {\r\n          throw new Error('Failed to fetch data from one of the APIs.');\r\n        }\r\n\r\n        const summaryData = await summaryResponse.json();\r\n        const profileData = await profileResponse.json();\r\n\r\n        if (\r\n          summaryData?.user?.login &&\r\n          summaryData.title &&\r\n          profileData?.stats?.registered\r\n        ) {\r\n          // Extract the relevant data\r\n          const rank = summaryData.title;\r\n          const login = summaryData.user.login;\r\n          const registered = profileData.stats.registered.sec\r\n            ? convertSecondsToDate(profileData.stats.registered.sec)\r\n            : 'Invalid Date';\r\n\r\n          // Extract new fields\r\n          const bestSpeed = profileData.stats.best_speed || 0; // Default to 0 if undefined\r\n          const ratingLevel = profileData.stats.rating_level || 0; // Default to 0 if undefined\r\n          const friends = profileData.stats.friends_cnt || 0; // Extract friends count\r\n          const cars = profileData.stats.cars_cnt || 0; // Extract cars count\r\n\r\n          // Extract sec and usec from user.avatar, with null check\r\n          const avatar = summaryData.user?.avatar || null; // Default to null if undefined or not present\r\n          const sec = summaryData.user.avatar?.sec || 0; // Default to 0 if undefined or null\r\n          const usec = summaryData.user.avatar?.usec || 0; // Default to 0 if undefined or null\r\n          const avatarTimestamp = convertToUpdatedTimestamp(sec, usec); // Combine sec and usec to get avatar timestamp\r\n\r\n          // Cache the fetched data if useLocalStorage is true, excluding the avatar\r\n          if (useLocalStorage) {\r\n            cachedUserInfo[userId] = {\r\n              rank: rank,\r\n              login: login,\r\n              registered: registered,\r\n              bestSpeed: bestSpeed,\r\n              ratingLevel: ratingLevel,\r\n              friends: friends, // Cache friends count\r\n              cars: cars, // Cache cars count\r\n              avatar: avatar,\r\n              avatarTimestamp: avatarTimestamp // Cache avatar timestamp\r\n            };\r\n\r\n            // Update localStorage with the new cached data\r\n            localStorage.setItem('fetchedUsers', JSON.stringify(cachedUserInfo));\r\n          }\r\n\r\n          // Resolve with the combined data\r\n          resolve({\r\n            rank: rank,\r\n            login: login,\r\n            registeredDate: registered,\r\n            bestSpeed: bestSpeed,\r\n            ratingLevel: ratingLevel,\r\n            friends: friends,\r\n            cars: cars,\r\n            avatar: avatar, // Return avatar for current session\r\n            avatarTimestamp: avatarTimestamp // Include avatar timestamp in the result\r\n          });\r\n        } else {\r\n          throw new Error('Invalid data format received from the API.');\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error fetching user profile data for ${userId}:`, error);\r\n        reject(error);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n// Helper function to convert time string to single hours\r\nfunction convertToSingleHours(timeString) {\r\n  const [hours, minutes = 0, seconds = 0] = timeString.split(':').map(Number);\r\n  return hours + minutes / 60 + seconds / 3600;\r\n}\r\n\r\n// Function to refresh or manually clear fetched users and reset the timer\r\n// @param {boolean} isManual - If true, clears cache unconditionally; if false, clears based on threshold (default is false)\r\n// @param {number} thresholdHours - Time threshold in hours for automatic cache clearing (default is 24 hours)\r\nfunction refreshFetchedUsers(isManual = false, thresholdHours = 24) {\r\n  // Retrieve the last clear time from localStorage\r\n  const lastClearTime = localStorage.getItem('lastClearTime');\r\n  const timeElapsed = lastClearTime ? (new Date().getTime() - lastClearTime) / (1000 * 60 * 60) : Infinity;\r\n\r\n  // If clearing manually or the time threshold has been reached, clear the cache\r\n  if (isManual || timeElapsed >= thresholdHours) {\r\n    // Clear the fetchedUsers from localStorage\r\n    localStorage.removeItem('fetchedUsers');\r\n\r\n    // Reset the in-memory fetchedUsers object\r\n    _definitions_js__WEBPACK_IMPORTED_MODULE_1__.state.fetchedUsers = {};\r\n\r\n    // Reset the timer by updating 'lastClearTime' and 'nextClearTime'\r\n    const nextClearTime = new Date().getTime() + thresholdHours * 60 * 60 * 1000;\r\n    localStorage.setItem('lastClearTime', new Date().getTime().toString());\r\n    localStorage.setItem('nextClearTime', nextClearTime.toString());\r\n  }\r\n}\r\n\r\nfunction getUserChatDuration(username, actionTime) {\r\n  // Retrieve stored user data and find the target user by login\r\n  const user = Object.values(JSON.parse(localStorage.getItem('fetchedUsers') || '[]'))\r\n    .find(u => u?.login === username);\r\n  if (!user) return ` User \"${username}\" not found`;\r\n\r\n  const actionLog = user.actionLog || [];\r\n  const current = actionLog.find(entry => entry.timestamp === actionTime);\r\n  if (!current) return `Action not found at ${actionTime}`;\r\n\r\n  const actionIndex = actionLog.indexOf(current);\r\n  if (actionIndex === 0) return ` ${username}'s first action`;\r\n\r\n  // Find the most recent action before the current one that has a different type\r\n  const prev = actionLog.slice(0, actionIndex).reverse().find(a => a.type !== current.type);\r\n  if (!prev) return ` No valid previous action found for ${actionTime}`;\r\n\r\n  // Calculate the duration between the two timestamps\r\n  const duration = calculateDuration(prev.timestamp, current.timestamp);\r\n  return current.type === 'leave'\r\n    ? ` ${username} stayed in chat for ${duration}`\r\n    : ` ${username} was absent for ${duration}`;\r\n}\r\n\r\nfunction calculateDuration(start, end) {\r\n  const toSeconds = t => t.split(':').reduce((acc, val, i) =>\r\n    acc + val * [3600, 60, 1][i], 0); // Convert HH:MM:SS to total seconds\r\n\r\n  const diff = Math.abs(toSeconds(end) - toSeconds(start)); // Get absolute difference in seconds\r\n\r\n  return [\r\n    Math.floor(diff / 3600), // Hours\r\n    Math.floor((diff % 3600) / 60), // Minutes\r\n    diff % 60 // Seconds\r\n  ].map(n => n.toString().padStart(2, '0')).join(':'); // Format as HH:MM:SS\r\n}\r\n\r\n// Function to check if a specific setting should be enabled based on localStorage settings\r\nfunction shouldEnableSetting(settingType, specificType) {\r\n  const toggleData = JSON.parse(localStorage.getItem('toggle')) || []; // Retrieve toggle settings or default to empty array\r\n\r\n  // Define toggle names for different setting types\r\n  const toggleNames = {\r\n    notifications: {\r\n      static: 'showChatStaticNotifications',\r\n      dynamic: 'showGlobalDynamicNotifications'\r\n    },\r\n    sound: {\r\n      presence: 'enableBeepOnChatJoinLeave',\r\n      gTTS: 'switchToGoogleTTSEngine'\r\n    }\r\n  };\r\n\r\n  const settingName = toggleNames[settingType];\r\n\r\n  if (!settingName || !settingName[specificType]) return false;\r\n\r\n  // Check if the specified setting toggle is set to 'yes'\r\n  return toggleData.some(toggle =>\r\n    toggle.name === settingName[specificType] && toggle.option === 'yes'\r\n  );\r\n}\r\n\r\n// Track if the user has loaded messages for the first time\r\nlet firstTime = true;\r\n// The distance from the bottom at which we should trigger auto-scrolling\r\nconst scrollThreshold = 600;\r\n\r\n// Scrolls the specified container to the bottom if the user has scrolled close enough\r\nfunction scrollMessagesToBottom(containerType = 'generalMessages') {\r\n  // Define a mapping for container types to their respective selectors\r\n  const containerSelectors = {\r\n    generalMessages: '.messages-content', // For general chat\r\n    chatlogsMessages: '.chat-logs-container', // For chat logs\r\n    personalMessages: '.messages-container-wrapper' // For personal messages panel\r\n  };\r\n\r\n  // Get the container based on the passed containerType\r\n  const containerSelector = containerSelectors[containerType];\r\n\r\n  // If the container selector is not defined, return\r\n  if (!containerSelector) return;\r\n\r\n  // Get the container element\r\n  const container = document.querySelector(containerSelector);\r\n  if (!container) return; // Return if the container doesn't exist\r\n\r\n  // If it's the user's first time loading messages, auto-scroll to the bottom\r\n  if (firstTime) {\r\n    container.scrollTop = container.scrollHeight;\r\n    firstTime = false;\r\n  } else {\r\n    // Calculate how far the user is from the bottom\r\n    const distanceFromBottom = container.scrollHeight - container.scrollTop - container.clientHeight;\r\n    // If the user is close enough to the bottom, auto-scroll to the bottom\r\n    if (distanceFromBottom <= scrollThreshold) {\r\n      container.scrollTop = container.scrollHeight;\r\n    }\r\n  }\r\n}\r\n\r\n// Function to scroll messages to the middle of the parent container\r\nasync function scrollMessagesToMiddle(parent, element) {\r\n  const { top, height } = element.getBoundingClientRect(); // Get the position and height of the found element\r\n  const { top: parentTop, height: parentHeight } = parent.getBoundingClientRect(); // Get the position and height of the parent\r\n\r\n  // Calculate the middle position of the parent container\r\n  const parentMiddle = parentTop + parentHeight / 2;\r\n\r\n  // Determine how far to scroll to center the found element\r\n  const scrollOffset = top - parentMiddle + height / 2;\r\n\r\n  // Scroll to the found element to center it within the parent\r\n  parent.scrollBy({\r\n    top: scrollOffset,\r\n    behavior: 'smooth'\r\n  });\r\n\r\n  await new Promise(resolve => setTimeout(resolve, 500)); // Wait for the scroll to complete\r\n  parent.style.scrollBehavior = 'auto'; // Reset scroll behavior\r\n  addShakeEffect(element); // Add a shake effect to the found element\r\n}\r\n\r\n// Helper function to get current time formatted as [HH:MM:SS]\r\nfunction getCurrentTimeFormatted() {\r\n  return new Date().toLocaleTimeString('en-US', {\r\n    hour12: false,\r\n    hour: '2-digit',\r\n    minute: '2-digit',\r\n    second: '2-digit'\r\n  });\r\n}\r\n\r\n/**\r\n * Checks if a given URL belongs to a trusted domain.\r\n * @param {string} url - The URL to check.\r\n * @returns {{isTrusted: boolean, domain: string}} - Whether the domain is trusted and the extracted domain.\r\n */\r\nfunction isTrustedDomain(url) {\r\n  try {\r\n    const parsedURL = new URL(url);\r\n    const hostnameParts = parsedURL.hostname.toLowerCase().split('.');\r\n    const domain = hostnameParts.length > 2 ? hostnameParts.slice(-2).join('.') : parsedURL.hostname;\r\n    return { isTrusted: _definitions_js__WEBPACK_IMPORTED_MODULE_1__.trustedDomains.includes(domain), domain };\r\n  } catch (error) {\r\n    console.error(\"Error in isTrustedDomain:\", error.message);\r\n    return { isTrusted: false, domain: url }; // Return original URL as domain in case of error\r\n  }\r\n}\r\n\r\nfunction highlightMentionWords(containerType = 'generalMessages') {\r\n  const containerSelectors = {\r\n    generalMessages: {\r\n      container: '.messages-content div',\r\n      messageElement: 'p',\r\n      exclude: ['.time', '.username'] // Add exclusion list\r\n    },\r\n    chatlogsMessages: {\r\n      container: '.chat-logs-container',\r\n      messageElement: '.message-text'\r\n    },\r\n    personalMessages: {\r\n      container: '.messages-container',\r\n      messageElement: '.message-text'\r\n    }\r\n  };\r\n\r\n  const config = containerSelectors[containerType];\r\n  if (!config) {\r\n    console.error('Invalid container type');\r\n    return;\r\n  }\r\n\r\n  const containers = document.querySelectorAll(config.container);\r\n  const globalProcessed = new WeakSet();\r\n\r\n  containers.forEach((container) => {\r\n    const messages = container.querySelectorAll(config.messageElement);\r\n\r\n    messages.forEach((message) => {\r\n      const processingQueue = [\r\n        ...message.querySelectorAll('.private'),\r\n        ...message.querySelectorAll('.system-message'),\r\n        message\r\n      ];\r\n\r\n      processingQueue.forEach((element) => {\r\n        const walker = document.createTreeWalker(\r\n          element,\r\n          NodeFilter.SHOW_TEXT,\r\n          {\r\n            acceptNode: (node) => {\r\n              // Skip processed nodes and protected elements\r\n              if (globalProcessed.has(node)) return NodeFilter.FILTER_SKIP;\r\n\r\n              // Check if node is inside excluded elements\r\n              const parent = node.parentElement;\r\n              if (parent.closest('.mention, .time, .username')) {\r\n                return NodeFilter.FILTER_SKIP;\r\n              }\r\n\r\n              // Additional exclusion for generalMessages\r\n              if (containerType === 'generalMessages' && parent.closest(config.exclude.join(','))) {\r\n                return NodeFilter.FILTER_SKIP;\r\n              }\r\n\r\n              return NodeFilter.FILTER_ACCEPT;\r\n            }\r\n          },\r\n          false\r\n        );\r\n\r\n        const nodes = [];\r\n        let currentNode;\r\n        while ((currentNode = walker.nextNode())) {\r\n          nodes.push(currentNode);\r\n        }\r\n\r\n        nodes.forEach((node) => {\r\n          if (!globalProcessed.has(node)) {\r\n            processNode(node);\r\n            globalProcessed.add(node);\r\n          }\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  function processNode(node) {\r\n    const regex = /[\\s]+|[^\\s\\w--]+|[\\w--]+/g;\r\n    const words = node.textContent.match(regex);\r\n    if (!words) return;\r\n\r\n    const fragment = document.createDocumentFragment();\r\n\r\n    words.forEach((word) => {\r\n      if (_definitions_js__WEBPACK_IMPORTED_MODULE_1__.mentionKeywords.map(alias => alias.toLowerCase()).includes(word.toLowerCase())) {\r\n        const mentionSpan = document.createElement('span');\r\n        mentionSpan.className = 'mention';\r\n        mentionSpan.textContent = word;\r\n        fragment.appendChild(mentionSpan);\r\n      } else {\r\n        fragment.appendChild(document.createTextNode(word));\r\n      }\r\n    });\r\n\r\n    node.parentNode.replaceChild(fragment, node);\r\n  }\r\n}\r\n\r\n// Initialize previousTotalCount with the current personal messages count from localStorage\r\nlet previousTotalCount =\r\n  (localStorage.personalMessages && Object.keys(JSON.parse(localStorage.personalMessages)).length) || 0;\r\n/**\r\n * Updates total and new personal message counts near the personal messages button.\r\n * - Increments new message count only when total message count increases.\r\n * - Manages visibility and pulse effects for the new message indicator.\r\n */\r\nfunction updatePersonalMessageCounts() {\r\n  const totalCountElement = document.querySelector('.personal-messages-button .total-message-count');\r\n  const newCountElement = document.querySelector('.personal-messages-button .new-message-count');\r\n  if (!totalCountElement || !newCountElement) return; // Exit if elements are missing\r\n\r\n  const personalMessages = JSON.parse(localStorage.getItem('personalMessages')) || {};\r\n  const totalCount = Object.keys(personalMessages).length;\r\n\r\n  let newCount = Number(localStorage.getItem('newMessagesCount')) || 0;\r\n  if (totalCount > previousTotalCount) {\r\n    newCount++;\r\n    localStorage.setItem('newMessagesCount', newCount);\r\n    addPulseEffect(newCountElement); // Apply pulse effect for new messages\r\n    addJumpEffect(newCountElement, 50, 50); // Apply jump effect for new messages\r\n  }\r\n\r\n  // Update counts in the UI\r\n  totalCountElement.textContent = totalCount;\r\n  newCountElement.textContent = newCount;\r\n\r\n  // Manage visibility of the new message indicator\r\n  newCountElement.style.visibility = newCount > 0 ? 'visible' : 'hidden';\r\n\r\n  // Apply pulse effect if total count changes\r\n  if (totalCount !== previousTotalCount) addPulseEffect(totalCountElement);\r\n\r\n  previousTotalCount = totalCount; // Update previous count\r\n}\r\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/helpers.js?");

/***/ }),

/***/ "./src/modules/icons.js":
/*!******************************!*\
  !*** ./src/modules/icons.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   actionSVG: () => (/* binding */ actionSVG),\n/* harmony export */   addSVG: () => (/* binding */ addSVG),\n/* harmony export */   beepSVG: () => (/* binding */ beepSVG),\n/* harmony export */   calendarSVG: () => (/* binding */ calendarSVG),\n/* harmony export */   chatLogsSVG: () => (/* binding */ chatLogsSVG),\n/* harmony export */   chevronDownSVG: () => (/* binding */ chevronDownSVG),\n/* harmony export */   chevronLeftSVG: () => (/* binding */ chevronLeftSVG),\n/* harmony export */   chevronRightSVG: () => (/* binding */ chevronRightSVG),\n/* harmony export */   chevronUpSVG: () => (/* binding */ chevronUpSVG),\n/* harmony export */   chevronsDownSVG: () => (/* binding */ chevronsDownSVG),\n/* harmony export */   chevronsUpSVG: () => (/* binding */ chevronsUpSVG),\n/* harmony export */   clipboardSVG: () => (/* binding */ clipboardSVG),\n/* harmony export */   clockSVG: () => (/* binding */ clockSVG),\n/* harmony export */   closeSVG: () => (/* binding */ closeSVG),\n/* harmony export */   deniedSVG: () => (/* binding */ deniedSVG),\n/* harmony export */   enterSVG: () => (/* binding */ enterSVG),\n/* harmony export */   exportSVG: () => (/* binding */ exportSVG),\n/* harmony export */   ignoredSVG: () => (/* binding */ ignoredSVG),\n/* harmony export */   importSVG: () => (/* binding */ importSVG),\n/* harmony export */   leaveSVG: () => (/* binding */ leaveSVG),\n/* harmony export */   mediaMessagesSVG: () => (/* binding */ mediaMessagesSVG),\n/* harmony export */   modeEverySVG: () => (/* binding */ modeEverySVG),\n/* harmony export */   modeMentionSVG: () => (/* binding */ modeMentionSVG),\n/* harmony export */   moderatorSVG: () => (/* binding */ moderatorSVG),\n/* harmony export */   personalMessagesSVG: () => (/* binding */ personalMessagesSVG),\n/* harmony export */   rangeIsOutSVG: () => (/* binding */ rangeIsOutSVG),\n/* harmony export */   removeSVG: () => (/* binding */ removeSVG),\n/* harmony export */   saveSVG: () => (/* binding */ saveSVG),\n/* harmony export */   settingsSVG: () => (/* binding */ settingsSVG),\n/* harmony export */   shuffleSVG: () => (/* binding */ shuffleSVG),\n/* harmony export */   silenceSVG: () => (/* binding */ silenceSVG),\n/* harmony export */   snowflakeSVG: () => (/* binding */ snowflakeSVG),\n/* harmony export */   toggleLeftSVG: () => (/* binding */ toggleLeftSVG),\n/* harmony export */   toggleRightSVG: () => (/* binding */ toggleRightSVG),\n/* harmony export */   trackedSVG: () => (/* binding */ trackedSVG),\n/* harmony export */   trashSVG: () => (/* binding */ trashSVG),\n/* harmony export */   userSVG: () => (/* binding */ userSVG),\n/* harmony export */   userlistCacheSVG: () => (/* binding */ userlistCacheSVG),\n/* harmony export */   usersSVG: () => (/* binding */ usersSVG),\n/* harmony export */   voiceSVG: () => (/* binding */ voiceSVG)\n/* harmony export */ });\nconst svgUrl = \"http://www.w3.org/2000/svg\";\r\nconst iconStrokeWidth = 2;\r\nconst iconSize = 28;\r\n\r\n// SVG icon for entering\r\nconst enterSVGStrokeColor = \"currentColor\";\r\nconst enterSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${enterSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"icon-enter icon-feather icon-log-in\">\r\n    <path d=\"M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4\"></path>\r\n    <polyline points=\"10 17 15 12 10 7\"></polyline>\r\n    <line x1=\"15\" y1=\"12\" x2=\"3\" y2=\"12\"></line>\r\n  </svg>`;\r\n\r\n// SVG icon for leaving\r\nconst leaveSVGStrokeColor = \"currentColor\";\r\nconst leaveSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${leaveSVGStrokeColor}\" stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"icon-leave icon-feather icon-log-out\">\r\n    <path d=\"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4\"></path>\r\n    <polyline points=\"16 17 21 12 16 7\"></polyline>\r\n    <line x1=\"21\" y1=\"12\" x2=\"9\" y2=\"12\"></line>\r\n  </svg>`;\r\n\r\n// SVG icon for the moderator with gradient\r\nconst moderatorSVGStopColorStart = \"rgb(255, 215, 0)\";\r\nconst moderatorSVGStopColorEnd = \"rgb(255, 140, 0)\";\r\nconst moderatorSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 10}\"\r\n      height=\"${iconSize - 10}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"url(#moderatorGradient)\"  <!-- Use a gradient fill -->\r\n      stroke=\"none\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-shield\">\r\n    <!-- Define the gradient -->\r\n    <defs>\r\n        <linearGradient id=\"moderatorGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n            <stop offset=\"0%\" style=\"stop-color: ${moderatorSVGStopColorStart}; stop-opacity: 1\" />\r\n            <stop offset=\"100%\" style=\"stop-color: ${moderatorSVGStopColorEnd}; stop-opacity: 1\" />\r\n        </linearGradient>\r\n    </defs>\r\n    <path d=\"M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z\"></path>\r\n  </svg>`;\r\n\r\n// SVG icon for the tracked with gradient stroke\r\nconst trackedSVGStopColorStart = \"rgb(135, 206, 250)\";\r\nconst trackedSVGStopColorEnd = \"rgb(0, 191, 255)\";\r\nconst trackedSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n       width=\"${iconSize - 12}\"\r\n       height=\"${iconSize - 12}\"\r\n       viewBox=\"0 0 24 24\"\r\n       fill=\"url(#trackedGradient)\"  <!-- Use a gradient fill -->\r\n       class=\"feather feather-star\">\r\n      <!-- Define the gradient for the fill -->\r\n    <defs>\r\n      <linearGradient id=\"trackedGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" style=\"stop-color: ${trackedSVGStopColorStart}; stop-opacity: 1\" />\r\n        <stop offset=\"100%\" style=\"stop-color: ${trackedSVGStopColorEnd}; stop-opacity: 1\" />\r\n      </linearGradient>\r\n    </defs>\r\n    <!-- Use the gradient for the fill -->\r\n    <polygon points=\"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2\"\r\n      stroke=\"url(#trackedGradient)\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    </polygon>\r\n  </svg>`;\r\n\r\n// SVG icon for ignored users\r\nconst ignoredSVGStrokeColor = \"rgb(255, 160, 122)\";\r\nconst ignoredSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${ignoredSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-slash\">\r\n    <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\r\n    <line x1=\"4.93\" y1=\"4.93\" x2=\"19.07\" y2=\"19.07\"></line>\r\n  </svg>`;\r\n\r\n// SVG markup for a clock icon\r\nconst clockSVGStrokeColor = \"currentColor\";\r\nconst clockSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n       width=\"${iconSize - 12}\"\r\n       height=\"${iconSize - 12}\"\r\n       viewBox=\"0 0 24 24\"\r\n       fill=\"none\"\r\n       stroke=\"${clockSVGStrokeColor}\"\r\n       stroke-width=\"${iconStrokeWidth}\"\r\n       stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-clock\">\r\n    <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\r\n    <polyline points=\"12 6 12 12 16 14\"></polyline>\r\n  </svg>`;\r\n\r\n// SVG for the \"chevron right\" icon, used in a popup chat messages\r\nconst actionSVGStrokeColor = \"currentColor\";\r\nconst actionSVG = `\r\n    <svg xmlns=\"${svgUrl}\"\r\n        width=\"${iconSize - 12}\"\r\n        height=\"${iconSize - 12}\"\r\n        viewBox=\"0 0 24 24\"\r\n        fill=\"none\"\r\n        stroke=\"${actionSVGStrokeColor}\"\r\n        stroke-width=\"${iconStrokeWidth}\"\r\n        stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-right\">\r\n      <polyline points=\"9 18 15 12 9 6\"></polyline>\r\n    </svg>`;\r\n\r\n// SVG markup for a user icon\r\nconst userSVGStrokeColor = \"currentColor\";\r\nconst userSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${userSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-user\">\r\n    <path d=\"M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2\"></path>\r\n    <circle cx=\"12\" cy=\"7\" r=\"4\"></circle>\r\n  </svg>`;\r\n\r\n// Button SVG icons \"silence\", \"beep\", \"voice\" representation\r\nconst silenceSVGStrokeColor = \"hsl(355, 80%, 65%)\";\r\nconst beepSVGStrokeColor = \"hsl(55, 80%, 65%)\";\r\nconst voiceSVGStrokeColor = \"hsl(80, 80%, 40%)\";\r\nconst silenceSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${silenceSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\r\n    <line x1=\"23\" y1=\"9\" x2=\"17\" y2=\"15\"></line>\r\n    <line x1=\"17\" y1=\"9\" x2=\"23\" y2=\"15\"></line>\r\n  </svg>`;\r\n\r\nconst beepSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${beepSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\r\n    <path d=\"M19.07 4.93a10 10 0 0 1 0 14.14\" opacity=\"0.3\"></path>\r\n    <path d=\"M15.54 8.46a5 5 0 0 1 0 7.07\"></path>\r\n  </svg>`;\r\n\r\nconst voiceSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${voiceSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\r\n    <path d=\"M19.07 4.93a10 10 0 0 1 0 14.14\"></path>\r\n    <path d=\"M15.54 8.46a5 5 0 0 1 0 7.07\"></path>\r\n  </svg>`;\r\n\r\n// Icons for message mode button\r\n// Button SVG icons \"every\", \"mention\" representation\r\nconst modeEverySVGStrokeColor = \"hsl(100, 50%, 50%)\";\r\nconst modeEverySVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${modeEverySVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path>\r\n    <circle cx=\"9\" cy=\"7\" r=\"4\"></circle>\r\n    <path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"></path>\r\n    <path d=\"M16 3.13a4 4 0 0 1 0 7.75\"></path>\r\n  </svg>`;\r\n\r\nconst modeMentionSVGStrokeColor = \"hsl(180, 60%, 50%)\";\r\nconst modeMentionSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${modeMentionSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2\"></path>\r\n    <circle cx=\"12\" cy=\"7\" r=\"4\"></circle>\r\n  </svg>`;\r\n\r\n// Icon for the out of range value\r\nconst rangeIsOutSVGStrokeColor = \"currentColor\";\r\nconst rangeIsOutSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${rangeIsOutSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-slash\">\r\n    <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\r\n    <line x1=\"4.93\" y1=\"4.93\" x2=\"19.07\" y2=\"19.07\"></line>\r\n  </svg>`;\r\n\r\n// Icon for userlistCache\r\nconst userlistCacheSVGStrokeColor = \"rgb(180, 213, 131)\";\r\nconst userlistCacheSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${userlistCacheSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-database\">\r\n    <ellipse cx=\"12\" cy=\"5\" rx=\"9\" ry=\"3\"></ellipse>\r\n    <path d=\"M21 12c0 1.66-4 3-9 3s-9-1.34-9-3\"></path>\r\n    <path d=\"M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5\"></path>\r\n  </svg>`;\r\n\r\n// Icon for personal messages\r\nconst personalMessagesSVGStrokeColor = \"rgb(255, 160, 122)\";\r\nconst personalMessagesSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${personalMessagesSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-mail\">\r\n    <path d=\"M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z\"></path>\r\n    <polyline points=\"22,6 12,13 2,6\"></polyline>\r\n  </svg>`;\r\n\r\n// Icon for chat logs\r\nconst chatLogsSVGStrokeColor = \"rgb(100, 149, 237)\";\r\nconst chatLogsSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chatLogsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-message-circle\">\r\n      <path \r\n          d=\"M21 11.5 a8.38 8.38 0 0 1 -.9 3.8 a8.5 8.5 0 0 1 -7.6 4.7 a8.38 8.38 0 0 1 -3.8 -.9\r\n          L3 21 l1.9 -5.7 a8.38 8.38 0 0 1 -.9 -3.8 a8.5 8.5 0 0 1 4.7 -7.6\r\n          a8.38 8.38 0 0 1 3.8 -.9 h.5 a8.48 8.48 0 0 1 8 8 v.5 z\">\r\n      </path>\r\n  </svg>`;\r\n\r\n// Icon for media messages\r\nconst mediaMessagesSVGStrokeColor = \"rgb(113, 196, 196)\";\r\nconst mediaMessagesSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${mediaMessagesSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-film\">\r\n    <rect x=\"2\" y=\"2\" width=\"20\" height=\"20\" rx=\"2.18\" ry=\"2.18\"></rect>\r\n    <line x1=\"7\" y1=\"2\" x2=\"7\" y2=\"22\"></line>\r\n    <line x1=\"17\" y1=\"2\" x2=\"17\" y2=\"22\"></line>\r\n    <line x1=\"2\" y1=\"12\" x2=\"22\" y2=\"12\"></line>\r\n    <line x1=\"2\" y1=\"7\" x2=\"7\" y2=\"7\"></line>\r\n    <line x1=\"2\" y1=\"17\" x2=\"7\" y2=\"17\"></line>\r\n    <line x1=\"17\" y1=\"17\" x2=\"22\" y2=\"17\"></line>\r\n    <line x1=\"17\" y1=\"7\" x2=\"22\" y2=\"7\"></line>\r\n  </svg>`;\r\n\r\n// Icon for the disabled chat button\r\nconst deniedSVGStrokeColor = \"rgb(255, 100, 100)\";\r\nconst deniedSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${deniedSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-slash\">\r\n    <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\r\n    <line x1=\"4.93\" y1=\"4.93\" x2=\"19.07\" y2=\"19.07\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the settings icon\r\nconst settingsSVGStrokeColor = \"rgb(255, 228, 196)\";\r\nconst settingsSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${settingsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-sliders\">\r\n    <line x1=\"4\" y1=\"21\" x2=\"4\" y2=\"14\"></line>\r\n    <line x1=\"4\" y1=\"10\" x2=\"4\" y2=\"3\"></line>\r\n    <line x1=\"12\" y1=\"21\" x2=\"12\" y2=\"12\"></line>\r\n    <line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"3\"></line>\r\n    <line x1=\"20\" y1=\"21\" x2=\"20\" y2=\"16\"></line>\r\n    <line x1=\"20\" y1=\"12\" x2=\"20\" y2=\"3\"></line>\r\n    <line x1=\"1\" y1=\"14\" x2=\"7\" y2=\"14\"></line>\r\n    <line x1=\"9\" y1=\"8\" x2=\"15\" y2=\"8\"></line>\r\n    <line x1=\"17\" y1=\"16\" x2=\"23\" y2=\"16\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"x\" icon (close button)\r\nconst closeSVGStrokeColor = \"rgb(144, 238, 144)\";\r\nconst closeSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${closeSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-x\">\r\n    <line x1=\"18\" y1=\"6\" x2=\"6\" y2=\"18\"></line>\r\n    <line x1=\"6\" y1=\"6\" x2=\"18\" y2=\"18\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"chevrons up\" icon\r\nconst chevronsSVGStrokeColor = \"rgb(211, 211, 211)\";\r\nconst chevronsUpSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevrons-up\">\r\n    <polyline points=\"17 11 12 6 7 11\"></polyline>\r\n    <polyline points=\"17 18 12 13 7 18\"></polyline>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"chevron up\" icon\r\nconst chevronUpSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-up\">\r\n    <polyline points=\"18 15 12 9 6 15\"></polyline>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"chevron down\" icon\r\nconst chevronDownSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-down\">\r\n    <polyline points=\"6 9 12 15 18 9\"></polyline>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"chevrons down\" icon\r\nconst chevronsDownSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevrons-down\">\r\n    <polyline points=\"7 13 12 18 17 13\"></polyline>\r\n    <polyline points=\"7 6 12 11 17 6\"></polyline>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"toggle-right\" icon\r\nconst toggleRightSVGStrokeColor = \"rgb(137, 187, 255)\";\r\nconst toggleRightSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 25 25\"\r\n      fill=\"none\"\r\n      stroke=\"${toggleRightSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-toggle-right\">\r\n    <rect x=\"1\" y=\"5\" width=\"22\" height=\"14\" rx=\"7\" ry=\"7\"></rect>\r\n    <circle cx=\"16\" cy=\"12\" r=\"3\"></circle>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"toggle-left\" icon\r\nconst toggleLeftSVGStrokeColor = \"rgb(137, 187, 255)\";\r\nconst toggleLeftSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 25 25\"\r\n      fill=\"none\"\r\n      stroke=\"${toggleLeftSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-toggle-left\">\r\n    <rect x=\"1\" y=\"5\" width=\"22\" height=\"14\" rx=\"7\" ry=\"7\"></rect>\r\n    <circle cx=\"8\" cy=\"12\" r=\"3\"></circle>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"calendar\" icon\r\nconst calendarSVGStrokeColor = \"rgb(176, 196, 222)\";\r\nconst calendarSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${calendarSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-calendar\">\r\n    <rect x=\"3\" y=\"4\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect>\r\n    <line x1=\"16\" y1=\"2\" x2=\"16\" y2=\"6\"></line>\r\n    <line x1=\"8\" y1=\"2\" x2=\"8\" y2=\"6\"></line>\r\n    <line x1=\"3\" y1=\"10\" x2=\"21\" y2=\"10\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"clipboard\" icon\r\nconst clipboardSVGStrokeColor = \"rgb(176, 196, 222)\";\r\nconst clipboardSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${clipboardSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-clipboard\">\r\n    <path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path>\r\n    <rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect>\r\n  </svg>`;\r\n\r\n// SVG for the \"chevron left\" icon, used to change chat logs one day backward\r\nconst chevronLeftSVGStrokeColor = \"rgb(28, 229, 229)\";\r\nconst chevronLeftSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronLeftSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-left\">\r\n    <polyline points=\"15 18 9 12 15 6\"></polyline>\r\n  </svg>`;\r\n\r\n// SVG for the \"chevron right\" icon, used to change chat logs one day forward\r\nconst chevronRightSVGStrokeColor = \"rgb(28, 229, 229)\";\r\nconst chevronRightSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronRightSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-right\">\r\n      <polyline points=\"9 18 15 12 9 6\"></polyline>\r\n  </svg>`;\r\n\r\n// SVG for the \"shuffle\" icon, used to select a random year, month, and day\r\nconst shuffleSVGStrokeColor = \"rgb(169, 155, 255)\";\r\nconst shuffleSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${shuffleSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-shuffle\">\r\n    <polyline points=\"16 3 21 3 21 8\"></polyline>\r\n    <line x1=\"4\" y1=\"20\" x2=\"21\" y2=\"3\"></line>\r\n    <polyline points=\"21 16 21 21 16 21\"></polyline>\r\n    <line x1=\"15\" y1=\"15\" x2=\"21\" y2=\"21\"></line>\r\n    <line x1=\"4\" y1=\"4\" x2=\"9\" y2=\"9\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the trash icon\r\nconst trashSVGStrokeColor = \"rgb(255, 140, 0)\";\r\nconst trashSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${trashSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-trash-2\">\r\n    <polyline points=\"3 6 5 6 21 6\"></polyline>\r\n    <path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path>\r\n    <line x1=\"10\" y1=\"11\" x2=\"10\" y2=\"17\"></line>\r\n    <line x1=\"14\" y1=\"11\" x2=\"14\" y2=\"17\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the users icon\r\nconst usersSVGStrokeColor = \"currentColor\";\r\nconst usersSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${usersSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-users\">\r\n    <path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path>\r\n    <circle cx=\"9\" cy=\"7\" r=\"4\"></circle>\r\n    <path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"></path>\r\n    <path d=\"M16 3.13a4 4 0 0 1 0 7.75\"></path>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"import\" icon (export button)\r\nconst importSVGStrokeColor = \"rgb(209, 144, 238)\";\r\nconst importSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${importSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-download\">\r\n    <path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"></path>\r\n    <polyline points=\"7 10 12 15 17 10\"></polyline>\r\n    <line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"export\" icon (import button)\r\nconst exportSVGStrokeColor = \"rgb(144, 185, 238)\";\r\nconst exportSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${exportSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\" stroke-linecap=\"round\"\r\n      stroke-linejoin=\"round\" class=\"feather feather-upload\">\r\n    <path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"></path>\r\n    <polyline points=\"17 8 12 3 7 8\"></polyline>\r\n    <line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"save\" icon (save button)\r\nconst saveSVGStrokeColor = \"rgb(144, 238, 220)\";\r\nconst saveSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${saveSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-save\">\r\n    <path d=\"M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z\"></path>\r\n    <polyline points=\"17 21 17 13 7 13 7 21\"></polyline>\r\n    <polyline points=\"7 3 7 8 15 8\"></polyline>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"remove\" icon (remove button)\r\nconst removeSVGStrokeColor = \"rgb(238, 144, 144)\";\r\nconst removeSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${removeSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-trash\">\r\n    <polyline points=\"3 6 5 6 21 6\"></polyline>\r\n    <path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"snowflake\" icon\r\nconst snowflakeSVGStrokeColor = \"rgb(176, 196, 222)\";\r\nconst snowflakeSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 8}\"\r\n      height=\"${iconSize - 8}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${snowflakeSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-snowflake\">\r\n    <g id=\"snowflake\">\r\n      <line x1=\"12.06\" y1=\"2.74\" x2=\"12.06\" y2=\"12.06\" />\r\n      <line x1=\"20.12\" y1=\"7.4\" x2=\"12.06\" y2=\"12.06\" />\r\n      <line x1=\"20.12\" y1=\"16.71\" x2=\"12.06\" y2=\"12.06\" />\r\n      <line x1=\"12.06\" y1=\"21.37\" x2=\"12.06\" y2=\"12.06\" />\r\n      <line x1=\"3.99\" y1=\"16.71\" x2=\"12.06\" y2=\"12.06\" />\r\n      <line x1=\"3.99\" y1=\"7.4\" x2=\"12.06\" y2=\"12.06\" />\r\n      <polyline points=\"8.96,4.67 12.06,7.77 15.16,4.67\"/>\r\n      <polyline points=\"16.9,5.68 15.76,9.92 20,11.05\"/>\r\n      <polyline points=\"20,13.06 15.76,14.2 16.9,18.43\"/>\r\n      <polyline points=\"15.16,19.44 12.06,16.34 8.96,19.44\"/>\r\n      <polyline points=\"7.21,18.43 8.35,14.2 4.11,13.06\"/>\r\n      <polyline points=\"4.11,11.05 8.35,9.92 7.21,5.68\"/>\r\n    </g>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"add\" icon (add button)\r\nconst addSVGStrokeColor = \"rgb(209, 144, 238)\";\r\nconst addSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${addSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-plus\">\r\n    <line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"></line>\r\n    <line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"></line>\r\n  </svg>`;\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/icons.js?");

/***/ }),

/***/ "./src/modules/image-converter.js":
/*!****************************************!*\
  !*** ./src/modules/image-converter.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertImageLinksToImage: () => (/* binding */ convertImageLinksToImage)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/modules/helpers.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definitions */ \"./src/modules/definitions.js\");\n// helpers\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Define dynamic variables\r\nlet {\r\n  bigImageEvents,\r\n} = _definitions__WEBPACK_IMPORTED_MODULE_1__.state;\r\n\r\n/*\r\n   * Converts links to images in chat messages by creating a thumbnail and a big image on click.\r\n   * Looks for links that contain \".jpg\" or \".jpeg\" or \".png\" or \".gif\" or \"webp\" extension and creates a thumbnail with the image.\r\n   * If a thumbnail already exists, it skips the link and looks for the next one.\r\n   * When a thumbnail is clicked, it creates a dimming layer and a big image that can be closed by clicking on the dimming layer or the big image itself.\r\n   * Allows navigation through images using the left (<) and right (>) arrow keys.\r\n   */\r\n\r\n// Define global variables for the current big image\r\nlet bigImage = null;\r\n\r\n// Define an array to store all the thumbnail links and their corresponding image URLs\r\nconst thumbnailLinks = [];\r\nlet currentImageIndex = 0;\r\nconst imageChangeDelay = 50; // Prevent double slide by single press adding slight delay\r\nlet isChangingImage = false; // Flag to track if an image change is in progress\r\n\r\nconst imageExtensionEmoji = '';\r\nconst webDomainEmoji = '';\r\nconst untrustedEoji = '';\r\n\r\n// List of allowed image extensions\r\nconst allowedImageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];\r\n\r\n/**\r\n * Checks if a given URL has an allowed image extension.\r\n * @param {string} url - The URL to check.\r\n * @returns {{allowed: boolean, extension: string}} - If the extension is allowed and its type.\r\n */\r\nfunction isAllowedImageExtension(url) {\r\n  // Shared extension extraction logic\r\n  const getExtension = (str) =>\r\n    (str.match(/\\.([^?#.]+)(?:[?#]|$)/i)?.[1]?.toLowerCase() || '');\r\n\r\n  try {\r\n    const extension = getExtension(url);\r\n    return {\r\n      allowed: allowedImageExtensions.includes(extension),\r\n      extension\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Error in isAllowedImageExtension:\", error.message);\r\n    return {\r\n      allowed: false,\r\n      extension: getExtension(String(url)) // Handle non-string URLs\r\n    };\r\n  }\r\n}\r\n\r\nfunction convertImageLinksToImage(containerType) {\r\n  const containerSelectors = {\r\n    generalMessages: \".messages-content div\",\r\n    chatlogsMessages: \".chat-logs-container\",\r\n    personalMessages: \".messages-container-wrapper\"\r\n  }\r\n\r\n  const container = document.querySelector(containerSelectors[containerType]);\r\n  if (!container) return;\r\n\r\n  const links = container.querySelectorAll(\"a:not(.skipped):not(.processed-image)\");\r\n  if (!links.length) return;\r\n\r\n  links.forEach(link => {\r\n    if (!link.href || !link.href.startsWith(\"http\")) return;\r\n\r\n    const { allowed, extension } = isAllowedImageExtension(link.href);\r\n    if (!allowed) return;\r\n\r\n    // Add class media if allowed image extenstion\r\n    link.classList.add(\"media\");\r\n\r\n    const { isTrusted, domain } = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isTrustedDomain)(link.href);\r\n    link.title = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isValidEncodedURL)(link.href) ? (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.decodeURL)(link.href) : link.href;\r\n\r\n    // Handle untrusted domains\r\n    if (!isTrusted) {\r\n      link.classList.add(\"skipped\");\r\n      link.textContent = `${imageExtensionEmoji} Image (${extension.toUpperCase()}) ${webDomainEmoji} Hostname (${domain}) ${untrustedEoji} Untrusted`;\r\n\r\n      // Directly handle the image loading on link click\r\n      link.addEventListener(\"click\", e => {\r\n        if (!link.classList.contains(\"processed-image\")) {\r\n          e.preventDefault(); // Prevent default behavior only if not processed yet\r\n          link.classList.remove(\"skipped\");\r\n          link.classList.add(\"processed-image\");\r\n          createThumbnail(link, true); // Force thumbnail creation\r\n        }\r\n      })\r\n    } else {\r\n      link.textContent = `${imageExtensionEmoji} Image (${extension.toUpperCase()}) ${webDomainEmoji} Hostname (${domain})`;\r\n      link.classList.add(\"processed-image\");\r\n      // Create thumbnail for trusted links directly\r\n      createThumbnail(link, false);\r\n    }\r\n  })\r\n\r\n  function createThumbnail(link, isUntrusted) {\r\n    const thumbnail = document.createElement(\"div\");\r\n    thumbnail.classList.add(\"clickable-thumbnail\");\r\n\r\n    const img = document.createElement(\"img\");\r\n    img.src = link.href;\r\n\r\n    img.onload = () => {\r\n      thumbnail.appendChild(img);\r\n      link.parentNode.insertBefore(thumbnail, link.nextSibling);\r\n      thumbnailLinks.push({ link, imgSrc: link.href });\r\n      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.scrollMessagesToBottom)(containerType);\r\n    }\r\n\r\n    img.onerror = () => {\r\n      console.error(\"Failed to load image:\", link.href);\r\n      link.classList.add(\"skipped\");\r\n    }\r\n\r\n    // Only show thumbnail on click for untrusted domains\r\n    if (isUntrusted) {\r\n      // Check if thumbnail already created, avoid creating again\r\n      if (!link.querySelector(\".clickable-thumbnail\")) {\r\n        link.addEventListener(\"click\", e => {\r\n          // Only create thumbnail once\r\n          if (!link.querySelector(\".clickable-thumbnail\")) {\r\n            thumbnail.appendChild(img); // Add image to thumbnail on user confirmation\r\n            link.parentNode.insertBefore(thumbnail, link.nextSibling);\r\n          }\r\n        })\r\n      }\r\n    } else {\r\n      // Show the thumbnail directly for trusted domains\r\n      thumbnail.appendChild(img);\r\n      link.parentNode.insertBefore(thumbnail, link.nextSibling);\r\n    }\r\n\r\n    thumbnail.addEventListener(\"click\", e => {\r\n      e.stopPropagation();\r\n      bigImage = createBigImage(img.src);\r\n      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.triggerTargetElement)(bigImage, \"show\");\r\n      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)(\"show\");\r\n    })\r\n  }\r\n}\r\n\r\n// Function to create a big image with a dimming layer\r\nfunction createBigImage(src) {\r\n  const bigImage = document.createElement('img');\r\n  bigImage.src = src;\r\n  bigImage.classList.add('scaled-thumbnail');\r\n  document.body.appendChild(bigImage);\r\n\r\n  const removeBigImage = (bigImage) => {\r\n    // Hide the big image and check if there are any popup panels open before hiding the dimming element\r\n    (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.triggerTargetElement)(bigImage, 'hide');\r\n\r\n    if (!document.querySelector('.popup-panel')) {\r\n      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)('hide');\r\n    }\r\n    // Remove all event listeners\r\n    (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.removeBigImageEventListeners)();\r\n  }\r\n\r\n  // Close when clicking outside the big image\r\n  bigImageEvents.unfocusedClick = function (event) {\r\n    if (!bigImage.contains(event.target)) { // If clicked outside the image\r\n      bigImage.remove(); // Directly remove the image from the DOM\r\n      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.removeBigImageEventListeners)(); // Clean up event listeners\r\n    }\r\n  }\r\n\r\n  document.addEventListener('click', bigImageEvents.unfocusedClick);\r\n\r\n  // Attach a keydown event listener for big image to close by ESC or Space and navigate with Arrow keys\r\n  bigImageEvents.keydown = function (event) {\r\n    if (event.code === 'Escape' || event.code === 'Space') { // Hide on ESC or Space\r\n      event.preventDefault(); // Prevent default scrolling behavior for Space\r\n      removeBigImage(bigImage);\r\n    } else if (event.code === 'ArrowLeft') {\r\n      navigateImages(-1);\r\n    } else if (event.code === 'ArrowRight') {\r\n      navigateImages(1);\r\n    }\r\n  }\r\n\r\n  document.addEventListener('keydown', bigImageEvents.keydown);\r\n\r\n  // ZOOM AND MOVE-- START\r\n\r\n  // Set the initial zoom scale and scaling factor\r\n  let zoomScale = 1;\r\n  let scalingFactor = 0.1;\r\n\r\n  // Set up variables for dragging\r\n  let isDragging = false;\r\n  let startX = 0;\r\n  let startY = 0;\r\n  let translateX = -50; // Initial translation in percentage\r\n  let translateY = -50; // Initial translation in percentage\r\n\r\n  // Define the movement speed\r\n  const movementSpeed = 5;\r\n\r\n  // Function to handle zooming\r\n  bigImageEvents.wheel = function (event) {\r\n    // Determine the direction of the mouse wheel movement\r\n    const deltaY = event.deltaY;\r\n    const direction = deltaY < 0 ? 1 : -1;\r\n\r\n    // Update the zoom scale based on the direction and scaling factor\r\n    zoomScale += direction * scalingFactor * zoomScale;\r\n\r\n    // Clamp the zoom scale to a minimum of 1\r\n    zoomScale = Math.max(zoomScale, 1);\r\n\r\n    // Apply the new zoom scale and transform origin\r\n    bigImage.style.transform = `translate(${translateX}%, ${translateY}%) scale(${zoomScale})`;\r\n\r\n    // Prevent the default scrolling behavior\r\n    event.preventDefault();\r\n  };\r\n\r\n  // Function to update the image position smoothly\r\n  bigImageEvents.mousemove = function (event) {\r\n    if (isDragging) {\r\n      // Calculate the distance moved since the last mousemove event\r\n      const deltaX = (event.clientX - startX) / zoomScale * movementSpeed;\r\n      const deltaY = (event.clientY - startY) / zoomScale * movementSpeed;\r\n\r\n      // Update the translate values in percentages\r\n      translateX += (deltaX / bigImage.clientWidth) * 100;\r\n      translateY += (deltaY / bigImage.clientHeight) * 100;\r\n\r\n      // Apply the new translate values in percentages\r\n      bigImage.style.transform = `translate(${translateX}%, ${translateY}%) scale(${zoomScale})`;\r\n\r\n      // Update the start position\r\n      startX = event.clientX;\r\n      startY = event.clientY;\r\n    }\r\n  };\r\n\r\n  bigImageEvents.mousedown = function (event) {\r\n    const { button, clientX, clientY, target, ctrlKey } = event;\r\n    // Restrict LMB and RMB to image clicks only\r\n    if ((button === 0 || button === 2) && target !== bigImage) return;\r\n    let src = target.src; // Get the src from the clicked element\r\n\r\n    if (button === 0) { // Left Mouse Button (LMB)\r\n      ctrlKey ? window.open(src, \"_blank\") : navigateImages(-1);\r\n    } else if (button === 2) { // Right Mouse Button (RMB)\r\n      event.preventDefault();\r\n      if (ctrlKey) {\r\n        // Copy to clipboard and hide the big image\r\n        navigator.clipboard.writeText(src).catch(console.error);\r\n        removeBigImage(bigImage); // Close the big image after copying\r\n      } else {\r\n        navigateImages(1);\r\n      }\r\n    } else if (button === 1) { // Middle Mouse Button (MMB)\r\n      isDragging = true;\r\n      [startX, startY] = [clientX, clientY];\r\n    }\r\n  };\r\n\r\n  bigImageEvents.mouseup = function () {\r\n    isDragging = false; // Reset the dragging flag\r\n  };\r\n\r\n  // Add contextmenu listener to prevent right-click context menu\r\n  bigImageEvents.contextmenu = function (event) {\r\n    event.preventDefault(); // Prevent context menu from appearing\r\n  };\r\n\r\n  // Attach all event listeners\r\n  (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.addBigImageEventListeners)();\r\n\r\n  return bigImage;\r\n}\r\n\r\n// ZOOM AND MOVE-- END\r\n\r\n\r\n// Function to navigate between images within bounds\r\nfunction navigateImages(direction) {\r\n  const newIndex = currentImageIndex + direction;\r\n\r\n  // Ensure the new index stays within bounds\r\n  if (newIndex >= 0 && newIndex < thumbnailLinks.length) {\r\n    if (isChangingImage) {\r\n      return; // If an image change is already in progress, do nothing\r\n    }\r\n\r\n    isChangingImage = true; // Set the flag to indicate image change is in progress\r\n\r\n    // Update the bigImage with the new image URL\r\n    if (bigImage) {\r\n      bigImage.src = thumbnailLinks[newIndex].imgSrc;\r\n    }\r\n\r\n    // Set a timeout to reset the flag after a short delay\r\n    setTimeout(() => {\r\n      isChangingImage = false;\r\n    }, imageChangeDelay); // Adjust the delay duration as needed (e.g., 50 milliseconds)\r\n\r\n    // Update the current index\r\n    currentImageIndex = newIndex;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/image-converter.js?");

/***/ }),

/***/ "./src/modules/messages.js":
/*!*********************************!*\
  !*** ./src/modules/messages.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPersonalMessagesButton: () => (/* binding */ createPersonalMessagesButton)\n/* harmony export */ });\n/* harmony import */ var _image_converter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-converter.js */ \"./src/modules/image-converter.js\");\n/* harmony import */ var _video_converter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./video-converter.js */ \"./src/modules/video-converter.js\");\n/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons */ \"./src/modules/icons.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.js */ \"./src/modules/helpers.js\");\n/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./definitions.js */ \"./src/modules/definitions.js\");\n // image converter\r\n // video converter\r\n\r\n// icons\r\n\r\n\r\n// helpers && helpers definitions\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Define dynamic variables\r\nlet {\r\n  panelsEvents\r\n} = _definitions_js__WEBPACK_IMPORTED_MODULE_4__.state;\r\n\r\n// Function to create the button for opening personal messages\r\nfunction createPersonalMessagesButton(panel) {\r\n  // Create a new element with class 'personal-messages-button'\r\n  const showPersonalMessagesButton = document.createElement('div');\r\n  showPersonalMessagesButton.classList.add(\"empowerment-button\", \"personal-messages-button\");\r\n  showPersonalMessagesButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.personalMessagesSVG; // Add icon\r\n\r\n  // Create the small indicator for all message count\r\n  const allMessageIndicator = document.createElement('div');\r\n  allMessageIndicator.classList.add(\"message-count\", \"total-message-count\");\r\n  const personalMessages = JSON.parse(localStorage.getItem('personalMessages')) || {};\r\n  allMessageIndicator.textContent = Object.keys(personalMessages).length;\r\n  showPersonalMessagesButton.appendChild(allMessageIndicator);\r\n\r\n  // Create the small indicator for new message count\r\n  const newMessageIndicator = document.createElement('div');\r\n  newMessageIndicator.classList.add(\"message-count\", \"new-message-count\");\r\n\r\n  // Get the new messages count from localStorage or set to 0 if not present\r\n  let newMessagesCount = Number(localStorage.getItem('newMessagesCount')) || (localStorage.setItem('newMessagesCount', '0'), 0);\r\n\r\n  newMessageIndicator.textContent = newMessagesCount;\r\n\r\n  // Check the newMessagesCount value and set visibility\r\n  newMessageIndicator.style.visibility = newMessagesCount > 0 ? 'visible' : 'hidden'; // Set visibility based on count\r\n\r\n  showPersonalMessagesButton.appendChild(newMessageIndicator);\r\n\r\n  // Assign a title to the button\r\n  showPersonalMessagesButton.title = 'Show Personal Messages';\r\n\r\n  // Add a click event listener to the button\r\n  showPersonalMessagesButton.addEventListener('click', function () {\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.addPulseEffect)(showPersonalMessagesButton); // Add pulse effect\r\n    showPersonalMessagesPanel(); // Show the personal messages panel\r\n    const personalMessagesCount = Object.keys(JSON.parse(localStorage.getItem('personalMessages')) || {}).length;\r\n    // Open the personal messages panel only when there are messages present.\r\n    if (personalMessagesCount > 0) {\r\n      // Reset newMessagesCount in localStorage to 0 when opening the panel\r\n      localStorage.setItem('newMessagesCount', '0');\r\n      newMessagesCount = 0; // Reset the local variable\r\n      newMessageIndicator.textContent = newMessagesCount; // Update the displayed count\r\n    }\r\n  });\r\n\r\n  // Append the button to the existing panel\r\n  panel.appendChild(showPersonalMessagesButton);\r\n}\r\n\r\n// Find chat message by time in range and matching username\r\nasync function findGeneralChatMessage(targetTime, targetUsername, allowScroll) {\r\n  const parent = document.querySelector('.messages-content'); // Chat container\r\n  if (!parent) return null; // Return null if the container isn't found\r\n\r\n  // Convert time string \"[HH:MM:SS]\" to total seconds\r\n  const timeStringToSeconds = (str) =>\r\n    str.replace(/[\\[\\]]/g, '').split(':').reduce((acc, time, i) =>\r\n      acc + Number(time) * (60 ** (2 - i)), 0\r\n    );\r\n\r\n  const initialTimeValue = timeStringToSeconds(targetTime); // Target time in seconds\r\n\r\n  // Helper to find <p> elements by matching time and username\r\n  const findMatchingElement = (condition) =>\r\n    Array.from(parent.querySelectorAll('p')).find((p) => {\r\n      const timeElement = p.querySelector('.time'); // Get the child element with class 'time'\r\n      const usernameElement = p.querySelector('.username span[data-user]'); // Get the username element\r\n\r\n      if (timeElement && usernameElement) {\r\n        const currentTimeValue = timeStringToSeconds(timeElement.textContent.trim());\r\n        const usernameText = usernameElement.textContent.trim(); // Extract the text content of the username\r\n\r\n        // Check if the time and username match the conditions\r\n        return condition(currentTimeValue) && usernameText === targetUsername;\r\n      }\r\n      return false;\r\n    });\r\n\r\n  // 1. Try to find an exact match first\r\n  let foundElement = findMatchingElement(\r\n    (currentTimeValue) => currentTimeValue === initialTimeValue\r\n  );\r\n\r\n  // 2. If no exact match, search within 10 seconds\r\n  if (!foundElement) {\r\n    foundElement = findMatchingElement(\r\n      (currentTimeValue) => Math.abs(currentTimeValue - initialTimeValue) <= 2\r\n    );\r\n  }\r\n\r\n  if (foundElement && allowScroll) {\r\n    await scrollMessagesToMiddle(parent, foundElement); // Call the extracted scrolling function\r\n  }\r\n\r\n  return foundElement || false; // Return found element or false if not found\r\n}\r\n\r\n// Find chat logs message by time in range and matching username\r\nasync function findChatLogsMessage(targetTime, targetUsername, allowScroll) {\r\n  const parent = document.querySelector('.chat-logs-container'); // Logs container\r\n  if (!parent) return null; // Return null if the container isn't found\r\n\r\n  // Convert time string \"[HH:MM:SS]\" to total seconds\r\n  const timeStringToSeconds = (str) =>\r\n    str.replace(/[\\[\\]]/g, '').split(':').reduce((acc, time, i) =>\r\n      acc + Number(time) * (60 ** (2 - i)), 0\r\n    );\r\n\r\n  const initialTimeValue = timeStringToSeconds(targetTime); // Target time in seconds\r\n\r\n  // Helper to find .message-item elements by matching time and username\r\n  const findMatchingElement = (condition) =>\r\n    Array.from(parent.querySelectorAll('.message-item')).find((messageItem) => {\r\n      const timeElement = messageItem.querySelector('.message-time'); // Get the child element with class 'message-time'\r\n      const usernameElement = messageItem.querySelector('.message-username'); // Get the username element\r\n\r\n      if (timeElement && usernameElement) {\r\n        const currentTimeValue = timeStringToSeconds(timeElement.textContent.trim());\r\n        const usernameText = usernameElement.textContent.trim(); // Extract the text content of the username\r\n\r\n        // Check if the time and username match the conditions\r\n        return condition(currentTimeValue) && usernameText === targetUsername;\r\n      }\r\n      return false;\r\n    });\r\n\r\n  // 1. Try to find an exact match first\r\n  let foundElement = findMatchingElement(\r\n    (currentTimeValue) => currentTimeValue === initialTimeValue\r\n  );\r\n\r\n  // 2. If no exact match, search within 10 seconds\r\n  if (!foundElement) {\r\n    foundElement = findMatchingElement(\r\n      (currentTimeValue) => Math.abs(currentTimeValue - initialTimeValue) <= 2\r\n    );\r\n  }\r\n\r\n  if (foundElement && allowScroll) {\r\n    await scrollMessagesToMiddle(parent, foundElement); // Call the extracted scrolling function\r\n  }\r\n\r\n  return foundElement || false; // Return found element or false if not found\r\n}\r\n\r\n/**\r\n * Converts a given local time to Moscow time (UTC+3) based on the system's timezone.\r\n *\r\n * How it works:\r\n * 1. Gets the system's local timezone offset in minutes (positive if behind UTC).\r\n * 2. Converts the local offset to total minutes from UTC.\r\n * 3. Defines Moscow's fixed offset as UTC+3 (180 minutes).\r\n * 4. Calculates the difference between Moscow's offset and the local offset.\r\n * 5. Parses the input time and converts it into total minutes since midnight.\r\n * 6. Adjusts the time by the calculated difference.\r\n * 7. Ensures the result stays within the 24-hour format (wrap-around handling).\r\n * 8. Converts the result back to HH:MM:SS format and returns it.\r\n *\r\n * @param {string} time - The local time in \"HH:MM:SS\" format.\r\n * @returns {string} - The converted time in Moscow time (HH:MM:SS).\r\n */\r\nfunction calibrateToMoscowTime(time) {\r\n  // Get local timezone offset in minutes (positive if local is behind UTC)\r\n  const localOffsetMinutes = new Date().getTimezoneOffset();\r\n\r\n  // Convert local offset to total minutes from UTC (local time = UTC + localTotalOffset)\r\n  const localTotalOffset = -localOffsetMinutes;\r\n\r\n  // Moscow is UTC+3 (180 minutes)\r\n  const moscowOffset = 3 * 60; // 180 minutes\r\n\r\n  // Calculate the adjustment needed: Moscow offset - local offset\r\n  const diffMinutes = moscowOffset - localTotalOffset;\r\n\r\n  // Parse input time\r\n  const [hours, minutes, seconds] = time.split(':').map(Number);\r\n\r\n  // Convert input time to total minutes since 00:00\r\n  const totalInputMinutes = hours * 60 + minutes;\r\n\r\n  // Adjust by diff and wrap within a single day (1440 minutes)\r\n  let adjustedMinutes = totalInputMinutes + diffMinutes;\r\n  adjustedMinutes = ((adjustedMinutes % 1440) + 1440) % 1440; // Ensure positive\r\n\r\n  // Convert back to hours and minutes\r\n  const adjustedHours = Math.floor(adjustedMinutes / 60);\r\n  const adjustedMins = adjustedMinutes % 60;\r\n\r\n  // Format the result with original seconds\r\n  return `${adjustedHours.toString().padStart(2, '0')}:` +\r\n    `${adjustedMins.toString().padStart(2, '0')}:` +\r\n    `${seconds.toString().padStart(2, '0')}`;\r\n}\r\n\r\n/**\r\n * Removes messages from the DOM and updates localStorage based on the removal type.\r\n * @param {HTMLElement} messageElement - The message element to remove.\r\n * @param {string} removalType - The type of removal: 'single', 'all', or 'from'.\r\n */\r\nfunction removeMessage(messageElement, removalType = 'single') {\r\n  // Extract time and username from the message element\r\n  const time = messageElement.querySelector('.message-time').textContent;\r\n  const username = messageElement.querySelector('.message-username').textContent;\r\n\r\n  // Retrieve localStorage personalMessagesBackup data\r\n  let backupData = JSON.parse(localStorage.getItem('personalMessagesBackup')) || {};\r\n\r\n  // If backup data does not exist, create it by copying original data from personalMessages\r\n  if (Object.keys(backupData).length === 0) {\r\n    const originalData = JSON.parse(localStorage.getItem('personalMessages')) || {};\r\n    backupData = { ...originalData }; // Make a copy of the original data\r\n    localStorage.setItem('personalMessagesBackup', JSON.stringify(backupData)); // Save backupData to localStorage\r\n  }\r\n\r\n  // Work with backupData (make a copy to modify)\r\n  let modifiedBackupData = { ...backupData };\r\n\r\n  if (removalType === 'all') {\r\n    // Remove all messages from the same user\r\n    document.querySelectorAll('.message-item').forEach((element) => {\r\n      const elementUsername = element.querySelector('.message-username').textContent;\r\n      if (elementUsername === username) {\r\n        element.remove(); // Remove the DOM element\r\n\r\n        // Remove the corresponding entry from backupData\r\n        const elementTime = element.querySelector('.message-time').textContent;\r\n        const messageKey = `[${elementTime}]_${elementUsername}`;\r\n        delete modifiedBackupData[messageKey];\r\n      }\r\n    });\r\n  } else if (removalType === 'from') {\r\n    // Get all message elements\r\n    const messageElements = Array.from(document.querySelectorAll('.message-item'));\r\n\r\n    // Find the index of the current message element\r\n    const currentIndex = messageElements.indexOf(messageElement);\r\n\r\n    // Iterate through messages starting from the current message till the end\r\n    for (let i = currentIndex; i < messageElements.length; i++) {\r\n      const element = messageElements[i];\r\n      const elementUsername = element.querySelector('.message-username').textContent;\r\n\r\n      if (elementUsername === username) {\r\n        // Remove the DOM element\r\n        element.remove();\r\n\r\n        // Remove the corresponding entry from backupData\r\n        const elementTime = element.querySelector('.message-time').textContent;\r\n        const messageKey = `[${elementTime}]_${elementUsername}`;\r\n        delete modifiedBackupData[messageKey];\r\n      }\r\n    }\r\n  } else {\r\n    // Default: Remove only the specific message (single)\r\n    const messageKey = `[${time}]_${username}`;\r\n    if (modifiedBackupData[messageKey]) {\r\n      delete modifiedBackupData[messageKey]; // Remove from backupData\r\n      messageElement.remove(); // Remove the DOM element\r\n    }\r\n  }\r\n\r\n  // Update localStorage with the modified backupData\r\n  localStorage.setItem('personalMessagesBackup', JSON.stringify(modifiedBackupData));\r\n\r\n  // Update the total message count displayed in the personal messages button\r\n  const messagesCountElement = document.querySelector('.personal-messages-button .total-message-count');\r\n  if (messagesCountElement) {\r\n    messagesCountElement.textContent = Object.keys(modifiedBackupData).length;\r\n  }\r\n}\r\n\r\n// Update the message count displayed in the personal messages button\r\nfunction updateMessageCount() {\r\n  const personalMessagesCount = Object.keys(JSON.parse(localStorage.getItem('personalMessages') || '{}')).length;\r\n  const messagesCountElement = document.querySelector('.personal-messages-button .total-message-count');\r\n  messagesCountElement.textContent = personalMessagesCount;\r\n}\r\n\r\n// Function to display the personal messages panel\r\nasync function showPersonalMessagesPanel() {\r\n  // Check if the panel already exists\r\n  const existingPanel = document.querySelector('.cached-messages-panel');\r\n  if (existingPanel) {\r\n    existingPanel.remove(); // Remove the settings panel\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n    return; // Return immediately to prevent further execution\r\n  }\r\n\r\n  // Flag to track if this is the first time the panel is being run\r\n  let isFirstPanelRun = true;\r\n  // Flag to track if messages are being imported\r\n  let isMessagesImport = false;\r\n  // Update the message count after panel load to reset the value if messages were not saved\r\n  updateMessageCount();\r\n  // Remove 'personalMessagesBackup' from localStorage if it exists\r\n  if (localStorage.getItem('personalMessagesBackup')) localStorage.removeItem('personalMessagesBackup');\r\n  // Remove any previous panel before creating a new one\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.removePreviousPanel)();\r\n\r\n  // Reset the new messages indicator to 0\r\n  const newMessagesCountElement = document.querySelector('.personal-messages-button .new-message-count');\r\n  if (newMessagesCountElement) newMessagesCountElement.textContent = '0';\r\n  newMessagesCountElement.style.visibility = 'hidden';\r\n  // Remove the localStorage key for new personal messages after opening the messages panel (always)\r\n  localStorage.removeItem('newMessagesCount');\r\n\r\n  // Function to get messages from localStorage\r\n  function getMessages() {\r\n    const cachedMessagesData = localStorage.getItem('personalMessages');\r\n    // Initialize messages by parsing fetched data or setting as empty object\r\n    return JSON.parse(cachedMessagesData) || {};\r\n  }\r\n\r\n  let messages = getMessages();\r\n\r\n  // Create a container div with class 'cached-messages-panel'\r\n  const cachedMessagesPanel = document.createElement('div');\r\n  cachedMessagesPanel.className = 'cached-messages-panel popup-panel';\r\n\r\n  // Create a container div for the panel header\r\n  const panelHeaderContainer = document.createElement('div');\r\n  panelHeaderContainer.className = 'panel-header';\r\n\r\n  // Create the search input container and append it to the panel header\r\n  const messagesSearchContainer = document.createElement('div');\r\n  messagesSearchContainer.className = 'search-for-personal-messages';\r\n\r\n  // Create the input field for searching personal messages\r\n  const messagesSearchInput = document.createElement('input');\r\n  messagesSearchInput.className = 'personal-messages-search-input';\r\n  messagesSearchInput.type = 'search';\r\n\r\n  // Append the search input to the search container\r\n  messagesSearchContainer.appendChild(messagesSearchInput);\r\n\r\n  // Create a container div with class 'panel-control-buttons'\r\n  const panelControlButtons = document.createElement('div');\r\n  panelControlButtons.className = 'panel-control-buttons';\r\n\r\n  // Create a save button with the provided SVG icon\r\n  const saveMessagesButton = document.createElement('div');\r\n  saveMessagesButton.className = 'large-button panel-header-save-button';\r\n  saveMessagesButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.saveSVG;\r\n  saveMessagesButton.title = 'Save messages';\r\n  saveMessagesButton.style.opacity = \"0\";\r\n\r\n  // Handle the save button click to restore the backup\r\n  saveMessagesButton.addEventListener('click', () => {\r\n    // Retrieve the backup and original data from localStorage\r\n    const backupData = localStorage.getItem('personalMessagesBackup');\r\n    const originalData = localStorage.getItem('personalMessages');\r\n\r\n    // Check if both backup and original data exist and if they are different\r\n    const bothDataExist = backupData && originalData;\r\n    const hasDataChanged = bothDataExist && originalData !== backupData;\r\n\r\n    // If no backup or original data exists, do nothing\r\n    if (!bothDataExist) return;\r\n\r\n    // Ask user for confirmation if data has changed and it's not the first run\r\n    if (hasDataChanged && !isFirstPanelRun) {\r\n      const userConfirmed = window.confirm(\"Do you want to apply changes?\");\r\n\r\n      // If user confirms, restore the backup data\r\n      if (userConfirmed) {\r\n        localStorage.setItem('personalMessages', backupData);\r\n        localStorage.removeItem('personalMessagesBackup');\r\n        saveMessagesButton.style.setProperty('display', 'none', 'important');\r\n        saveMessagesButton.style.opacity = '0'; // Hide the save button after saving\r\n        // Wait for the opacity transition to finish before hiding the element\r\n        saveMessagesButton.addEventListener('transitionend', function () {\r\n          // After the transition, hide the button by setting display to 'none'\r\n          saveMessagesButton.style.display = 'none'; // Now you can safely hide the element\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  // Create an import button for messages with the provided SVG icon\r\n  const importMessagesButton = document.createElement('div');\r\n  importMessagesButton.className = \"large-button panel-header-import-button\";\r\n  importMessagesButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.importSVG;\r\n  importMessagesButton.title = 'Import messages';\r\n\r\n  importMessagesButton.addEventListener('click', () => {\r\n    isMessagesImport = true;\r\n    const input = document.createElement('input');\r\n    input.type = 'file';\r\n    input.accept = '.json';\r\n\r\n    input.addEventListener('change', (event) => {\r\n      const file = event.target.files[0];\r\n      if (file) {\r\n        const reader = new FileReader();\r\n        reader.onload = async () => {\r\n          try {\r\n            const importedMessages = JSON.parse(reader.result);\r\n            const existingMessages = JSON.parse(localStorage.getItem('personalMessages') || '{}');\r\n\r\n            // Merge existing and imported messages, ensuring no duplicates by date key\r\n            const mergedMessages = {\r\n              ...existingMessages,\r\n              ...importedMessages\r\n            };\r\n\r\n            // Sort the merged messages with cleaned time for sorting but without modifying the original time\r\n            const cleanedMergedMessages = Object.fromEntries(\r\n              Object.entries(mergedMessages)\r\n                .sort(([, valueA], [, valueB]) => {\r\n                  // Temporarily clean the time for sorting purposes (no change to original time)\r\n                  const cleanedTimeA = valueA.time.replace(/[[\\]]/g, '');\r\n                  const cleanedTimeB = valueB.time.replace(/[[\\]]/g, '');\r\n\r\n                  // Combine date and cleaned time for comparison\r\n                  const dateTimeA = `${valueA.date} ${cleanedTimeA}`;\r\n                  const dateTimeB = `${valueB.date} ${cleanedTimeB}`;\r\n\r\n                  // Convert to Date objects for sorting\r\n                  return new Date(dateTimeA) - new Date(dateTimeB);\r\n                })\r\n            );\r\n\r\n            // Store the merged messages back in localStorage (time remains unchanged with square brackets)\r\n            localStorage.setItem('personalMessages', JSON.stringify(cleanedMergedMessages));\r\n\r\n            updateMessageCount(); // Update the message count after import\r\n\r\n            // Load imported messages\r\n            const messages = getMessages();\r\n            await loadMessages(messages);\r\n          } catch (error) {\r\n            alert('Failed to import messages. The file may be corrupted.');\r\n          }\r\n        };\r\n        reader.readAsText(file);\r\n      }\r\n    });\r\n\r\n    input.click();\r\n  });\r\n\r\n  // Create an export button for messages with the provided SVG icon\r\n  const exportMessagesButton = document.createElement('div');\r\n  exportMessagesButton.className = \"large-button panel-header-export-button\";\r\n  exportMessagesButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.exportSVG;\r\n  exportMessagesButton.title = 'Export messages';\r\n\r\n  // Add event listener for exporting messages\r\n  exportMessagesButton.addEventListener('click', () => {\r\n    const messages = localStorage.getItem('personalMessages');\r\n    if (messages && messages !== '{}') {\r\n      const currentDate = new Intl.DateTimeFormat('en-CA').format(new Date()); // Get the current date in YYYY-MM-DD format\r\n\r\n      // Parse the JSON string to an object for formatting\r\n      const messagesObject = JSON.parse(messages);\r\n\r\n      // Convert the object back to a formatted JSON string with indentation\r\n      const formattedMessages = JSON.stringify(messagesObject, null, 2); // Indented JSON\r\n\r\n      const blob = new Blob([formattedMessages], { type: 'application/json' });\r\n      const link = document.createElement('a');\r\n      link.href = URL.createObjectURL(blob);\r\n      link.download = `Personal_Messages_${currentDate}.json`; // Use currentDate for file name\r\n      link.click();\r\n    } else {\r\n      alert('No messages to export.');\r\n    }\r\n  });\r\n\r\n  // Create a copy personal messages button element\r\n  const copyPersonalMessagesButton = document.createElement('div');\r\n  copyPersonalMessagesButton.className = \"large-button panel-header-copy-button\";\r\n  // Set the inner HTML of the copy personal messages button element with the clipboard SVG\r\n  copyPersonalMessagesButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.clipboardSVG;\r\n  copyPersonalMessagesButton.title = 'Copy Personal Messages';\r\n\r\n  // Event listener to copy the text content of the messages container\r\n  copyPersonalMessagesButton.addEventListener('click', () => {\r\n    addJumpEffect(copyPersonalMessagesButton, 0, 0);\r\n    const textContent = Array.from(document.querySelector('.messages-container').children)\r\n      .filter(node => {\r\n        const style = window.getComputedStyle(node);\r\n        // Ignore hidden messages with contentVisibility 'hidden' or display 'none'\r\n        return style.contentVisibility !== 'hidden' && style.display !== 'none';\r\n      })\r\n      .map(node => node.classList.contains('date-item') ? node.textContent.trim() :\r\n        [node.querySelector('.message-time'), node.querySelector('.message-username'), node.querySelector('.message-text')]\r\n          .map(el => el?.textContent.trim()).filter(Boolean).join(' '))\r\n      .filter(Boolean).join(' \\n');\r\n\r\n    // Check if there's content to copy\r\n    if (textContent.trim()) {\r\n      navigator.clipboard.writeText(textContent)\r\n        .then(() => addJumpEffect(copyPersonalMessagesButton, 0, 0))\r\n        .catch(console.error);\r\n    } else {\r\n      alert('No messages to copy.');\r\n    }\r\n  });\r\n\r\n  // Create a clear cache button with the provided SVG icon\r\n  const clearCacheButton = document.createElement('div');\r\n  clearCacheButton.className = \"large-button panel-header-clear-button\";\r\n  clearCacheButton.title = 'Clear personal messages';\r\n  clearCacheButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.trashSVG;\r\n\r\n  // Add a click event listener to the clear cache button\r\n  clearCacheButton.addEventListener('click', () => {\r\n    // Set the flag to true when clear messages is initiated\r\n    isMessagesImport = true;\r\n    // Check if there are any messages before attempting to clear\r\n    const messages = JSON.parse(localStorage.getItem('personalMessages') || '{}');\r\n    if (Object.keys(messages).length === 0) {\r\n      alert('No messages to delete.');\r\n      return; // Exit the function if no messages exist\r\n    }\r\n    // Clear the messages container\r\n    messagesContainer.innerHTML = null;\r\n\r\n    // Set the 'personalMessages' key in localStorage to an empty object\r\n    localStorage.setItem('personalMessages', JSON.stringify({}));\r\n\r\n    // Fade out the cached messages panel when the clear cache button is clicked\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(cachedMessagesPanel, 'hide');\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n\r\n    // Update the message count displayed in the personal messages button\r\n    const messagesCountElement = document.querySelector('.personal-messages-button .total-message-count');\r\n    if (messagesCountElement) messagesCountElement.textContent = '0';\r\n  });\r\n\r\n  // Create a close button with the provided SVG icon\r\n  const closePanelButton = document.createElement('div');\r\n  closePanelButton.className = \"large-button panel-header-close-button\";\r\n  closePanelButton.title = 'Close panel';\r\n  closePanelButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.closeSVG;\r\n\r\n  // Add a click event listener to the close panel button\r\n  closePanelButton.addEventListener('click', () => {\r\n    // Fade out the cached messages panel when the close button is clicked\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(cachedMessagesPanel, 'hide');\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n  });\r\n\r\n  // Append the search container to the panel header container\r\n  panelHeaderContainer.appendChild(messagesSearchContainer);\r\n\r\n  // Append buttons to the panel header container\r\n  panelControlButtons.appendChild(saveMessagesButton);\r\n  panelControlButtons.appendChild(importMessagesButton);\r\n  panelControlButtons.appendChild(exportMessagesButton);\r\n  panelControlButtons.appendChild(copyPersonalMessagesButton);\r\n  panelControlButtons.appendChild(clearCacheButton);\r\n  panelControlButtons.appendChild(closePanelButton);\r\n\r\n  // Append the panel control buttons element inside the panel header container\r\n  panelHeaderContainer.appendChild(panelControlButtons);\r\n\r\n  // Append the header to the cached messages panel\r\n  cachedMessagesPanel.appendChild(panelHeaderContainer);\r\n\r\n  // Create a container for the messages\r\n  const messagesContainer = document.createElement('div');\r\n  messagesContainer.className = 'messages-container';\r\n\r\n  function attachMutationObserver() {\r\n    // Set up MutationObserver to monitor removal of child elements\r\n    const observer = new MutationObserver(mutationsList => {\r\n      // Skip the observer actions if messages are being imported\r\n      if (isMessagesImport) return;\r\n\r\n      // Check if any node was removed from the messages container\r\n      const removedNode = mutationsList.find(mutation => mutation.type === 'childList' && mutation.removedNodes.length > 0);\r\n\r\n      if (removedNode && saveMessagesButton.style.opacity === '0') {\r\n        isFirstPanelRun = false;\r\n\r\n        // Ensure button is visible and part of the layout before applying opacity\r\n        saveMessagesButton.style.visibility = 'visible'; // Make the button interactable\r\n        saveMessagesButton.style.display = 'flex'; // Set display to flex to reveal it\r\n        saveMessagesButton.offsetHeight; // Ensure styles are applied before transition starts\r\n\r\n        // Apply opacity to fade the button in\r\n        saveMessagesButton.style.opacity = '1';\r\n        saveMessagesButton.style.transition = 'opacity 0.5s ease'; // Apply smooth fade-in transition\r\n      }\r\n    });\r\n\r\n    // Configure the observer to watch for child node removals\r\n    observer.observe(messagesContainer, {\r\n      childList: true, // Watch for changes to the children\r\n      subtree: true // Also monitor all descendants of the messagesContainer\r\n    });\r\n  }\r\n\r\n  let lastUsername = null; // Store the last username processed\r\n  let pingCheckCounter = 0; // Initialize a counter\r\n  let maxPingChecks = 100; // Set the limit to 100\r\n  let pingMessages = false; // Initialize pingMessages as false\r\n  let lastDate = null; // Store the last processed date\r\n\r\n  // Create an array to store message elements for later appending\r\n  const messageElements = [];\r\n\r\n  // Define messageColors and timeColors inside the loop\r\n  const timeColors = {\r\n    private: 'coral',\r\n    mention: 'darkseagreen'\r\n  };\r\n\r\n  const messageColors = {\r\n    private: 'coral',\r\n    mention: 'lightsteelblue',\r\n    default: 'slategray' // Default color if type is not private or mention\r\n  };\r\n\r\n  // Load messages on initial panel open\r\n  async function loadMessages(messages) {\r\n    messagesContainer.children.length && messagesContainer.replaceChildren();\r\n    // Loop through the messages and create elements\r\n    Object.entries(messages).forEach(([, { time, date, username, usernameColor, message, type, userId }]) => {\r\n      // If the current date is different from the last processed one, create a new date-item\r\n      if (lastDate !== date) {\r\n        const dateItem = document.createElement('div');\r\n        dateItem.className = 'date-item';\r\n        // show \"Today\" if date matches\r\n        dateItem.textContent = date === _definitions_js__WEBPACK_IMPORTED_MODULE_4__.today ? 'Today ' : `${date} `;\r\n        dateItem.dataset.date = date; // Store the date in a data attribute\r\n        messagesContainer.appendChild(dateItem); // Append the date-item to the container\r\n        lastDate = date; // Update the last processed date\r\n      }\r\n\r\n      // Create a message-item for the current message\r\n      const messageElement = document.createElement('div');\r\n      messageElement.className = 'message-item';\r\n\r\n      // Add margin-top if this is the first message of a new username group\r\n      if (username !== lastUsername) {\r\n        messageElement.style.marginTop = '0.6em';\r\n        lastUsername = username; // Update the lastUsername\r\n      }\r\n\r\n      // Remove square brackets from the time string\r\n      const formattedTime = time.replace(/[\\[\\]]/g, '').trim();\r\n\r\n      // Create time, username, and message elements\r\n      const timeElement = document.createElement('span');\r\n      timeElement.className = 'message-time';\r\n      timeElement.textContent = formattedTime;\r\n      timeElement.title = `Moscow Time: ${calibrateToMoscowTime(formattedTime)}`;\r\n      timeElement.style.color = timeColors[type] || 'slategray';\r\n\r\n      // Add click event listener for \"mention\" and \"private\" types\r\n      if (type === 'mention' || type === 'private') {\r\n        const hoverColor = type === 'mention' ? 'lightgreen' : 'peachpuff';\r\n        timeElement.addEventListener('mouseover', () => { timeElement.style.color = hoverColor; });\r\n        timeElement.addEventListener('mouseout', () => { timeElement.style.color = timeColors[type]; });\r\n        timeElement.addEventListener('click', (event) => {\r\n          if (event.ctrlKey) {\r\n            removeMessage(messageElement, 'from');\r\n            return; // Exit the function to prevent opening the chatlog\r\n          }\r\n          if (type === 'mention') {\r\n            const url = `https://klavogonki.ru/chatlogs/${date}.html#${calibrateToMoscowTime(formattedTime)}`;\r\n            window.open(url, '_blank', 'noopener,noreferrer');\r\n          }\r\n        });\r\n      }\r\n\r\n      const usernameElement = document.createElement('span');\r\n      usernameElement.className = 'message-username';\r\n      usernameElement.textContent = username;\r\n      usernameElement.style.color = usernameColor;\r\n\r\n      // Add click event only if userId is defined\r\n      usernameElement.addEventListener('click', (event) => {\r\n        // Remove all messages on Ctrl + LMB click for the same username\r\n        if (event.ctrlKey) {\r\n          removeMessage(messageElement, 'all');\r\n          return;\r\n        }\r\n        if (userId) { // Check if userId is defined\r\n          const url = `https://klavogonki.ru/u/#/${userId}/`; // Construct the user profile URL\r\n          window.open(url, '_blank', 'noopener,noreferrer'); // Open in a new tab\r\n        } else {\r\n          addShakeEffect(usernameElement); // Call the shake effect if userId is not defined\r\n        }\r\n      });\r\n\r\n      const messageTextElement = document.createElement('span');\r\n      messageTextElement.className = 'message-text';\r\n\r\n      // Replace smiley codes with <img> tags, and then wrap links with <a> tags\r\n      messageTextElement.innerHTML = message\r\n        // Replace smiley codes like :word: with <img> tags\r\n        .replace(/:(?=\\w*[a-zA-Z])(\\w+):/g,\r\n          (_, word) => `<img src=\"/img/smilies/${word}.gif\" alt=\":${word}:\" title=\":${word}:\" class=\"smile\">`\r\n        )\r\n        // Wrap http and https links with <a> tags\r\n        .replace(/(https?:\\/\\/[^\\s]+)/gi,\r\n          (url) => `<a href=\"${url}\" target=\"_blank\" rel=\"noopener noreferrer\">${url}</a>`\r\n        );\r\n\r\n      // Add click event listener for the messageTextElement\r\n      messageTextElement.addEventListener('click', async function (event) {\r\n        // Remove single message on Ctrl + LMB click for the same username\r\n        if (event.ctrlKey) {\r\n          removeMessage(messageElement, 'single');\r\n          return;\r\n        }\r\n\r\n        // Call the findGeneralChatMessage function to search for the general chat message by time in range and username\r\n        const foundGeneralChatMessage = await findGeneralChatMessage(time, username, true);\r\n        if (foundGeneralChatMessage) {\r\n          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(cachedMessagesPanel, 'hide');\r\n          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n        } else {\r\n          let previousElement = messageTextElement.parentElement.previousElementSibling;\r\n          while (previousElement && !previousElement.classList.contains('date-item')) {\r\n            previousElement = previousElement.previousElementSibling;\r\n          }\r\n          if (previousElement) {\r\n            await showChatLogsPanel(previousElement.dataset.date);\r\n            const calibratedMoscowTime = calibrateToMoscowTime(formattedTime);\r\n            // Call the findChatLogsMessage function to search for the chat logs message by time in range and username\r\n            requestAnimationFrame(async () => {\r\n              setTimeout(async () => {\r\n                // find chat messge if not found close the panel\r\n                const foundChatLogsMessage = await findChatLogsMessage(calibratedMoscowTime, username, true);\r\n                if (!foundChatLogsMessage) {\r\n                  const chatLogsPanel = document.querySelector('.chat-logs-panel'); // Get the chat logs panel\r\n                  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(chatLogsPanel, 'hide'); // Hide the chat logs panel\r\n                  showPersonalMessagesPanel(); // Show the personal messages panel again\r\n                }\r\n              }, 500); // Adjust the delay as needed\r\n            });\r\n          }\r\n        }\r\n      });\r\n\r\n      // Store elements for (pingable messages) colorization after all processing\r\n      const messageData = {\r\n        messageTextElement,\r\n        time,\r\n        username,\r\n        type\r\n      };\r\n\r\n      // Add messageData to the array for later processing\r\n      messageElements.push(messageData);\r\n\r\n      // Append time, username, and message to the message element\r\n      messageElement.appendChild(timeElement);\r\n      messageElement.appendChild(usernameElement);\r\n      messageElement.appendChild(messageTextElement);\r\n\r\n      // Append the message element to the messages container\r\n      messagesContainer.appendChild(messageElement);\r\n    });\r\n\r\n    requestAnimationFrame(() => {\r\n      (0,_image_converter_js__WEBPACK_IMPORTED_MODULE_0__.convertImageLinksToImage)('personalMessages');\r\n      (0,_video_converter_js__WEBPACK_IMPORTED_MODULE_1__.convertVideoLinksToPlayer)('personalMessages');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processEncodedLinks)('personalMessages'); // Decodes links within the personal messages section.\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.highlightMentionWords)('personalMessages');\r\n      messagesContainer.scrollTop = messagesContainer.scrollHeight; // Scroll after next repaint\r\n      attachMutationObserver();\r\n      setTimeout(() => { isMessagesImport = false; }, 500);\r\n    });\r\n\r\n    // Process the colorization logic in reverse order\r\n    messageElements.reverse().forEach(async ({ messageTextElement, time, username, type }) => {\r\n      if (pingCheckCounter < maxPingChecks) {\r\n        pingMessages = await findGeneralChatMessage(time, username, false);\r\n        pingCheckCounter++; // Increment the counter\r\n\r\n        if (pingCheckCounter >= maxPingChecks) {\r\n          pingMessages = false;\r\n          console.log(\"Reached maximum ping checks, resetting pingMessages.\");\r\n        }\r\n      }\r\n\r\n      // Colorize the messageTextElement accordingly (Pingable messages)\r\n      messageTextElement.style.color =\r\n        pingMessages && type === 'mention' ? 'lightgreen' :\r\n          pingMessages && type === 'private' ? 'lemonchiffon' :\r\n            messageColors[type] || 'slategray';\r\n    });\r\n  }\r\n\r\n  // Assuming this code is within an async function\r\n  await loadMessages(messages);\r\n\r\n  // Append the messages container to the cached messages panel\r\n  cachedMessagesPanel.appendChild(messagesContainer);\r\n\r\n  // Append the cached messages panel to the body\r\n  document.body.appendChild(cachedMessagesPanel);\r\n\r\n  // Create and append scroll buttons\r\n  const { scrollButtonsContainer } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.createScrollButtons)(messagesContainer);\r\n  cachedMessagesPanel.appendChild(scrollButtonsContainer);\r\n\r\n  // Fade in the cached messages panel\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(cachedMessagesPanel, 'show');\r\n  // Show the dimming background\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('show');\r\n\r\n  // Add click event listener to clear the search input by LMB click with Ctrl key pressed\r\n  messagesSearchInput.addEventListener('click', () => _helpers_js__WEBPACK_IMPORTED_MODULE_3__.isCtrlKeyPressed && (messagesSearchInput.value = ''));\r\n\r\n  // Event listener to handle input search for matching personal messages\r\n  // It searches through messages grouped by date and displays the corresponding date\r\n  // Only if there are matching messages in that group.\r\n  messagesSearchInput.addEventListener('input', () => {\r\n    const query = messagesSearchInput.value.toLowerCase().replace(/_/g, ' ');\r\n\r\n    messagesContainer.querySelectorAll('.date-item').forEach(dateEl => {\r\n      let showDateForGroup = false;\r\n      let nextEl = dateEl.nextElementSibling;\r\n\r\n      // Iterate through messages in the current group (until the next date item)\r\n      while (nextEl && !nextEl.classList.contains('date-item')) {\r\n        const match = (nextEl.querySelector('.message-time')?.textContent.toLowerCase().replace(/_/g, ' ') + ' ' +\r\n          nextEl.querySelector('.message-username')?.textContent.toLowerCase().replace(/_/g, ' ') + ' ' +\r\n          nextEl.querySelector('.message-text')?.textContent.toLowerCase().replace(/_/g, ' ')).includes(query);\r\n\r\n        // Toggle visibility based on match using content visibility and font size\r\n        nextEl.style.contentVisibility = match ? 'visible' : 'hidden';\r\n        // Set font size to 0 for hidden messages to maintain layout or remove the font size property\r\n        nextEl.style.fontSize = match ? '' : '0';\r\n\r\n        showDateForGroup = showDateForGroup || match; // Show date if any match found in the group\r\n\r\n        nextEl = nextEl.nextElementSibling;\r\n      }\r\n\r\n      dateEl.style.display = showDateForGroup ? '' : 'none'; // Show or hide the date based on the match results in the group\r\n    });\r\n  });\r\n\r\n  // Focus on the search input using requestAnimationFrame\r\n  function focusOnSearchField() { requestAnimationFrame(function () { messagesSearchInput.focus(); }); } focusOnSearchField();\r\n\r\n  // Define the event handler function for personal messages panel\r\n  panelsEvents.handlePersonalMessagesKeydown = (event) => { // Assign the function to the object\r\n    if (event.key === 'Escape') {\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(cachedMessagesPanel, 'hide');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n      document.removeEventListener('keydown', panelsEvents.handlePersonalMessagesKeydown); // Remove the event listener\r\n    }\r\n  };\r\n\r\n  // Attach the event listener\r\n  document.addEventListener('keydown', panelsEvents.handlePersonalMessagesKeydown);\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/messages.js?");

/***/ }),

/***/ "./src/modules/notifications.js":
/*!**************************************!*\
  !*** ./src/modules/notifications.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStaticNotification: () => (/* binding */ createStaticNotification),\n/* harmony export */   showUserAction: () => (/* binding */ showUserAction)\n/* harmony export */ });\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./definitions */ \"./src/modules/definitions.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"./src/modules/helpers.js\");\n/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tooltip */ \"./src/modules/tooltip.js\");\n// definitions\r\n\r\n\r\n// helpers\r\n\r\n\r\n// tooltip\r\n\r\n\r\n// Creates the action icon element\r\nfunction createActionIcon(iconType) {\r\n  const actionIcon = document.createElement('div');\r\n  actionIcon.classList.add('action-icon');\r\n  actionIcon.style.margin = '0 4px';\r\n  actionIcon.style.setProperty('border', 'none', 'important');\r\n  actionIcon.innerHTML = iconType;\r\n  return actionIcon;\r\n}\r\n\r\n// Function to create and display a static notification\r\nfunction createStaticNotification(user, iconType, time, presence, containerType) {\r\n  // Define a mapping for container types to their respective selectors\r\n  const containerSelectors = {\r\n    generalChat: '.messages-content div', // For general chat notifications\r\n    cachePanel: '.fetched-users .action-log' // For cache notifications\r\n  };\r\n\r\n  // Get the container based on the passed containerType\r\n  const containerSelector = containerSelectors[containerType];\r\n\r\n  // If the container selector is not defined, return\r\n  if (!containerSelector) {\r\n    console.error(\"Invalid or missing container. Please provide 'generalChat' or 'cachePanel'.\");\r\n    return;\r\n  }\r\n\r\n  const staticNotificationsContainer = document.querySelector(containerSelector);\r\n  if (!staticNotificationsContainer) {\r\n    console.error(\"Container not found in DOM.\");\r\n    return;\r\n  }\r\n\r\n  // Add a class to the container based on the container type\r\n  staticNotificationsContainer.classList.add(\r\n    containerType === 'generalChat'\r\n      ? 'static-chat-notifications-container'\r\n      : 'static-cache-notifications-container'\r\n  );\r\n\r\n  // Create the action icon based on the iconType provided\r\n  const staticChatNotification = document.createElement('div');\r\n  staticChatNotification.classList.add('static-chat-notification');\r\n\r\n  // Add double-click listener to purge notifications only if using the generalChat container\r\n  if (containerType === 'generalChat') {\r\n    staticChatNotification.addEventListener('dblclick', () => {\r\n      purgeStaticChatNotifications();\r\n    });\r\n  }\r\n\r\n  // Create the user element\r\n  const userElement = document.createElement('span');\r\n  userElement.classList.add(\"action-user\");\r\n  userElement.textContent = user;\r\n\r\n  // Create the action icon based on the iconType provided\r\n  const actionIcon = createActionIcon(iconType);\r\n\r\n  // Create the time element\r\n  const timeElement = document.createElement('span');\r\n  timeElement.classList.add(\"action-time\");\r\n  timeElement.textContent = time;\r\n\r\n  // Append elements in order: user span, action icon, time span\r\n  staticChatNotification.appendChild(userElement);\r\n  staticChatNotification.appendChild(actionIcon);\r\n  staticChatNotification.appendChild(timeElement);\r\n\r\n  // Store username and time as data attributes for easy access later\r\n  staticChatNotification.dataset.username = user;\r\n  staticChatNotification.dataset.time = time;\r\n\r\n  // Style based on presence\r\n  if (presence) {\r\n    staticChatNotification.classList.add('user-enter');\r\n  } else {\r\n    staticChatNotification.classList.add('user-left');\r\n  }\r\n\r\n  // Append the notification to the selected container\r\n  staticNotificationsContainer.appendChild(staticChatNotification);\r\n\r\n  // Use the custom tooltip when the user enters the static notification\r\n  staticChatNotification.addEventListener('mouseover', () => {\r\n    // Use dataset to get the username and time from the static notification\r\n    const usernameData = staticChatNotification.dataset.username;\r\n    const timeData = staticChatNotification.dataset.time;\r\n    // Get the user chat duration and pass it to the custom tooltip\r\n    const title = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getUserChatDuration)(usernameData, timeData);\r\n    // Create and display the custom tooltip\r\n    (0,_tooltip__WEBPACK_IMPORTED_MODULE_2__.createCustomTooltip)(staticChatNotification, title);\r\n  });\r\n}\r\n\r\n// Function to create and animate a dynamic notification\r\nfunction createDynamicNotification(user, iconType, time, presence) {\r\n  let dynamicChatNotificationsContainer = document.querySelector('.dynamic-chat-notifications-container');\r\n  // Create container if it doesn't exist\r\n  if (!dynamicChatNotificationsContainer) {\r\n    dynamicChatNotificationsContainer = document.createElement('div');\r\n    dynamicChatNotificationsContainer.classList.add('dynamic-chat-notifications-container');\r\n    document.body.appendChild(dynamicChatNotificationsContainer);\r\n  }\r\n\r\n  // Create the notification element\r\n  const dynamicChatNotification = document.createElement('div');\r\n  dynamicChatNotification.classList.add('dynamic-chat-notification');\r\n\r\n  // Create user element\r\n  const userElement = document.createElement('span');\r\n  userElement.classList.add(\"action-user\");\r\n  userElement.textContent = user;\r\n\r\n  // Create the action icon based on the iconType provided\r\n  const actionIcon = createActionIcon(iconType);\r\n\r\n  // Create time element\r\n  const timeElement = document.createElement('span');\r\n  timeElement.classList.add(\"action-time\");\r\n  timeElement.textContent = time;\r\n\r\n  // Append elements in order: user span, action icon, time span\r\n  dynamicChatNotification.appendChild(userElement);\r\n  dynamicChatNotification.appendChild(actionIcon);\r\n  dynamicChatNotification.appendChild(timeElement);\r\n\r\n  // Store username and time as data attributes for easy access later\r\n  dynamicChatNotification.dataset.username = user;\r\n  dynamicChatNotification.dataset.time = time;\r\n\r\n  // Set colorization based on presence\r\n  if (presence) {\r\n    dynamicChatNotification.classList.add('user-enter');\r\n  } else {\r\n    dynamicChatNotification.classList.add('user-left');\r\n  }\r\n\r\n  // Append to the container\r\n  dynamicChatNotificationsContainer.appendChild(dynamicChatNotification);\r\n\r\n  // Use the custom tooltip when the user enters the static notification\r\n  dynamicChatNotification.addEventListener('mouseover', () => {\r\n    // Use dataset to get the username and time from the static notification\r\n    const usernameData = dynamicChatNotification.dataset.username;\r\n    const timeData = dynamicChatNotification.dataset.time;\r\n    // Get the user chat duration and pass it to the custom tooltip\r\n    const title = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getUserChatDuration)(usernameData, timeData);\r\n    // Create and display the custom tooltip\r\n    (0,_tooltip__WEBPACK_IMPORTED_MODULE_2__.createCustomTooltip)(dynamicChatNotification, title);\r\n  });\r\n\r\n  // Animate: slide in, then slide out and remove\r\n  setTimeout(() => {\r\n    dynamicChatNotification.style.transform = 'translateX(0)';\r\n    setTimeout(() => {\r\n      dynamicChatNotification.style.transform = 'translateX(-100%)';\r\n      setTimeout(() => {\r\n        dynamicChatNotificationsContainer.removeChild(dynamicChatNotification);\r\n      }, 300); // after slide-out animation\r\n    }, _definitions__WEBPACK_IMPORTED_MODULE_0__.dynamicChatNotificationTimeout);\r\n  }, 300);\r\n}\r\n\r\n// Main function which now calls the appropriate notification function(s)\r\nfunction showUserAction(user, iconType, presence) {\r\n  // Check if the user is tracked and in the correct state\r\n  const isTrackedUser = _definitions__WEBPACK_IMPORTED_MODULE_0__.usersToTrack.some(\r\n    (trackedUser) => trackedUser.name === user && trackedUser.state === 'thawed'\r\n  );\r\n\r\n  const shouldShowStatic = isTrackedUser && (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.shouldEnableSetting)('notifications', 'static');\r\n  const shouldShowDynamic = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.shouldEnableSetting)('notifications', 'dynamic');\r\n\r\n  // If neither notification is enabled, exit early.\r\n  if (!shouldShowStatic && !shouldShowDynamic) return;\r\n\r\n  // Get current time formatted as [HH:MM:SS]\r\n  const time = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getCurrentTimeFormatted)();\r\n\r\n  if (shouldShowStatic && isTrackedUser) {\r\n    createStaticNotification(user, iconType, time, presence, 'generalChat');\r\n    (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.scrollMessagesToBottom)();\r\n  }\r\n\r\n  if (shouldShowDynamic) {\r\n    createDynamicNotification(user, iconType, time, presence);\r\n  }\r\n}\r\n\r\n// NOTIFICATIONS TERMINATOR \r\n\r\n// Helper for pausing execution\r\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\nasync function purgeStaticChatNotifications(\r\n  removalDelay = 40,\r\n  scrollDuration = 600,\r\n  animationDuration = 140\r\n) {\r\n  const chat = document.querySelector(\".messages-content\");\r\n  if (!chat) return;\r\n\r\n  // Save original scroll behavior and set to smooth once\r\n  const originalScrollBehavior = chat.style.scrollBehavior;\r\n  chat.style.scrollBehavior = 'smooth';\r\n\r\n  const elements = [...document.querySelectorAll('.static-chat-notification')].reverse();\r\n\r\n  for (const el of elements) {\r\n    const needsScroll = !isVisibleInContainer(el, chat);\r\n\r\n    if (needsScroll) {\r\n      // Smooth scroll to element\r\n      chat.scrollTop = el.offsetTop - chat.offsetTop - chat.clientHeight / 2;\r\n      await sleep(scrollDuration);\r\n    }\r\n\r\n    Object.assign(el.style, {\r\n      transition: [\r\n        `opacity ${animationDuration / 1000}s cubic-bezier(.3,.1,1,.1)`,\r\n        `transform ${animationDuration / 1000}s cubic-bezier(0,.7,.3,0.95)`\r\n      ].join(','),\r\n      opacity: 0,\r\n      transformOrigin: 'left',\r\n      transform: 'translateX(8em) skewX(-20deg)'\r\n    });\r\n\r\n    // Wait for animation to complete before removal\r\n    await sleep(animationDuration);\r\n    el.remove();\r\n\r\n    // Standard delay between elements\r\n    await sleep(removalDelay);\r\n  }\r\n\r\n  // Final scroll to bottom only if needed\r\n  const isAtBottom = chat.scrollHeight - chat.scrollTop <= chat.clientHeight;\r\n  if (!isAtBottom) {\r\n    chat.scrollTop = chat.scrollHeight;\r\n    await sleep(scrollDuration);\r\n  }\r\n\r\n  // Restore original scroll behavior\r\n  chat.style.scrollBehavior = originalScrollBehavior;\r\n}\r\n\r\nfunction isVisibleInContainer(el, container) {\r\n  const containerRect = container.getBoundingClientRect();\r\n  const elRect = el.getBoundingClientRect();\r\n  return (\r\n    elRect.top >= containerRect.top &&\r\n    elRect.bottom <= containerRect.bottom\r\n  );\r\n}\r\n\r\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/notifications.js?");

/***/ }),

/***/ "./src/modules/settings.js":
/*!*********************************!*\
  !*** ./src/modules/settings.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSettingsButton: () => (/* binding */ createSettingsButton)\n/* harmony export */ });\n/* harmony import */ var _icons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icons.js */ \"./src/modules/icons.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"./src/modules/helpers.js\");\n/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definitions.js */ \"./src/modules/definitions.js\");\n// icons\r\n\r\n\r\n// helpers && helpers definitions\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Define dynamic variables\r\nlet {\r\n  panelsEvents\r\n} = _definitions_js__WEBPACK_IMPORTED_MODULE_2__.state;\r\n\r\n// Array of setting keys and their corresponding exported arrays\r\nconst settingsMap = [\r\n  ['usersToTrack', _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usersToTrack],\r\n  ['mentionKeywords', _definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords],\r\n  ['usernameReplacements', _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usernameReplacements],\r\n  ['moderator', _definitions_js__WEBPACK_IMPORTED_MODULE_2__.moderator],\r\n  ['ignored', _definitions_js__WEBPACK_IMPORTED_MODULE_2__.ignored]\r\n];\r\n\r\nsettingsMap.forEach(([key, arr]) => {\r\n  const stored = JSON.parse(localStorage.getItem(key)) || [];\r\n  if (stored.length) arr.splice(0, arr.length, ...stored);\r\n});\r\n\r\n// Assuming myNickname is defined somewhere in your code:\r\n_definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords.push(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.myNickname);\r\n\r\n// Global function to handle file input and process uploaded settings\r\nasync function handleUploadSettings(event) {\r\n  const file = event.target.files[0];\r\n  if (file) {\r\n    const reader = new FileReader();\r\n\r\n    // Return a Promise to handle the asynchronous reading\r\n    return new Promise((resolve, reject) => {\r\n      reader.onload = function (e) {\r\n        const jsonData = e.target.result; // Get the raw JSON string\r\n        try {\r\n          const settingsData = JSON.parse(jsonData); // Attempt to parse the JSON data\r\n          // Call a function to process the uploaded settings data\r\n          processUploadedSettings(settingsData);\r\n          resolve(); // Resolve the promise if successful\r\n        } catch (error) {\r\n          console.error('Error parsing JSON data:', error.message); // Log the error message\r\n          console.error('Invalid JSON:', jsonData); // Log the raw JSON string for debugging\r\n          // Optional: Notify the user about the error\r\n          alert('Failed to parse JSON data. Please check the format and try again.');\r\n          reject(error); // Reject the promise on error\r\n        }\r\n      };\r\n\r\n      reader.onerror = function (e) {\r\n        console.error('Error reading file:', e.target.error); // Handle file reading errors\r\n        reject(e.target.error); // Reject the promise on error\r\n      };\r\n\r\n      reader.readAsText(file); // Read the file as text\r\n    });\r\n  }\r\n}\r\n\r\nfunction handleDownloadSettings(settingsData) {\r\n  if (!settingsData || typeof settingsData !== 'object') {\r\n    console.error('Invalid settings data for download.');\r\n    alert('Cannot export settings. Please try again.');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const tabSize2 = '  ';\r\n    const tabSize4 = '    ';\r\n\r\n    // Format usersToTrack\r\n    const usersToTrackFormatted = settingsData.usersToTrack\r\n      .map((user) => `${tabSize4}${JSON.stringify(user)}`)\r\n      .join(',\\n');\r\n\r\n    // Format username replacements\r\n    const replacementsFormatted = settingsData.usernameReplacements\r\n      ?.map(replacement => `${tabSize4}${JSON.stringify(replacement)}`)\r\n      .join(',\\n') || '';\r\n\r\n    // Format toggle settings\r\n    const toggleFormatted = settingsData.toggle\r\n      .map(toggle => `${tabSize4}${JSON.stringify(toggle)}`)\r\n      .join(',\\n');\r\n\r\n    // Build JSON structure\r\n    const jsonData = '{\\n' +\r\n      `${tabSize2}\"usersToTrack\": [\\n` +\r\n      `${usersToTrackFormatted}\\n` +\r\n      `${tabSize2}],\\n` +\r\n      `${tabSize2}\"mentionKeywords\": [\\n` +\r\n      `${settingsData.mentionKeywords.map(keyword => `${tabSize4}\"${keyword}\"`).join(',\\n')}\\n` +\r\n      `${tabSize2}],\\n` +\r\n      `${tabSize2}\"usernameReplacements\": [\\n` + // Added replacements section\r\n      `${replacementsFormatted}\\n` +\r\n      `${tabSize2}],\\n` +\r\n      `${tabSize2}\"moderator\": [\\n` +\r\n      `${settingsData.moderator.map(moderator => `${tabSize4}\"${moderator}\"`).join(',\\n')}\\n` +\r\n      `${tabSize2}],\\n` +\r\n      `${tabSize2}\"ignored\": [\\n` +\r\n      `${settingsData.ignored.map(user => `${tabSize4}\"${user}\"`).join(',\\n')}\\n` +\r\n      `${tabSize2}],\\n` +\r\n      `${tabSize2}\"toggle\": [\\n` +\r\n      `${toggleFormatted}\\n` +\r\n      `${tabSize2}]\\n` +\r\n      '}';\r\n\r\n    // Generate filename\r\n    const currentDate = new Intl.DateTimeFormat('en-CA').format(new Date());\r\n    const filename = `KG_Chat_Empowerment_Settings_${currentDate}.json`;\r\n\r\n    // Create and trigger download\r\n    const blob = new Blob([jsonData], { type: 'application/json' });\r\n    const url = URL.createObjectURL(blob);\r\n    const tempLink = document.createElement('a');\r\n    tempLink.href = url;\r\n    tempLink.download = filename;\r\n    document.body.appendChild(tempLink);\r\n    tempLink.click();\r\n    document.body.removeChild(tempLink);\r\n    URL.revokeObjectURL(url);\r\n  } catch (error) {\r\n    console.error('Error exporting settings:', error);\r\n    alert('Failed to export settings. Please try again.');\r\n  }\r\n}\r\n\r\n// Function to retrieve settings from localStorage and combine them into a single object\r\nfunction getSettingsData() {\r\n  // Retrieve data from localStorage using the appropriate keys\r\n  const usersToTrack = JSON.parse(localStorage.getItem('usersToTrack')) || [];\r\n  const mentionKeywords = JSON.parse(localStorage.getItem('mentionKeywords')) || [];\r\n  const usernameReplacements = JSON.parse(localStorage.getItem('usernameReplacements')) || [];\r\n  const moderator = JSON.parse(localStorage.getItem('moderator')) || [];\r\n  const ignored = JSON.parse(localStorage.getItem('ignored')) || [];\r\n  const toggle = JSON.parse(localStorage.getItem('toggle')) || [];\r\n\r\n  // Combine the retrieved data into a single object\r\n  const settingsData = {\r\n    usersToTrack: usersToTrack,\r\n    mentionKeywords: mentionKeywords,\r\n    usernameReplacements: usernameReplacements,\r\n    moderator: moderator,\r\n    ignored: ignored,\r\n    toggle: toggle\r\n  };\r\n\r\n  return settingsData;\r\n}\r\n\r\n// Create a button to upload and apply new settings,\r\n// receiving the parent panel as a parameter.\r\nfunction createSettingsButton(panel) {\r\n  const showSettingsButton = document.createElement('div');\r\n  showSettingsButton.classList.add(\"empowerment-button\", \"settings-button\");\r\n\r\n  showSettingsButton.title = 'Show Settings Panel';\r\n  showSettingsButton.style.position = 'relative';\r\n\r\n  // Use the settings SVG from icons.js\r\n  showSettingsButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.settingsSVG;\r\n\r\n  const importFileInput = document.createElement('input');\r\n  importFileInput.type = 'file';\r\n  importFileInput.accept = '.json';\r\n  importFileInput.style.display = 'none';\r\n\r\n  importFileInput.addEventListener('change', handleUploadSettings);\r\n\r\n  showSettingsButton.addEventListener('click', event => {\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addPulseEffect)(showSettingsButton);\r\n    if (_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isAltKeyPressed) handleDownloadSettings(getSettingsData());\r\n    if (_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isCtrlKeyPressed) importFileInput.click();\r\n    if (_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isAltKeyPressed || _helpers_js__WEBPACK_IMPORTED_MODULE_1__.isCtrlKeyPressed) return;\r\n    showSettingsPanel();\r\n  });\r\n\r\n  showSettingsButton.appendChild(importFileInput);\r\n\r\n  // Append the settings button to the passed panel\r\n  panel.appendChild(showSettingsButton);\r\n}\r\n\r\n// Save the current settings to localStorage\r\nfunction saveSettingsToLocalStorage() {\r\n  localStorage.setItem('usersToTrack', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.usersToTrack));\r\n  localStorage.setItem('mentionKeywords', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords));\r\n  localStorage.setItem('usernameReplacements', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.usernameReplacements));\r\n  localStorage.setItem('moderator', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.moderator));\r\n  localStorage.setItem('ignored', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.ignored));\r\n  localStorage.setItem('toggle', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.toggle));\r\n}\r\n\r\n// Process and apply uploaded settings\r\nfunction processUploadedSettings({\r\n  usersToTrack: u = [],\r\n  mentionKeywords: mk = [],\r\n  usernameReplacements: ur = [],\r\n  moderator: md = [],\r\n  ignored: i = [],\r\n  toggle: t = []\r\n}) {\r\n  // Ensure the uploaded values are valid arrays\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usersToTrack = Array.isArray(u) ? u : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usersToTrack;\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords = Array.isArray(mk) ? mk : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords;\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usernameReplacements = Array.isArray(ur) ? ur : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usernameReplacements;\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.moderator = Array.isArray(md) ? md : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.moderator;\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.ignored = Array.isArray(i) ? i : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.ignored;\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.toggle = Array.isArray(t) ? t : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.toggle;\r\n\r\n  // Save to localStorage after applying the settings\r\n  saveSettingsToLocalStorage();\r\n  console.log('Uploaded settings applied:', {\r\n    usersToTrack: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usersToTrack,\r\n    mentionKeywords: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords,\r\n    usernameReplacements: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usernameReplacements, // Added to log\r\n    moderator: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.moderator,\r\n    ignored: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.ignored,\r\n    toggle: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.toggle\r\n  });\r\n}\r\n\r\n// Function to display the settings panel\r\nfunction showSettingsPanel() {\r\n  // Check if the panel already exists\r\n  const existingPanel = document.querySelector('.settings-panel');\r\n  if (existingPanel) {\r\n    existingPanel.remove(); // Remove the settings panel\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerDimmingElement)('hide');\r\n    return; // Return immediately to prevent further execution\r\n  }\r\n\r\n  // Remove any previous panel before creating a new one\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removePreviousPanel)();\r\n\r\n  // Create the settings panel container\r\n  const settingsPanel = document.createElement('div');\r\n  settingsPanel.className = 'settings-panel popup-panel';\r\n\r\n  // Define the event handler function for settings panel\r\n  panelsEvents.handleSettingsKeydown = (event) => { // Assign the function to the object\r\n    if (event.key === 'Escape') {\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerTargetElement)(settingsPanel, 'hide');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerDimmingElement)('hide');\r\n      document.removeEventListener('keydown', panelsEvents.handleSettingsKeydown); // Remove the event listener\r\n    }\r\n  };\r\n\r\n  // Attach the event listener\r\n  document.addEventListener('keydown', panelsEvents.handleSettingsKeydown);\r\n\r\n  // Create a container div for the panel header\r\n  const panelHeaderContainer = document.createElement('div');\r\n  panelHeaderContainer.className = 'panel-header';\r\n\r\n  const panelControlButtons = document.createElement('div');\r\n  panelControlButtons.classList.add(\"panel-control-buttons\");\r\n\r\n  // Create a close button with the provided SVG icon\r\n  const closePanelButton = document.createElement('div');\r\n  closePanelButton.className = 'large-button panel-header-close-button';\r\n  closePanelButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.closeSVG;\r\n  closePanelButton.title = 'Close panel';\r\n\r\n  // Add a click event listener to the close panel button\r\n  closePanelButton.addEventListener('click', () => {\r\n    // Fade out the settings panel when the close button is clicked\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerTargetElement)(settingsPanel, 'hide');\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerDimmingElement)('hide');\r\n  });\r\n\r\n  // Create a clear cache button with the provided SVG icon\r\n  const clearCacheButton = document.createElement('div');\r\n  clearCacheButton.className = \"large-button panel-header-clear-button\";\r\n  clearCacheButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.trashSVG;\r\n  clearCacheButton.title = 'Clear settings';\r\n\r\n  // Add a click event listener to the clear cache button\r\n  clearCacheButton.addEventListener('click', () => {\r\n    clearSettingsContainers();\r\n  })\r\n\r\n  // Create an import button with the provided SVG icon\r\n  const importSettingsButton = document.createElement('div');\r\n  importSettingsButton.className = \"large-button panel-header-import-button\";\r\n  importSettingsButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.importSVG;\r\n  importSettingsButton.title = 'Import settings';\r\n\r\n  // Create a save button with the provided SVG icon\r\n  const saveSettingsButton = document.createElement('div');\r\n  saveSettingsButton.className = \"large-button panel-header-save-button\";\r\n  saveSettingsButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.saveSVG;\r\n  saveSettingsButton.title = 'Save settings';\r\n\r\n  function initializeSaveButtonLogic(saveButton) {\r\n    const container = document.querySelector('.settings-content-container');\r\n    if (!container) return console.error(\"Container not found.\");\r\n\r\n    const showButton = () => {\r\n      saveButton.style.visibility = 'visible'; // Make the element interactable\r\n      saveButton.style.display = 'flex'; // Set display to flex to reveal it\r\n      setTimeout(() => {\r\n        saveButton.style.opacity = '1'; // Gradually change opacity\r\n      }, 10); // Small delay to trigger the transition\r\n    };\r\n\r\n    const hideButton = () => {\r\n      saveButton.style.opacity = '0'; // Fade out\r\n      setTimeout(() => {\r\n        saveButton.style.visibility = 'hidden'; // Hide the element after fading out\r\n        saveButton.style.display = 'none'; // Hide the element from layout\r\n      }, 300); // Match the transition duration for smooth disappearance\r\n    };\r\n\r\n    // Get previous values from localStorage\r\n    const previousValues = getSettingsData();\r\n\r\n    const handleInputChange = () => {\r\n      const currentValues = {\r\n        usersToTrack: [],\r\n        mentionKeywords: [],\r\n        usernameReplacements: [],\r\n        moderator: [],\r\n        ignored: [],\r\n        toggle: []\r\n      };\r\n\r\n      // Process tracked items\r\n      container.querySelectorAll('.settings-tracked-container .tracked-item').forEach(item => {\r\n        const usernameField = item.querySelector('.tracked-username-field');\r\n        const genderField = item.querySelector('.tracked-gender-select');\r\n        const pronunciationField = item.querySelector('.tracked-pronunciation-field');\r\n        const snowflakeButton = item.querySelector('.assigned-thawed-config, .assigned-frozen-config');\r\n\r\n        const usernameValue = usernameField ? usernameField.value.trim() : '';\r\n        const genderValue = genderField ? genderField.value.trim() : '';\r\n        const pronunciationValue = pronunciationField ? pronunciationField.value.trim() : '';\r\n        // Determine the state based on the button's class\r\n        const state = snowflakeButton.classList.contains('assigned-frozen-config') ? 'frozen' : 'thawed';\r\n\r\n        // Push current values to usersToTrack\r\n        currentValues.usersToTrack.push({\r\n          name: usernameValue,\r\n          gender: genderValue,\r\n          pronunciation: pronunciationValue,\r\n          state\r\n        });\r\n      });\r\n\r\n      // Create a set of tracked usernames (case-insensitive)\r\n      const trackedNames = new Set(\r\n        currentValues.usersToTrack.map(user => user.name.toLowerCase())\r\n      );\r\n\r\n      // Process mention items\r\n      container.querySelectorAll('.settings-mention-container .mention-item').forEach(item => {\r\n        const mentionField = item.querySelector('.mention-field');\r\n        const mentionValue = mentionField ? mentionField.value.trim() : '';\r\n        currentValues.mentionKeywords.push(mentionValue);\r\n      });\r\n\r\n      // Process replacement items\r\n      container.querySelectorAll('.settings-replacement-container .replacement-item').forEach(item => {\r\n        const originalField = item.querySelector('.replacement-original-field');\r\n        const replacementField = item.querySelector('.replacement-field');\r\n        const originalValue = originalField ? originalField.value.trim() : '';\r\n        const replacementValue = replacementField ? replacementField.value.trim() : '';\r\n\r\n        // If the original value exists in tracked users, prevent creating a new replacement item.\r\n        if (trackedNames.has(originalValue.toLowerCase())) {\r\n          // Optionally, mark the field as invalid to notify the user.\r\n          originalField.classList.add('input-error');\r\n          addShakeEffect(originalField);\r\n          return; // Skip pushing this replacement item.\r\n        } else {\r\n          originalField.classList.remove('input-error');\r\n        }\r\n\r\n        currentValues.usernameReplacements.push({\r\n          original: originalValue,\r\n          replacement: replacementValue\r\n        });\r\n      });\r\n\r\n      // Process moderator\r\n      container.querySelectorAll('.settings-moderator-container .moderator-item').forEach(item => {\r\n        const moderatorField = item.querySelector('.moderator-field');\r\n        const moderatorValue = moderatorField ? moderatorField.value.trim() : '';\r\n        currentValues.moderator.push(moderatorValue);\r\n      });\r\n\r\n      // Process ignored items\r\n      container.querySelectorAll('.settings-ignored-container .ignored-item').forEach(item => {\r\n        const ignoredField = item.querySelector('.ignored-field');\r\n        const ignoredValue = ignoredField ? ignoredField.value.trim() : '';\r\n        currentValues.ignored.push(ignoredValue);\r\n      });\r\n\r\n      // Process toggle (yes/no) settings based on select elements within each toggle-setting item\r\n      container.querySelectorAll('.settings-toggle-container .toggle-item').forEach(item => {\r\n        const descriptionElement = item.querySelector('.toggle-description'); // Get the description element\r\n        const selectElement = item.querySelector('.toggle-select'); // Select the toggle (select) element within the current toggle-item\r\n        const selectedValue = selectElement ? selectElement.value.trim() : 'no'; // Default to 'no' if not selected\r\n\r\n        // Get the data-toggle-name attribute value from the descriptionElement\r\n        const toggleName = descriptionElement.getAttribute('data-toggle-name');\r\n\r\n        // Push the current toggle setting as an object into the toggle array\r\n        if (toggleName) {\r\n          currentValues.toggle.push({\r\n            name: toggleName, // Store the toggle name\r\n            option: selectedValue // Store the selected value directly\r\n          });\r\n        }\r\n      });\r\n\r\n      // Check if any values have changed compared to previous state\r\n      const valuesChanged = JSON.stringify(previousValues) !== JSON.stringify(currentValues);\r\n\r\n      // Show or hide the save button based on whether values have changed\r\n      valuesChanged ? showButton() : hideButton();\r\n\r\n      return currentValues; // Return current values for saving later\r\n    };\r\n\r\n    // Attach click event to save settings when there are changes\r\n    saveButton.addEventListener('click', () => {\r\n      const currentValues = handleInputChange(); // Get current values before saving\r\n      processUploadedSettings(currentValues); // Process and save the current settings\r\n      // Update previousValues to the current state after saving\r\n      Object.assign(previousValues, currentValues);\r\n      hideButton(); // Optionally hide the button after saving\r\n    });\r\n\r\n    // Add input listeners to existing fields\r\n    container.querySelectorAll('input, select').forEach(field => {\r\n      field.addEventListener('input', handleInputChange);\r\n    });\r\n\r\n    // Function to attach event listeners to dynamically added input and select elements\r\n    const attachEventListeners = (element) => {\r\n      if (element.tagName === 'INPUT' || element.tagName === 'SELECT') {\r\n        element.addEventListener('input', handleInputChange);\r\n        // console.log('Listener attached to:', element);\r\n      } else {\r\n        // Check its children for input or select elements\r\n        element.querySelectorAll('input, select').forEach((child) => {\r\n          child.addEventListener('input', handleInputChange);\r\n          // console.log('Listener attached to child:', child);\r\n        });\r\n      }\r\n    };\r\n\r\n    // Create a mutation observer to monitor changes in the target container\r\n    const observer = new MutationObserver((0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.debounce)((mutationsList) => {\r\n      mutationsList.forEach((mutation) => {\r\n        if (mutation.type === 'childList') {\r\n          mutation.addedNodes.forEach((node) => {\r\n            if (node.nodeType === Node.ELEMENT_NODE) {\r\n              // console.log('Added:', node);\r\n              attachEventListeners(node); // Attach event listeners to new elements\r\n            }\r\n          });\r\n\r\n          mutation.removedNodes.forEach((node) => {\r\n            if (node.nodeType === Node.ELEMENT_NODE) {\r\n              // console.log('Removed:', node);\r\n              handleInputChange(); // Call handleInputChange to check the state after any changes\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }, _definitions_js__WEBPACK_IMPORTED_MODULE_2__.debounceTimeout));\r\n\r\n    // Start observing the target container for child list changes\r\n    observer.observe(container, {\r\n      childList: true,\r\n      subtree: true, // Observe all descendants as well\r\n    });\r\n  }\r\n\r\n  // Create a hidden file input for importing settings\r\n  const importFileInput = document.createElement('input');\r\n  importFileInput.type = 'file';\r\n  importFileInput.accept = '.json'; // Specify the file type\r\n  importFileInput.style.display = 'none'; // Hide the file input\r\n\r\n  // Add an event listener for the import file input\r\n  importFileInput.addEventListener('change', async (event) => {\r\n    await handleUploadSettings(event); // Wait for processing uploaded settings\r\n    // Clear the containers before populating new data\r\n    clearSettingsContainers();\r\n    // Populate the UI with updated settings\r\n    populateSettings();\r\n  });\r\n\r\n  // Function to clear the content of settings containers\r\n  function clearSettingsContainers() {\r\n    const containers = [\r\n      '.settings-tracked-container',\r\n      '.settings-mention-container',\r\n      '.settings-replacement-container',\r\n      '.settings-moderator-container',\r\n      '.settings-ignored-container',\r\n      '.settings-toggle-container'\r\n    ];\r\n\r\n    containers.forEach(selector => {\r\n      const container = document.querySelector(selector);\r\n      if (container) container.replaceChildren(); // Clear the container\r\n\r\n      const addButton = container.querySelector('.add-settings-button');\r\n      // Re-add the .add-settings-button if it was found\r\n      addButton && container.appendChild(addButton);\r\n    });\r\n  }\r\n\r\n  // Add a click event listener to the import button\r\n  importSettingsButton.addEventListener('click', () => {\r\n    importFileInput.click(); // Trigger file input click\r\n  });\r\n\r\n  // Append the file input to the import button\r\n  importSettingsButton.appendChild(importFileInput);\r\n\r\n  // Create an export button with the provided SVG icon\r\n  const exportSettingsButton = document.createElement('div');\r\n  exportSettingsButton.className = \"large-button panel-header-export-button\";\r\n  exportSettingsButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.exportSVG;\r\n  exportSettingsButton.title = 'Export settings';\r\n\r\n  // Example of how to use the getSettingsData function in the export event\r\n  exportSettingsButton.addEventListener('click', function () {\r\n    const settingsData = getSettingsData(); // Retrieve the settings data\r\n    handleDownloadSettings(settingsData); // Pass the retrieved settings data to the download function\r\n  });\r\n\r\n  // Append the buttons to the panel header container\r\n  panelControlButtons.appendChild(saveSettingsButton);\r\n  panelControlButtons.appendChild(importSettingsButton);\r\n  panelControlButtons.appendChild(exportSettingsButton);\r\n  panelControlButtons.appendChild(clearCacheButton);\r\n  panelControlButtons.appendChild(closePanelButton);\r\n\r\n  panelHeaderContainer.appendChild(panelControlButtons);\r\n\r\n  settingsPanel.appendChild(panelHeaderContainer);\r\n\r\n  // Create a container for the settings content\r\n  const settingsContainer = document.createElement('div');\r\n  settingsContainer.className = 'settings-content-container';\r\n\r\n  // Array of settings types with corresponding emoji\r\n  const settingsTypes = [\r\n    { type: 'tracked', emoji: '' },\r\n    { type: 'mention', emoji: '' },\r\n    { type: 'replacement', emoji: '' },\r\n    { type: 'moderator', emoji: '' },\r\n    { type: 'ignored', emoji: '' },\r\n    { type: 'toggle', emoji: '' }\r\n  ];\r\n\r\n  settingsTypes.forEach(({ type, emoji }) => {\r\n    const description = document.createElement('div');\r\n    description.className = `settings-${type}-description settings-description`; // Add specific class and settings-description\r\n\r\n    // Create the description container directly\r\n    const container = document.createElement('div');\r\n    container.className = `settings-${type}-container`;\r\n\r\n    // Set the text content with first letter capitalized and append emoji\r\n    description.textContent = `${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} ${emoji}`;\r\n\r\n    settingsContainer.appendChild(description);\r\n    settingsContainer.appendChild(container);\r\n  });\r\n\r\n  // Append the settings content container to the settings panel\r\n  settingsPanel.appendChild(settingsContainer);\r\n\r\n  // Applies common styles to a select element and its options\r\n  function styleSelect(select) {\r\n    select.style.height = '30px';\r\n    select.style.maxWidth = '120px';\r\n    select.style.minWidth = '105px';\r\n    select.style.padding = '0.4em';\r\n    select.style.font = '1em Montserrat';\r\n    select.style.fontFamily = 'Montserrat';\r\n    select.style.setProperty('color', 'bisque', 'important');\r\n    select.style.setProperty('border-radius', '0.2em', 'important');\r\n    select.style.boxSizing = 'border-box';\r\n    select.style.setProperty('background-color', 'rgb(17,17,17)', 'important');\r\n    select.style.setProperty('border', '1px solid rgb(34,34,34)', 'important');\r\n\r\n    // Style each option element\r\n    Array.from(select.options).forEach(option => {\r\n      option.style.height = '30px';\r\n      option.style.setProperty('background-color', 'rgb(17,17,17)', 'important');\r\n      option.style.setProperty('color', 'bisque', 'important');\r\n      option.style.fontFamily = 'Montserrat';\r\n    });\r\n  }\r\n\r\n  // Common function to attach click event for removing an item\r\n  function attachRemoveListener(removeButton, item) {\r\n    removeButton.addEventListener('click', () => {\r\n      item.remove(); // Remove the parent element\r\n    });\r\n  }\r\n\r\n  // Function to attach click event for toggling between \"assigned-thawed-config\" and \"assigned-frozen-config\"\r\n  function attachSnowflakeListener(snowflakeButton, username) {\r\n    snowflakeButton.addEventListener('click', () => {\r\n      const isFrozen = snowflakeButton.classList.toggle('assigned-frozen-config');\r\n      snowflakeButton.classList.toggle('assigned-thawed-config');\r\n\r\n      // Set opacity based on the assigned class\r\n      snowflakeButton.style.opacity = isFrozen ? '1' : '0.3';\r\n\r\n      // Update localStorage using the helper function\r\n      updateUserState(username, isFrozen ? 'frozen' : 'thawed');\r\n    });\r\n  }\r\n\r\n  // Helper function to create a container element\r\n  function createContainer(type, layout = 'inline-flex') {\r\n    const item = document.createElement('div');\r\n    item.className = `${type}-item`;\r\n    item.style.display = layout;\r\n    item.style.gap = '0.5em';\r\n    item.style.padding = '0.25em';\r\n    return item;\r\n  }\r\n\r\n  // Helper function to create an input element\r\n  function createInput(type, value = '', placeholder = '') {\r\n    const input = document.createElement('input');\r\n    input.className = `settings-field ${type}-field`;\r\n    input.value = value;\r\n    input.placeholder = placeholder;\r\n    return input;\r\n  }\r\n\r\n  // Helper function to create a remove button with styles and event listener\r\n  function createRemoveButton(type, item) {\r\n    const removeButton = document.createElement('div');\r\n    removeButton.className = `settings-button remove-settings-button remove-${type}-word`;\r\n    removeButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.removeSVG;\r\n    attachRemoveListener(removeButton, item);\r\n    return removeButton;\r\n  }\r\n\r\n  // Helper function to create a snowflake button with styles and event listener\r\n  function createSnowflakeButton(state = 'thawed', username) {\r\n    const snowflakeButton = document.createElement('div');\r\n    snowflakeButton.className = `settings-button assigned-settings-button assigned-${state}-config`;\r\n\r\n    // Set initial opacity based on the state\r\n    snowflakeButton.style.opacity = state === 'thawed' ? '0.3' : '1';\r\n    snowflakeButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.snowflakeSVG;\r\n\r\n    attachSnowflakeListener(snowflakeButton, username); // Pass username here\r\n    return snowflakeButton;\r\n  }\r\n\r\n  // Function to update a specific user in localStorage to add the state property\r\n  function updateUserState(username, state) {\r\n    const usersData = localStorage.getItem(\"usersToTrack\");\r\n    if (usersData) {\r\n      const updatedUsers = JSON.parse(usersData).map(user =>\r\n        user.name === username ? { ...user, state } : user\r\n      );\r\n      localStorage.setItem(\"usersToTrack\", JSON.stringify(updatedUsers));\r\n    }\r\n  }\r\n\r\n  // Function to create a spoiler container (as provided)\r\n  function createSpoilerContainer(contentElement, options = {}) {\r\n    const container = document.createElement('div');\r\n    container.classList.add(\"settings-spoiler\");\r\n    const toggleButton = document.createElement('button');\r\n\r\n    toggleButton.textContent = options.showText || 'Show Content';\r\n\r\n    contentElement.style.display = 'none';\r\n\r\n    toggleButton.addEventListener('click', () => {\r\n      const isHidden = contentElement.style.display === 'none';\r\n      contentElement.style.display = isHidden ? 'flex' : 'none';\r\n      toggleButton.textContent = isHidden\r\n        ? (options.hideText || 'Hide Content')\r\n        : (options.showText || 'Show Content');\r\n    });\r\n\r\n    container.appendChild(toggleButton);\r\n    container.appendChild(contentElement);\r\n\r\n    return container;\r\n  }\r\n\r\n  // Function to create a tracked item (with gender select)\r\n  function createTrackedItem(user) {\r\n    const item = createContainer('tracked', 'flex');\r\n\r\n    const usernameInput = createInput('tracked-username', user.name, 'Username');\r\n    const pronunciationInput = createInput('tracked-pronunciation', user.pronunciation, 'Pronunciation');\r\n    const removeButton = createRemoveButton('tracked', item);\r\n\r\n    // Set the initial state based on the user's state property, defaulting to 'thawed' if it doesn't exist\r\n    const initialState = (user.state === 'frozen') ? 'frozen' : 'thawed';\r\n    const snowflakeButton = createSnowflakeButton(initialState, user.name); // Pass username\r\n\r\n    const genderSelect = document.createElement('select');\r\n    genderSelect.className = 'tracked-gender-select';\r\n    const genders = [\r\n      { value: 'Male', emoji: '' },\r\n      { value: 'Female', emoji: '' },\r\n    ];\r\n    genders.forEach(({ value, emoji }) => {\r\n      const option = document.createElement('option');\r\n      option.value = value;\r\n      option.textContent = `${emoji} ${value}`;\r\n      if (user.gender === value) option.selected = true;\r\n      genderSelect.appendChild(option);\r\n    });\r\n    styleSelect(genderSelect);\r\n\r\n    item.appendChild(usernameInput);\r\n    item.appendChild(genderSelect);\r\n    item.appendChild(pronunciationInput);\r\n    item.appendChild(removeButton);\r\n    item.appendChild(snowflakeButton);\r\n\r\n    return item;\r\n  }\r\n\r\n  // Function to create a mention item\r\n  function createMentionItem(keyword) {\r\n    const item = createContainer('mention');\r\n    const mentionInput = createInput('mention', keyword, 'Mention Keyword');\r\n    const removeButton = createRemoveButton('mention', item);\r\n\r\n    item.appendChild(mentionInput);\r\n    item.appendChild(removeButton);\r\n\r\n    return item;\r\n  }\r\n\r\n  // Function to create a username replacement item for text to speech API\r\n  function createReplacementItem(replacement = { original: '', replacement: '' }) {\r\n    const item = createContainer('replacement');\r\n    const originalInput = createInput('replacement-original', replacement.original, 'Original username');\r\n    const replacementInput = createInput('replacement', replacement.replacement, 'Replacement name');\r\n    const removeButton = createRemoveButton('replacement', item);\r\n\r\n    item.appendChild(originalInput);\r\n    item.appendChild(replacementInput);\r\n    item.appendChild(removeButton);\r\n\r\n    return item;\r\n  }\r\n\r\n  // Function to create a moderator item\r\n  function createModeratorItem(moderator) {\r\n    const item = createContainer('moderator');\r\n    const moderatorInput = createInput('moderator', moderator, 'Moderator Name');\r\n    const removeButton = createRemoveButton('moderator', item);\r\n\r\n    item.appendChild(moderatorInput);\r\n    item.appendChild(removeButton);\r\n\r\n    return item;\r\n  }\r\n\r\n  // Function to create an ignored item\r\n  function createIgnoredItem(user) {\r\n    const item = createContainer('ignored');\r\n    const ignoredInput = createInput('ignored', user, 'Ignored User');\r\n    const removeButton = createRemoveButton('ignored', item);\r\n\r\n    item.appendChild(ignoredInput);\r\n    item.appendChild(removeButton);\r\n\r\n    return item;\r\n  }\r\n\r\n  // Function to create a toggle item with a description and select for yes/no options\r\n  function createToggleItem(toggle, name, optionValue) {\r\n    const item = createContainer('toggle', 'flex');\r\n    item.style.alignItems = 'center';\r\n\r\n    // Create the select element for yes/no\r\n    const select = document.createElement('select');\r\n    select.className = 'toggle-select';\r\n\r\n    // Create the description element\r\n    const description = document.createElement('span');\r\n    description.className = 'toggle-description';\r\n    description.innerText = toggle.description;\r\n    // Set the custom data attribute for the setting using the name parameter\r\n    description.setAttribute('data-toggle-name', name); // Set data-toggle-name to the name parameter\r\n\r\n    // Add click event to open the image in a new tab\r\n    description.style.cursor = 'pointer'; // Add pointer cursor to indicate it's clickable\r\n    description.style.color = 'burlywood';\r\n    description.style.transition = 'color 0.15s ease-in-out';\r\n\r\n    description.addEventListener('click', () => {\r\n      if (toggle.image) {\r\n        window.open(toggle.image, '_blank'); // Open the image in a new tab\r\n      }\r\n    });\r\n\r\n    // Compact mouseover and mouseout events\r\n    description.addEventListener('mouseover', function () { description.style.color = 'lightgoldenrodyellow'; })\r\n    description.addEventListener('mouseout', function () { description.style.color = 'burlywood'; });\r\n\r\n    // Define options with emojis for yes and no\r\n    const options = [\r\n      { value: 'yes', emoji: '' },\r\n      { value: 'no', emoji: '' }\r\n    ];\r\n\r\n    // Create options for the select element\r\n    options.forEach(({ value, emoji }) => {\r\n      const option = document.createElement('option');\r\n      option.value = value;\r\n      option.textContent = `${emoji} ${value}`; // Format text as \" yes\" or \" no\"\r\n      select.appendChild(option);\r\n    });\r\n\r\n    // Set the initial value of the select based on the optionValue parameter\r\n    select.value = optionValue; // Assign the optionValue to the select element\r\n\r\n    // Style the select element\r\n    styleSelect(select); // Call the styling function\r\n\r\n    // Append the description and select to the toggle item\r\n    item.appendChild(select);\r\n    item.appendChild(description);\r\n\r\n    return item; // Return the created toggle item\r\n  }\r\n\r\n  function populateSettings() {\r\n    const containers = {\r\n      usersToTrack: '.settings-tracked-container',\r\n      mentionKeywords: '.settings-mention-container',\r\n      usernameReplacements: '.settings-replacement-container',\r\n      moderator: '.settings-moderator-container',\r\n      ignored: '.settings-ignored-container'\r\n    };\r\n\r\n    const creators = {\r\n      usersToTrack: { name: 'tracked', createItem: createTrackedItem },\r\n      mentionKeywords: { name: 'mention', createItem: createMentionItem },\r\n      usernameReplacements: { name: 'replacement', createItem: createReplacementItem },\r\n      moderator: { name: 'moderator', createItem: createModeratorItem },\r\n      ignored: { name: 'ignored', createItem: createIgnoredItem }\r\n    };\r\n\r\n    const data = getSettingsData();\r\n\r\n    Object.entries(data).forEach(([key, items]) => {\r\n      const container = document.querySelector(containers[key]);\r\n      if (!container) return;\r\n      container.classList.add(\"settings-container\");\r\n\r\n      if (key === 'mentionKeywords' || key === 'moderator' || key === 'ignored') {\r\n        container.style.flexDirection = 'row';\r\n      }\r\n\r\n      // Clear existing items and add buttons, but ensure the add button is not removed\r\n      const existingAddButton = container.querySelector('.add-settings-button');\r\n      while (container.firstChild) {\r\n        if (container.firstChild !== existingAddButton) {\r\n          container.removeChild(container.firstChild);\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Populate items\r\n      items.forEach(item => container.appendChild(creators[key].createItem(item)));\r\n\r\n      const addButton = createAddButton(containers[key], creators[key].createItem);\r\n      container.appendChild(addButton);\r\n\r\n      // Check if already wrapped in a spoiler\r\n      const isAlreadyWrapped = container.closest('.settings-spoiler') !== null;\r\n\r\n      if (!isAlreadyWrapped) {\r\n        const parent = container.parentNode;\r\n        if (parent) {\r\n          const index = Array.from(parent.childNodes).indexOf(container);\r\n          parent.removeChild(container);\r\n          const spoiler = createSpoilerContainer(container, {\r\n            showText: `Show ${creators[key].name} settings`,\r\n            hideText: `Hide ${creators[key].name} settings`\r\n          });\r\n          spoiler.classList.add('settings-spoiler-wrapper');\r\n          if (index >= parent.childNodes.length) {\r\n            parent.appendChild(spoiler);\r\n          } else {\r\n            parent.insertBefore(spoiler, parent.childNodes[index]);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Process toggle settings separately\r\n    const storedToggleSettings = JSON.parse(localStorage.getItem('toggle')) || [];\r\n    const toggleContainer = document.querySelector('.settings-toggle-container');\r\n    const toggleSettings = [\r\n      {\r\n        name: 'showChatStaticNotifications',\r\n        description: ' Show chat static notifications',\r\n        image: 'https://i.imgur.com/oUPSi9I.jpeg'\r\n      },\r\n      {\r\n        name: 'showGlobalDynamicNotifications',\r\n        description: ' Show global dynamic notifications',\r\n        image: 'https://i.imgur.com/8ffCdUG.jpeg'\r\n      },\r\n      {\r\n        name: 'enabledBeepOnChatJoinLeave',\r\n        description: ' Play a beep sound and speak feedback when the user enters or leaves the chat',\r\n        image: 'https://i.imgur.com/6PXFIES.jpeg'\r\n      },\r\n      {\r\n        name: 'switchToGoogleTTSEngine',\r\n        description: ' Switch to google TTS engine if available',\r\n        image: 'https://i.imgur.com/0H94LII.jpeg'\r\n      }\r\n    ];\r\n\r\n    toggleSettings.forEach(toggle => {\r\n      const storedSetting = storedToggleSettings.find(item => item.name === toggle.name);\r\n      const optionValue = storedSetting ? storedSetting.option : 'yes';\r\n      const toggleItem = createToggleItem(toggle, toggle.name, optionValue);\r\n      toggleContainer.appendChild(toggleItem);\r\n    });\r\n  }\r\n\r\n  // Function to create an \"Add\" button for dynamic item creation\r\n  function createAddButton(containerSelector, itemCreator) {\r\n    const middleWord = containerSelector.split('-')[1]; // Extract key type (e.g., tracked, mention)\r\n    const existingButton = document.querySelector(`.add-${middleWord}-item`); // Check if the button already exists\r\n    // If the button exists, remove it\r\n    if (existingButton) existingButton.remove();\r\n\r\n    const addButton = document.createElement('div');\r\n    // Set class, content, and style for the button\r\n    addButton.className = `settings-button add-settings-button add-${middleWord}-item`;\r\n    addButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.addSVG; // Add SVG icon to the button\r\n    addButton.style.margin = '0.4em';\r\n\r\n    // On click, validate the last item and create a new one if valid\r\n    addButton.addEventListener('click', () => {\r\n      const container = document.querySelector(containerSelector); // Get the container element\r\n\r\n      // Get all settings {type} items and select the last one\r\n      const allItems = container.querySelectorAll(`.${middleWord}-item`);\r\n      const lastItem = allItems.length > 0 ? allItems[allItems.length - 1] : null;\r\n\r\n      // Check if the last item has any input fields\r\n      const inputFields = lastItem ? lastItem.querySelectorAll('input') : []; // Get all input fields in the last item\r\n      const hasEmptyFields = Array.from(inputFields).some(field => field.value.trim().length === 0); // Check for empty fields\r\n\r\n      // Allow creation only if the last item has no empty fields (or if there are no items yet)\r\n      const canCreateNewItem = !lastItem || !hasEmptyFields;\r\n\r\n      if (canCreateNewItem) {\r\n        // Create a new empty item based on the item creator function\r\n        const emptyItem = itemCreator === createTrackedItem\r\n          ? itemCreator({ name: '', pronunciation: '' }) // Remove gender from tracked item creation\r\n          : itemCreator('');\r\n\r\n        // Check if the new item is a valid HTMLElement before inserting\r\n        if (emptyItem instanceof HTMLElement) {\r\n          container.insertBefore(emptyItem, addButton); // Insert the new item before the Add button\r\n        } else {\r\n          console.error('Invalid item created.'); // Log an error if the item is not valid\r\n        }\r\n      } else {\r\n        // Alert the user if the last item is filled\r\n        alert('Please fill in the previous item before adding a new one.');\r\n      }\r\n    });\r\n\r\n    return addButton; // Return the created button\r\n  }\r\n\r\n  // Create and append scroll buttons\r\n  const { scrollButtonsContainer } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.createScrollButtons)(settingsContainer);\r\n  settingsPanel.appendChild(scrollButtonsContainer);\r\n\r\n  // Append the settings panel to the body\r\n  document.body.appendChild(settingsPanel);\r\n\r\n  // Call the function to populate settings on page load\r\n  populateSettings();\r\n\r\n  // Make save button work as expected\r\n  initializeSaveButtonLogic(saveSettingsButton);\r\n\r\n  // Fade in the settings panel and dimming background element\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerTargetElement)(settingsPanel, 'show');\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerDimmingElement)('show');\r\n}\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/settings.js?");

/***/ }),

/***/ "./src/modules/tooltip.js":
/*!********************************!*\
  !*** ./src/modules/tooltip.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCustomTooltip: () => (/* binding */ createCustomTooltip)\n/* harmony export */ });\nlet tooltipInstance = null;\r\nlet tooltipHideTimeout = null;\r\nlet tooltipShowTimeout = null;\r\nlet isTooltipVisible = false;\r\nlet isTooltipShown = false;\r\nlet currentElement = null;\r\n\r\nconst tooltipMousemoveHandler = (e) => {\r\n  if (tooltipInstance) {\r\n    tooltipInstance.style.left = `${e.clientX + 0}px`;\r\n    tooltipInstance.style.top = `${e.clientY + 18}px`;\r\n  }\r\n};\r\n\r\n// Global hide function\r\nconst hideTooltip = () => {\r\n  isTooltipVisible = false;\r\n  currentElement = null;\r\n  clearTimeout(tooltipShowTimeout);\r\n  tooltipShowTimeout = null;\r\n\r\n  clearTimeout(tooltipHideTimeout);\r\n  tooltipHideTimeout = setTimeout(() => {\r\n    if (tooltipInstance) {\r\n      tooltipInstance.style.opacity = '0';\r\n      isTooltipShown = false;\r\n      setTimeout(() => {\r\n        if (!isTooltipVisible && tooltipInstance) {\r\n          tooltipInstance.style.display = 'none';\r\n          document.removeEventListener('mousemove', tooltipMousemoveHandler);\r\n        }\r\n      }, 50);\r\n    }\r\n  }, 100);\r\n};\r\n\r\n// MutationObserver to check element removal\r\nconst observer = new MutationObserver(() => {\r\n  if (currentElement && !document.contains(currentElement)) {\r\n    hideTooltip();\r\n  }\r\n});\r\nobserver.observe(document, { childList: true, subtree: true });\r\n\r\nfunction createCustomTooltip(element, tooltipText) {\r\n  if (element.classList.contains('events-included')) return;\r\n  element.classList.add('events-included');\r\n\r\n  tooltipInstance ||= (() => {\r\n    const tooltipElement = document.createElement('div');\r\n    tooltipElement.classList.add(\"custom-tooltip-popup\");\r\n    document.body.appendChild(tooltipElement);\r\n    return tooltipElement;\r\n  })();\r\n\r\n  const showTooltip = (e) => {\r\n    isTooltipVisible = true;\r\n    currentElement = element;\r\n    clearTimeout(tooltipShowTimeout);\r\n    clearTimeout(tooltipHideTimeout);\r\n    tooltipInstance.textContent = tooltipText;\r\n\r\n    document.addEventListener('mousemove', tooltipMousemoveHandler);\r\n    tooltipMousemoveHandler(e);\r\n\r\n    if (!isTooltipShown) {\r\n      tooltipShowTimeout = setTimeout(() => {\r\n        tooltipInstance.style.display = 'flex';\r\n        tooltipInstance.style.opacity = '1';\r\n        isTooltipShown = true;\r\n      }, 600);\r\n    }\r\n  };\r\n\r\n  element.addEventListener('mouseenter', showTooltip);\r\n  element.addEventListener('mouseleave', hideTooltip);\r\n}\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/tooltip.js?");

/***/ }),

/***/ "./src/modules/video-converter.js":
/*!****************************************!*\
  !*** ./src/modules/video-converter.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertVideoLinksToPlayer: () => (/* binding */ convertVideoLinksToPlayer)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/modules/helpers.js\");\n// helpers\r\n\r\n\r\nconst videoExtensionEmoji = '';\r\nconst webDomainEmoji = '';\r\nconst untrustedEoji = '';\r\n\r\n// List of allowed video extensions\r\nconst allowedVideoExtensions = ['mp4', 'webm', 'ogg', 'mov', 'avi'];\r\n\r\n/**\r\n * Checks if a given URL has an allowed video extension.\r\n * @param {string} url - The URL to check.\r\n * @returns {{allowed: boolean, extension: string}} - Indicates if the extension is allowed and returns the extension.\r\n */\r\nfunction isAllowedVideoExtension(url) {\r\n  // Shared extension extraction logic\r\n  const getExtension = (str) =>\r\n    (str.match(/\\.([^?#.]+)(?:[?#]|$)/i)?.[1]?.toLowerCase() || '');\r\n\r\n  try {\r\n    const extension = getExtension(url);\r\n    return {\r\n      allowed: allowedVideoExtensions.includes(extension),\r\n      extension\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Error in isAllowedVideoExtension:\", error.message);\r\n    return {\r\n      allowed: false,\r\n      extension: getExtension(String(url)) // Handle non-string URLs\r\n    };\r\n  }\r\n}\r\n\r\nfunction convertVideoLinksToPlayer(containerType) {\r\n  // Define container selectors for different message types\r\n  const containerSelectors = {\r\n    generalMessages: '.messages-content div',\r\n    chatlogsMessages: '.chat-logs-container',\r\n    personalMessages: '.messages-container-wrapper'\r\n  };\r\n\r\n  // Get the container selector based on the provided type\r\n  const containerSelector = containerSelectors[containerType];\r\n  if (!containerSelector) {\r\n    console.error('Invalid container type specified');\r\n    return;\r\n  }\r\n\r\n  // Select the container element\r\n  const container = document.querySelector(containerSelector);\r\n  if (!container) return;\r\n\r\n  // Find all unprocessed links inside the container\r\n  const links = container.querySelectorAll(\"a:not(.skipped):not(.processed-video)\");\r\n  if (!links.length) return;\r\n\r\n  links.forEach(link => {\r\n    const url = link.href;\r\n    if (!url) return;\r\n\r\n    // Get video details using our helper function\r\n    const videoInfo = getVideoInfo(url);\r\n    if (!videoInfo) return;\r\n\r\n    // Add media class if youtube or video\r\n    link.classList.add(\"media\");\r\n\r\n    // Check if the link's href includes a trusted domain\r\n    const { isTrusted, domain } = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isTrustedDomain)(url);\r\n\r\n    // For untrusted domains, add classes and update text before waiting for a click\r\n    if (!isTrusted) {\r\n      link.classList.add(\"skipped\");\r\n      link.textContent = `${videoExtensionEmoji} ${videoInfo.videoType} ${webDomainEmoji} Hostname (${domain}) ${untrustedEoji} Untrusted`;\r\n      link.addEventListener(\"click\", e => {\r\n        if (!link.classList.contains(\"processed-video\")) {\r\n          e.preventDefault();\r\n          link.classList.remove(\"skipped\");\r\n          processVideoLink(link, url, domain, videoInfo);\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    // For trusted links, process immediately\r\n    processVideoLink(link, url, domain, videoInfo);\r\n  });\r\n\r\n  function processVideoLink(link, url, domain, videoInfo) {\r\n    const { youtubeMatch, videoType, videoId } = videoInfo;\r\n    // Use the helper function to check for allowed video extensions\r\n    const videoCheck = isAllowedVideoExtension(url);\r\n    if (!youtubeMatch && !videoCheck.allowed) return;\r\n\r\n    // Add media and processed-video classes (if not already added)\r\n    link.classList.add(\"processed-video\");\r\n\r\n    // Create a wrapper div for better structure\r\n    const wrapper = document.createElement('div');\r\n    wrapper.classList.add(\"video-wrapper\");\r\n\r\n    // Create an appropriate embed element (iframe for YouTube, video for allowed formats)\r\n    let embedElement = document.createElement(youtubeMatch ? 'iframe' : 'video');\r\n    embedElement.classList.add(\"video-container\");\r\n\r\n    if (youtubeMatch) {\r\n      // Update link text and set YouTube embed\r\n      link.textContent = `${videoExtensionEmoji} ${videoType} ${webDomainEmoji} Hostname (${domain})`;\r\n      embedElement.src = `https://www.youtube.com/embed/${videoId}`;\r\n      embedElement.allowFullscreen = true;\r\n    } else {\r\n      // Update link text for MP4 videos\r\n      link.textContent = `${videoExtensionEmoji} ${videoType} ${webDomainEmoji} Hostname (${domain})`;\r\n      embedElement.src = url;\r\n      embedElement.controls = true;\r\n    }\r\n\r\n    // Set link attributes and insert elements\r\n    link.title = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isValidEncodedURL)(url) ? (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.decodeURL)(url) : url;\r\n    link.style.display = 'inline-flex';\r\n    link.parentNode.insertBefore(wrapper, link);\r\n    wrapper.append(link, embedElement);\r\n\r\n    // Scroll to the bottom of the container after processing links\r\n    (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.scrollMessagesToBottom)(containerType);\r\n  }\r\n\r\n  // Helper function to get video information based on the URL\r\n  function getVideoInfo(url) {\r\n    const youtubeMatch = url.match(/(?:shorts\\/|live\\/|watch\\?v=|youtu\\.be\\/)([a-zA-Z0-9_-]{11})/i);\r\n\r\n    if (youtubeMatch) {\r\n      const videoId = youtubeMatch[1];\r\n      const videoType = url.includes('shorts/') ? 'Shorts' :\r\n        url.includes('live/') ? 'Live' :\r\n          url.includes('watch?v=') ? 'Watch' :\r\n            url.includes('youtu.be/') ? 'Share' : 'YouTube';\r\n      return { youtubeMatch: true, videoId, videoType };\r\n    }\r\n\r\n    // Check if it's an MP4 or other video format\r\n    const extension = url.split('.').pop().toLowerCase();\r\n    if (allowedVideoExtensions.includes(extension)) {\r\n      return { youtubeMatch: false, videoType: `Video (${extension.toUpperCase()})` };\r\n    }\r\n\r\n    return false; // Return false if no match\r\n  }\r\n}\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/video-converter.js?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ \"./node_modules/css-loader/dist/cjs.js!./src/style.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/style.css?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;