// ==UserScript==
// @name         KG_Chat_Empowerment
// @namespace    klavogonki
// @version      1.0.0
// @description  Enhance the chat abilities
// @author       Patcher
// @match        *://klavogonki.ru/g*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=klavogonki.ru
// @updateURL    https://raw.githubusercontent.com/VimiummuimiV/KG_Goddies/refs/heads/master/KG_Chat_Empowerment.js
// @downloadURL  https://raw.githubusercontent.com/VimiummuimiV/KG_Goddies/refs/heads/master/KG_Chat_Empowerment.js
// @grant        none
// ==/UserScript==

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.empowerment-button {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  width: 48px;\r\n  height: 48px;\r\n  cursor: pointer;\r\n  margin: 4px;\r\n  background-color: #212226;\r\n  border: 1px solid #45474b;\r\n}\r\n\r\n/* input error indication */\r\n.input-error {\r\n  transition: background-color 300ms ease-in-out;\r\n  background-color: #6b2f2f !important;\r\n}\r\n\r\n/* chat length popup on field type with dynamic movement horizontally */\r\n.length-field-popup {\r\n  position: absolute;\r\n  font: bold 12px Montserrat;\r\n  bottom: 40px;\r\n  transition: left 100ms ease-out;\r\n  height: 20px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  padding: 2px 4px;\r\n  margin: 2px;\r\n  opacity: 0;\r\n}\r\n\r\n.bounce-in {\r\n  animation: bounceIn 500ms forwards;\r\n}\r\n\r\n@keyframes bounceIn {\r\n  0% {\r\n    transform: translateY(0);\r\n    opacity: 0;\r\n  }\r\n\r\n  50% {\r\n    transform: translateY(-10px);\r\n    opacity: 1;\r\n  }\r\n\r\n  100% {\r\n    transform: translateY(0);\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n.bounce-out {\r\n  animation: bounceOut 500ms forwards;\r\n}\r\n\r\n@keyframes bounceOut {\r\n  0% {\r\n    transform: translateY(0);\r\n    opacity: 1;\r\n  }\r\n\r\n  50% {\r\n    transform: translateY(-10px);\r\n    opacity: 1;\r\n  }\r\n\r\n  100% {\r\n    transform: translateY(0);\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n/* catalogs panel && personal messages panel messages anchors color */\r\n.chat-logs-panel .message-text a,\r\n.cached-messages-panel .message-text a {\r\n  color: burlywood !important;\r\n  transition: color 0.15s ease-in-out;\r\n}\r\n\r\n.chat-logs-panel .message-text a:hover,\r\n.cached-messages-panel .message-text a:hover {\r\n  color: lightgoldenrodyellow !important;\r\n}\r\n\r\n/* Empowerment panel */\r\n.empowerment-panel {\r\n  position: fixed;\r\n  top: 60px;\r\n  right: 12px;\r\n  padding: 6px;\r\n  z-index: 1000;\r\n}\r\n\r\n/* Chat user count element */\r\n.chat-user-count {\r\n  filter: grayscale(100%);\r\n  transition: 0.2s ease-in-out;\r\n  font-family: 'Orbitron', sans-serif;\r\n  font-size: 24px;\r\n  color: #83cf40;\r\n  background-color: #2b4317;\r\n  width: 48px;\r\n  height: 48px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border: 1px solid #4b7328;\r\n  margin: 4px;\r\n}\r\n\r\n.pulse-effect {\r\n  animation: pulse 500ms ease-out;\r\n}\r\n\r\n@keyframes pulse {\r\n  0% {\r\n    filter: brightness(1);\r\n  }\r\n\r\n  50% {\r\n    filter: brightness(1.5);\r\n  }\r\n\r\n  100% {\r\n    filter: brightness(1);\r\n  }\r\n}\r\n\r\n.shake-effect {\r\n  animation: shake 500ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;\r\n}\r\n\r\n@keyframes shake {\r\n  0% {\r\n    transform: translateX(0);\r\n  }\r\n\r\n  10% {\r\n    transform: translateX(-4px);\r\n  }\r\n\r\n  20% {\r\n    transform: translateX(6px);\r\n  }\r\n\r\n  30% {\r\n    transform: translateX(-8px);\r\n  }\r\n\r\n  40% {\r\n    transform: translateX(8px);\r\n  }\r\n\r\n  50% {\r\n    transform: translateX(-6px);\r\n  }\r\n\r\n  60% {\r\n    transform: translateX(5px);\r\n  }\r\n\r\n  70% {\r\n    transform: translateX(-3px);\r\n  }\r\n\r\n  80% {\r\n    transform: translateX(2px);\r\n  }\r\n\r\n  90% {\r\n    transform: translateX(-1px);\r\n  }\r\n\r\n  100% {\r\n    transform: translateX(0);\r\n  }\r\n}\r\n\r\n.custom-tooltip-popup {\r\n  position: fixed;\r\n  background: rgb(22, 22, 22);\r\n  color: rgb(222, 222, 222);\r\n  padding: 0.5em;\r\n  z-index: 1200;\r\n  font-size: 0.9em;\r\n  pointer-events: none;\r\n  white-space: nowrap;\r\n  opacity: 0;\r\n  transition: opacity 0.1s;\r\n  display: none;\r\n  left: 0;\r\n  top: 0;\r\n  border: 1px solid rgb(60, 60, 60) !important;\r\n  border-radius: 4px !important;\r\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3) !important;\r\n}\r\n\r\n.static-chat-notification {\r\n  cursor: default;\r\n  white-space: nowrap;\r\n  padding: 8px;\r\n  display: inline-flex;\r\n  flex: auto;\r\n  justify-content: center;\r\n  margin: 4px;\r\n  font-size: 1em;\r\n  align-items: center;\r\n  border-radius: 4px !important;\r\n}\r\n\r\n.dynamic-chat-notifications-container {\r\n  z-index: 1000;\r\n  width: 0;\r\n  position: fixed;\r\n  display: flex;\r\n  flex-direction: column;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  padding-top: 160px;\r\n}\r\n\r\n.dynamic-chat-notification {\r\n  cursor: default;\r\n  white-space: nowrap;\r\n  position: relative;\r\n  align-items: center;\r\n  width: fit-content;\r\n  display: flex;\r\n  margin-bottom: 0.2em;\r\n  padding: 8px 16px 8px 12px;\r\n  border-radius: 0 4px 4px 0 !important;\r\n  left: 0;\r\n  transform: translateX(-100%);\r\n  opacity: 1;\r\n  transition: transform 0.3s cubic-bezier(0.83, 0, 0.17, 1), opacity 0.3s cubic-bezier(0.83, 0, 0.17, 1);\r\n}\r\n\r\n/* For both (static and dynamic) notifications */\r\n.user-enter {\r\n  color: hsl(100, 50%, 50%) !important;\r\n  background-color: hsl(100, 50%, 10%) !important;\r\n  outline: 1px solid hsl(100, 50%, 25%) !important;\r\n}\r\n\r\n.user-left {\r\n  color: hsl(0, 50%, 70%) !important;\r\n  background-color: hsl(0, 50%, 15%) !important;\r\n  outline: 1px solid hsl(0, 50%, 40%) !important;\r\n}\r\n\r\n/* convertImageLinksToImage */\r\n.clickable-thumbnail {\r\n  opacity: 1;\r\n  transition: opacity 0.15s ease-in-out;\r\n  border: none;\r\n  width: 6vw;\r\n  min-width: 100px;\r\n  max-height: 200px;\r\n  height: auto;\r\n  cursor: pointer;\r\n  background-color: transparent;\r\n  padding: 2px;\r\n  margin: 6px;\r\n  overflow-y: auto;\r\n}\r\n\r\n.clickable-thumbnail:hover {\r\n  opacity: 0.8;\r\n}\r\n\r\n.clickable-thumbnail img {\r\n  max-height: 100%;\r\n  max-width: 100%;\r\n  background-color: transparent;\r\n}\r\n\r\n.scaled-thumbnail {\r\n  top: 50%;\r\n  left: 50%;\r\n  transform-origin: center center;\r\n  transform: translate(-50%, -50%) scale(1);\r\n  position: fixed;\r\n  opacity: 0;\r\n  z-index: 999;\r\n  transform-origin: center center;\r\n  max-height: 90vh;\r\n  max-width: 90vw;\r\n  cursor: pointer;\r\n}\r\n\r\n/* convertVideoLinksToPlayer */\r\n.video-wrapper {\r\n  display: flex;\r\n  width: fit-content;\r\n  flex-direction: column;\r\n  gap: 6px;\r\n  margin-bottom: 10px;\r\n}\r\n\r\n.video-container {\r\n  display: flex;\r\n  border: none;\r\n  height: 165px;\r\n}\r\n\r\n/* Dimming element */\r\n.dimming-background {\r\n  background: black;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  position: fixed;\r\n  opacity: 0;\r\n  z-index: 998;\r\n}\r\n\r\n/* loadProfileIntoIframe */\r\n.profile-iframe-container {\r\n  opacity: 0;\r\n  border: none;\r\n  display: flex;\r\n  position: fixed;\r\n  z-index: 999;\r\n  width: 75vw;\r\n  min-width: 1000px;\r\n  height: 80vh;\r\n  top: 48.5vh;\r\n  left: 50vw;\r\n  transform: translate(-50%, -50%);\r\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08) !important;\r\n  border-radius: 0.6em !important;\r\n}\r\n\r\n.scroll-buttons-container {\r\n  display: flex;\r\n  justify-content: center;\r\n  grid-area: scroll;\r\n  flex-direction: column;\r\n  height: calc(100% - 1em);\r\n  padding: 1em;\r\n}\r\n\r\n.scroll-buttons-container .scroll-button {\r\n  margin: 0.25em 0;\r\n  background-color: rgba(222, 222, 222, 0.1);\r\n}\r\n\r\n/* Common styles for all panel header buttons */\r\n.large-button {\r\n  width: 48px;\r\n  height: 48px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  cursor: pointer;\r\n  border-radius: 0.2em !important;\r\n  filter: brightness(1);\r\n  transition: filter 0.3s ease, opacity 0.3s ease;\r\n}\r\n\r\n.large-button:hover {\r\n  filter: brightness(0.8);\r\n}\r\n\r\n.panel-control-buttons {\r\n  display: flex;\r\n}\r\n\r\n.panel-control-buttons>div:not(:first-child) {\r\n  margin-left: 0.5em;\r\n}\r\n\r\n/* Common background color for all panel header buttons */\r\n.panel-header-clear-button {\r\n  background-color: brown;\r\n}\r\n\r\n.panel-header-close-button {\r\n  background-color: darkolivegreen;\r\n}\r\n\r\n.panel-header-save-button {\r\n  display: none;\r\n  opacity: 0;\r\n  visibility: hidden;\r\n  background-color: #2f6b63;\r\n}\r\n\r\n.panel-header-import-button {\r\n  background-color: #502f6b;\r\n}\r\n\r\n.panel-header-export-button {\r\n  background-color: #2f4c6b;\r\n}\r\n\r\n.panel-header-copy-button,\r\n.panel-header-date-button {\r\n  background-color: steelblue;\r\n}\r\n\r\n.panel-header-toggle-button {\r\n  background-color: #144e9d;\r\n}\r\n\r\n.panel-header-toggle-media-messages {\r\n  background-color: darkslategray;\r\n}\r\n\r\n.toggle-mention-messages-button {\r\n  background-color: saddlebrown;\r\n}\r\n\r\n.panel-header-one-day-back-button,\r\n.panel-header-one-day-forward-button {\r\n  background-color: darkcyan;\r\n}\r\n\r\n.panel-header-shuffle-button {\r\n  background-color: darkslateblue;\r\n}\r\n\r\n/* New chat user list */\r\n#chat-general .userlist-content {\r\n  opacity: 0;\r\n}\r\n\r\n#chat-general .smile-tab {\r\n  position: relative;\r\n  z-index: 1;\r\n}\r\n\r\n.chat-user-list {\r\n  display: flex;\r\n  flex-direction: column;\r\n  position: absolute;\r\n  top: 20px;\r\n  padding-top: 8px;\r\n  width: 200px;\r\n  height: 94%;\r\n  overflow-y: auto;\r\n  overflow-x: hidden;\r\n}\r\n\r\n.chat-user-list [class^=\"rank-group\"] {\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.chat-user-list [class^=\"user\"] {\r\n  display: inline-flex;\r\n  margin: 2px 0;\r\n}\r\n\r\n.chat-user-list .avatar {\r\n  width: 24px;\r\n  height: 24px;\r\n  display: inline-flex;\r\n}\r\n\r\n.chat-user-list .avatar img,\r\n.fetched-users .avatar img {\r\n  transform-origin: left;\r\n  transition: transform 0.3s;\r\n}\r\n\r\n.chat-user-list .avatar img:hover,\r\n.fetched-users .avatar img:hover {\r\n  transform: scale(2);\r\n}\r\n\r\n.chat-user-list .name {\r\n  text-decoration: none;\r\n  display: inline-flex;\r\n  width: auto;\r\n  height: 24px;\r\n  line-height: 24px;\r\n  padding: 0 8px;\r\n  max-width: 124px;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n}\r\n\r\n.chat-user-list .name:hover {\r\n  text-decoration: underline;\r\n}\r\n\r\n.chat-user-list .profile,\r\n.chat-user-list .tracked,\r\n.chat-user-list .ignored,\r\n.chat-user-list .moderator {\r\n  display: inline-flex;\r\n  width: 24px;\r\n  height: 24px;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n/* Highlight for mention words */\r\n.mention {\r\n  display: inline-flex;\r\n  color: #83cf40;\r\n  font-family: Roboto Mono, monospace;\r\n  font-weight: bold;\r\n}\r\n\r\n/* Chat popup messages */\r\n.popup-messages-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: flex-end;\r\n  align-items: start;\r\n  user-select: none;\r\n  pointer-events: none;\r\n  position: fixed;\r\n  left: 0;\r\n  right: 0;\r\n  top: 50px;\r\n  bottom: 0;\r\n}\r\n\r\n.popup-chat-message {\r\n  display: flex;\r\n  align-items: center;\r\n  background-color: hsl(100, 50%, 10%);\r\n  position: relative;\r\n  max-width: 70vw;\r\n  border-radius: 0.2em !important;\r\n  color: hsl(100, 50%, 50%);\r\n  border: 1px solid hsl(100, 50%, 25%);\r\n  padding: 4px;\r\n  margin: 6px 15vw;\r\n  opacity: 0;\r\n  transform: translateY(20px);\r\n  transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;\r\n  animation: fadeIn 0.3s ease-in-out forwards;\r\n}\r\n\r\n@keyframes fadeIn {\r\n  from {\r\n    opacity: 0;\r\n    transform: translateY(20px);\r\n  }\r\n\r\n  to {\r\n    opacity: 1;\r\n    transform: translateY(0);\r\n  }\r\n}\r\n\r\n.popup-chat-message.fade-out {\r\n  animation: fadeOut 0.3s ease-in-out forwards;\r\n}\r\n\r\n@keyframes fadeOut {\r\n  from {\r\n    opacity: 1;\r\n    transform: translateY(0);\r\n  }\r\n\r\n  to {\r\n    opacity: 0;\r\n    transform: translateY(-20px);\r\n  }\r\n}\r\n\r\n.popup-chat-message>div {\r\n  padding: 2px;\r\n  display: flex;\r\n  font-family: 'Montserrat', sans-serif;\r\n}\r\n\r\n.popup-chat-message .time,\r\n.popup-chat-message .time-icon {\r\n  opacity: 0.7;\r\n}\r\n\r\n/* Empowerment voice settings (Ctrl + Alt) */\r\n.voice-settings {\r\n  position: absolute;\r\n  top: 65px;\r\n  right: 70px;\r\n  opacity: 0;\r\n  transition: opacity 0.3s ease;\r\n  font-family: Orbitron, sans-serif;\r\n}\r\n\r\n/* Basic styles for empowerment voice settings */\r\n.voice-value-info {\r\n  display: flex;\r\n  width: 100%;\r\n  justify-content: center;\r\n  margin-bottom: 6px;\r\n}\r\n\r\n/* voice speed */\r\n.voice-speed {\r\n  color: hsl(100, 50%, 50%);\r\n}\r\n\r\n.voice-speed-progress {\r\n  display: block;\r\n  width: 120px;\r\n  height: 12px;\r\n  background-color: hsl(90, 60%, 30%);\r\n}\r\n\r\n.voice-speed-progress-fill {\r\n  display: block;\r\n  height: 100%;\r\n  background-color: hsl(90, 60%, 50%);\r\n}\r\n\r\n/* voice pitch */\r\n.voice-pitch {\r\n  color: hsl(180, 60%, 50%);\r\n}\r\n\r\n.voice-pitch-progress {\r\n  display: block;\r\n  width: 120px;\r\n  height: 12px;\r\n  background-color: hsl(180, 60%, 30%);\r\n}\r\n\r\n.voice-pitch-progress-fill {\r\n  display: block;\r\n  height: 100%;\r\n  background-color: hsl(180, 60%, 50%);\r\n}\r\n\r\n/* showCachePanel */\r\n.cached-users-panel {\r\n  opacity: 0;\r\n  background-color: #1b1b1b;\r\n  border-radius: 0.6em !important;\r\n  position: fixed;\r\n  top: 100px;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  width: 80vw;\r\n  height: 80vh;\r\n  z-index: 999;\r\n  display: grid;\r\n  grid-template-columns: 1fr;\r\n  grid-template-rows: min-content;\r\n  grid-template-areas:\r\n    \"header header\"\r\n    \"cache scroll\";\r\n}\r\n\r\n.cached-users-panel .panel-header {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: space-between;\r\n  padding: 0.6em;\r\n  grid-area: header;\r\n}\r\n\r\n.cached-users-panel .drop-time {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  min-width: fit-content;\r\n}\r\n\r\n.cached-users-panel .drop-time-threshold-description {\r\n  padding: 0.6em;\r\n  color: #c6b209;\r\n}\r\n\r\n.cached-users-panel .drop-time-threshold {\r\n  padding: 0.6em;\r\n  color: lightcoral;\r\n  font-family: 'Roboto Mono', monospace;\r\n  font-size: 1.1em;\r\n  font-weight: bold;\r\n  border-radius: 0.2em !important;\r\n  border: 1px solid rgba(240, 128, 128, 0.20);\r\n  background-color: rgba(240, 128, 128, 0.05);\r\n  transition: filter 0.3s;\r\n  filter: sepia(0);\r\n  cursor: pointer;\r\n}\r\n\r\n.cached-users-panel .drop-time-threshold:hover {\r\n  filter: sepia(1);\r\n}\r\n\r\n.cached-users-panel .drop-time-expiration-description {\r\n  padding: 0.6em;\r\n  color: #d0562c;\r\n}\r\n\r\n.cached-users-panel .drop-time-expiration {\r\n  padding: 0.6em;\r\n  color: antiquewhite;\r\n  font-family: 'Roboto Mono', monospace;\r\n  font-size: 1.1em;\r\n}\r\n\r\n.cached-users-panel .search-for-cached-users {\r\n  width: 100%;\r\n  margin: 0 0.5em;\r\n  display: flex;\r\n}\r\n\r\n.cached-users-panel .cached-users-search-input {\r\n  outline: none;\r\n  width: 100%;\r\n  padding: 10px;\r\n  font-size: 1em;\r\n  font-family: 'Montserrat';\r\n  color: bisque !important;\r\n  border-radius: 0.2em !important;\r\n  box-sizing: border-box;\r\n  background-color: #111;\r\n  border: 1px solid #222;\r\n}\r\n\r\n.cached-users-panel .error-message {\r\n  width: fit-content;\r\n  white-space: nowrap;\r\n  font-family: 'Montserrat';\r\n  color: lightcoral;\r\n}\r\n\r\n.fetch-mode-button {\r\n  background-color: #b2a4f9;\r\n}\r\n\r\n.fetch-mode-button svg {\r\n  stroke: darkslateblue;\r\n}\r\n\r\n.cache-mode-button {\r\n  background-color: darkslateblue;\r\n}\r\n\r\n.cache-mode-button svg {\r\n  stroke: #b2a4f9;\r\n}\r\n\r\n.cached-users-panel .fetched-users {\r\n  display: grid;\r\n  grid-template-rows: 1fr 1fr;\r\n  height: calc(100% - 0.5em);\r\n  overflow-y: auto;\r\n  grid-area: cache;\r\n}\r\n\r\n.cached-users-panel .users-container {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));\r\n  gap: 12px;\r\n  padding: 1em;\r\n  height: fit-content;\r\n}\r\n\r\n/* Common styles for all descriptions */\r\n.cached-users-panel .description {\r\n  color: bisque;\r\n  font-family: Montserrat;\r\n  font-size: 1em;\r\n  margin: 0;\r\n  padding: 0.4em 0.2em;\r\n  grid-column: 1 / -1;\r\n  height: fit-content;\r\n}\r\n\r\n/* Common styles for user container elements in cached users panel */\r\n.cached-users-panel .user-item {\r\n  padding: 0.2em;\r\n  margin: 0.4em 0.2em;\r\n  display: grid;\r\n  grid-template-columns: auto 1fr;\r\n  align-items: center;\r\n  height: fit-content;\r\n}\r\n\r\n/* Common styles for the visits element */\r\n.cached-users-panel .visits {\r\n  margin-left: 8px;\r\n  padding: 4px 6px;\r\n  border-radius: 2px !important;\r\n  cursor: pointer;\r\n  white-space: pre;\r\n}\r\n\r\n/* Styling for tracked visits */\r\n.cached-users-panel .visits.tracked {\r\n  color: greenyellow;\r\n  background-color: darkgreen;\r\n  font-weight: bold;\r\n}\r\n\r\n/* Styling for untracked visits */\r\n.cached-users-panel .visits.untracked {\r\n  color: orange;\r\n  background-color: #111111;\r\n  font-weight: normal;\r\n}\r\n\r\n/* Common styles for the action log container */\r\n.cached-users-panel .action-log {\r\n  position: fixed;\r\n  opacity: 0;\r\n  padding: 8px;\r\n  gap: 4px;\r\n  top: 50%;\r\n  left: 50%;\r\n  transform: translate(-50%, -50%);\r\n  max-height: 85vh;\r\n  overflow-y: auto;\r\n  scrollbar-width: none;\r\n  overflow-x: hidden;\r\n  display: flex;\r\n  min-width: 30vw;\r\n  max-width: 50vw;\r\n  flex-wrap: wrap;\r\n  background-color: #111111;\r\n  border: 3px dashed #212121;\r\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08) !important;\r\n  border-radius: 0.2em !important;\r\n}\r\n\r\n.cached-users-panel .rank {\r\n  padding: 2px 0;\r\n}\r\n\r\n.cached-users-panel .registered {\r\n  color: cadetblue;\r\n  font-size: 12px;\r\n}\r\n\r\n.cached-users-panel .user-metrics {\r\n  margin-top: 4px;\r\n  grid-column: span 2;\r\n}\r\n\r\n.cached-users-panel .avatar {\r\n  font-size: 1.8rem;\r\n  margin-right: 8px;\r\n}\r\n\r\n.cached-users-panel .avatar img {\r\n  height: 24px;\r\n  width: 24px;\r\n}\r\n\r\n.cached-users-panel .login {\r\n  color: skyblue !important;\r\n  text-decoration: none;\r\n  font-family: 'Montserrat', sans-serif;\r\n  transition: color 0.3s ease;\r\n}\r\n\r\n.cached-users-panel .login:hover {\r\n  color: cornsilk !important;\r\n}\r\n\r\n/* createCacheButton */\r\n.cache-user-count {\r\n  display: flex;\r\n  position: absolute;\r\n  justify-content: center;\r\n  align-items: center;\r\n  left: 0;\r\n  bottom: 0;\r\n  transform: translate(-50%, 50%);\r\n  z-index: 1;\r\n  height: 20px;\r\n  padding: 0 4px;\r\n  border-radius: 2px !important;\r\n  background-color: #9db380;\r\n  color: rgb(2, 2, 2);\r\n  font-size: 12px;\r\n  font-family: Roboto, sans-serif;\r\n  font-weight: bold;\r\n}\r\n\r\n/* createPersonalMessagesButton */\r\n.personal-messages-button {\r\n  position: relative;\r\n  z-index: 2;\r\n}\r\n\r\n.message-count {\r\n  display: flex;\r\n  position: absolute;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: 20px;\r\n  padding: 0 4px;\r\n  border-radius: 2px !important;\r\n  color: rgb(2, 2, 2);\r\n  font-size: 12px;\r\n  font-family: Roboto, sans-serif;\r\n  font-weight: bold;\r\n  bottom: 0;\r\n}\r\n\r\n.total-message-count {\r\n  left: 0;\r\n  transform: translate(-50%, 50%);\r\n  background-color: #fa8072;\r\n}\r\n\r\n.new-message-count {\r\n  right: 0;\r\n  transform: translate(50%, 50%);\r\n  background-color: #ffd700;\r\n}\r\n\r\n/* showPersonalMessagesPanel */\r\n.cached-messages-panel {\r\n  opacity: 0;\r\n  background-color: #1b1b1b;\r\n  border-radius: 0.6em !important;\r\n  position: fixed;\r\n  top: 100px;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  width: 50vw;\r\n  height: 80vh;\r\n  z-index: 999;\r\n  min-width: 1000px;\r\n  display: grid;\r\n  grid-template-columns: 1fr;\r\n  grid-template-rows: min-content;\r\n  grid-template-areas:\r\n    \"header header\"\r\n    \"messages scroll\";\r\n}\r\n\r\n.panel-header {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: flex-end;\r\n  /* Aligns to the right */\r\n  padding: 0.6em;\r\n  grid-area: header;\r\n}\r\n\r\n.search-for-personal-messages {\r\n  width: 100%;\r\n  margin: 0 0.5em 0 0;\r\n  display: flex;\r\n}\r\n\r\n.personal-messages-search-input {\r\n  outline: none;\r\n  width: 100%;\r\n  padding: 10px;\r\n  font-size: 1em;\r\n  font-family: Montserrat, sans-serif;\r\n  color: bisque !important;\r\n  border-radius: 0.2em !important;\r\n  box-sizing: border-box;\r\n  background-color: #111;\r\n  border: 1px solid #222 !important;\r\n}\r\n\r\n.cached-messages-panel .messages-container {\r\n  overflow-y: auto;\r\n  height: calc(100% - 0.5em);\r\n  padding: 1em;\r\n  grid-area: messages;\r\n}\r\n\r\n.cached-messages-panel .date-item {\r\n  position: relative;\r\n  font: 1em Montserrat, sans-serif;\r\n  color: burlywood;\r\n  background-color: rgba(222, 184, 135, 0.1);\r\n  width: fit-content;\r\n  margin: 2em 1em 1em;\r\n  padding: 0.4em 0.8em;\r\n  text-align: center;\r\n  border-radius: 0.4em !important;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n}\r\n\r\n.cached-messages-panel .message-item {\r\n  padding: 0.2em;\r\n}\r\n\r\n.cached-messages-panel .message-time {\r\n  margin: 0px 0.4em;\r\n  height: fit-content;\r\n  cursor: pointer;\r\n  transition: color 0.2s ease;\r\n}\r\n\r\n.cached-messages-panel .message-username {\r\n  display: inline-flex;\r\n  cursor: pointer;\r\n  margin: 0px 0.4em;\r\n  height: fit-content;\r\n}\r\n\r\n.cached-messages-panel .message-text {\r\n  cursor: pointer;\r\n  margin: 0px 0.4em;\r\n  height: fit-content;\r\n}\r\n\r\n/* createChatLogsButton */\r\n.chat-logs-button {\r\n  position: relative;\r\n  z-index: 1;\r\n}\r\n\r\n/* showChatLogsPanel */\r\n.chat-logs-panel {\r\n  opacity: 0;\r\n  background-color: #1b1b1b;\r\n  border-radius: 0.6em !important;\r\n  position: fixed;\r\n  top: 100px;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  width: 80vw;\r\n  height: 80vh;\r\n  z-index: 999;\r\n  min-width: 1000px;\r\n  display: grid;\r\n  grid-template-columns: 1fr;\r\n  grid-template-rows: min-content;\r\n  grid-template-areas:\r\n    \"header header header\"\r\n    \"messages scroll users\";\r\n}\r\n\r\n.chat-logs-panel .panel-header {\r\n  display: flex;\r\n  flex-direction: row;\r\n  grid-area: header;\r\n  justify-content: flex-end;\r\n  padding: 0.6em;\r\n}\r\n\r\n.chat-logs-panel .panel-control-buttons {\r\n  display: flex;\r\n}\r\n\r\n.chat-logs-panel .search-for-chatlogs-messages {\r\n  width: 100%;\r\n  margin: 0 0.5em 0 0;\r\n  display: flex;\r\n}\r\n\r\n.chat-logs-panel .chatlogs-search-input {\r\n  outline: none;\r\n  height: 48px;\r\n  width: 100%;\r\n  padding: 10px;\r\n  font-size: 1em;\r\n  font-family: Montserrat;\r\n  color: bisque !important;\r\n  border-radius: 0.2em !important;\r\n  box-sizing: border-box;\r\n  background-color: #111;\r\n  border: 1px solid #222 !important;\r\n}\r\n\r\n.chat-logs-panel .chatlogs-date-input {\r\n  background-color: #111;\r\n  color: bisque;\r\n  border: 1px solid #222;\r\n  width: fit-content;\r\n  height: 48px;\r\n  padding: 10px;\r\n  font-size: 1em;\r\n  font-family: Montserrat;\r\n  border-radius: 0.2em !important;\r\n  box-sizing: border-box;\r\n  margin: 0 0.5em;\r\n}\r\n\r\n.toggle-mention-messages-counter,\r\n.toggle-media-messages-counter {\r\n  display: flex;\r\n  position: absolute;\r\n  justify-content: center;\r\n  align-items: center;\r\n  padding: 2px 4px;\r\n  border-radius: 2px !important;\r\n  font-size: 12px;\r\n  font-family: Roboto;\r\n  font-weight: bold;\r\n  bottom: 0px;\r\n  left: 0px;\r\n  transform: translate(-50%, 50%);\r\n  color: #020202;\r\n  pointer-events: none;\r\n  user-select: none;\r\n}\r\n\r\n.toggle-mention-messages-counter {\r\n  background-color: #ffa07a;\r\n}\r\n\r\n.toggle-media-messages-counter {\r\n  background-color: #71c4c4;\r\n}\r\n\r\n.chat-logs-panel .saved-chatlog-url {\r\n  color: darkseagreen !important;\r\n  text-decoration: none;\r\n  display: inline-flex;\r\n  padding: 0.5em;\r\n}\r\n\r\n.chat-logs-panel .saved-chatlog-url-title {\r\n  color: lightsteelblue;\r\n  padding: 0.5em;\r\n}\r\n\r\n.saved-chatlog-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  overflow-y: auto;\r\n  background-color: rgb(30, 40, 45);\r\n  border: 1px solid rgb(60, 70, 80) !important;\r\n  border-radius: 0.2em !important;\r\n  position: absolute;\r\n  padding: 0.5em;\r\n  height: fit-content;\r\n  width: max-content;\r\n  max-height: 400px;\r\n  top: calc(50px + 1em);\r\n  right: 0;\r\n}\r\n\r\n.chat-logs-panel .chat-logs-container {\r\n  overflow-y: auto;\r\n  height: calc(100% - 0.5em);\r\n  padding: 1em;\r\n  display: flex;\r\n  grid-area: messages;\r\n  flex-direction: column;\r\n}\r\n\r\n.chat-logs-panel .message-item {\r\n  padding: 0.2em;\r\n  display: inline-flex;\r\n  cursor: pointer;\r\n  align-items: start;\r\n}\r\n\r\n.chat-logs-panel .message-time {\r\n  color: darkseagreen;\r\n  margin: 0 0.4em;\r\n  cursor: pointer;\r\n  transition: color 0.2s ease;\r\n  height: fit-content;\r\n}\r\n\r\n.chat-logs-panel .message-time:hover {\r\n  color: lightgreen;\r\n}\r\n\r\n.chat-logs-panel .message-username {\r\n  cursor: pointer;\r\n  margin: 0 0.4em;\r\n  height: fit-content;\r\n}\r\n\r\n.chat-logs-panel .message-text {\r\n  color: lightsteelblue;\r\n  margin: 0 0.4em;\r\n  overflow-wrap: anywhere;\r\n  height: fit-content;\r\n}\r\n\r\n.chat-logs-panel .active-users {\r\n  padding: 1em;\r\n  height: calc(100% - 1em);\r\n  width: fit-content;\r\n  overflow-y: auto;\r\n  overflow-x: hidden;\r\n  grid-area: users;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.chat-logs-panel .active-user-item {\r\n  display: flex;\r\n  height: fit-content;\r\n  align-items: center;\r\n  justify-content: left;\r\n  margin: 0.2em 0;\r\n  cursor: pointer;\r\n  transition: filter 0.15s;\r\n}\r\n\r\n.chat-logs-panel .active-user-item:hover {\r\n  filter: brightness(0.8);\r\n}\r\n\r\n.chat-logs-panel .active-user-name {\r\n  padding: 0.4em;\r\n}\r\n\r\n.chat-logs-panel .active-user-messages-count {\r\n  padding: 0.4em;\r\n  border-radius: 0.2em !important;\r\n}\r\n\r\n/* showSettingsPanel */\r\n.settings-panel {\r\n  opacity: 0;\r\n  background-color: #1b1b1b;\r\n  border-radius: 0.6em !important;\r\n  position: fixed;\r\n  top: 100px;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  width: 50vw;\r\n  height: 80vh;\r\n  z-index: 999;\r\n  min-width: 1000px;\r\n  display: grid;\r\n  grid-template-columns: 1fr;\r\n  grid-template-rows: min-content;\r\n  grid-template-areas:\r\n    \"header header\"\r\n    \"settings scroll\";\r\n}\r\n\r\n.settings-panel .panel-header {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: flex-end;\r\n  padding: 0.6em;\r\n  grid-area: header;\r\n}\r\n\r\n.settings-panel .settings-content-container {\r\n  overflow-y: auto;\r\n  height: calc(100% - 0.5em);\r\n  padding: 1em;\r\n  grid-area: settings;\r\n}\r\n\r\n.settings-panel .settings-description {\r\n  position: relative;\r\n  font: 1em Montserrat;\r\n  color: burlywood;\r\n  background-color: rgba(222, 184, 135, 0.1);\r\n  width: fit-content;\r\n  margin: 0 0 1em;\r\n  padding: 0.4em 0.8em;\r\n  border-radius: 0.4em !important;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n}\r\n\r\n.settings-panel .settings-spoiler button {\r\n  position: relative;\r\n  font: 1em Montserrat;\r\n  color: lightgreen;\r\n  background-color: rgba(222, 184, 135, 0.1);\r\n  margin: 0 0 3em 0;\r\n  padding: 0.4em 0.8em;\r\n  border-radius: 0.4em !important;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  cursor: pointer;\r\n  transition: background-color 0.3s ease;\r\n  border: none;\r\n}\r\n\r\n.settings-panel .settings-spoiler button:hover {\r\n  background-color: rgba(222, 184, 135, 0.25);\r\n}\r\n\r\n.settings-panel .settings-field {\r\n  height: 30px;\r\n  max-width: 200px;\r\n  min-width: 150px;\r\n  padding: 0.4em;\r\n  font: 1em Montserrat;\r\n  font-family: Montserrat;\r\n  color: bisque;\r\n  border-radius: 0.2em !important;\r\n  box-sizing: border-box;\r\n  background-color: rgb(17, 17, 17);\r\n  border: 1px solid rgb(34, 34, 34);\r\n}\r\n\r\n.settings-panel .settings-button {\r\n  width: 30px;\r\n  height: 30px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border-radius: 0.2em !important;\r\n  cursor: pointer;\r\n  transition: filter 0.3s;\r\n  filter: brightness(1);\r\n}\r\n\r\n.settings-panel .settings-button:hover {\r\n  filter: brightness(0.8);\r\n}\r\n\r\n/* Disabled state */\r\n.settings-panel .settings-button.disabled {\r\n  filter: grayscale(1);\r\n  pointer-events: none;\r\n  opacity: 0.5;\r\n}\r\n\r\n.settings-panel .settings-button {\r\n  width: 30px;\r\n  height: 30px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border-radius: 0.2em !important;\r\n  cursor: pointer;\r\n  transition: filter 0.3s;\r\n}\r\n\r\n.settings-panel .remove-settings-button {\r\n  stroke: #ee9090;\r\n  background-color: #6b2f2f;\r\n}\r\n\r\n.settings-panel .assigned-settings-button {\r\n  stroke: lightsteelblue;\r\n  background-color: steelblue;\r\n}\r\n\r\n.settings-panel .add-settings-button {\r\n  stroke: #d190ee;\r\n  background-color: #502f6b;\r\n}\r\n\r\n.settings-panel .settings-container {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  align-items: start;\r\n  flex-direction: column;\r\n}\r\n\r\n/* toggleHiddenMessages */\r\n.toggle-button-hidden {\r\n  background-color: hsl(0, 20%, 10%);\r\n  color: hsl(0, 50%, 50%);\r\n  border: 1px solid hsl(0, 50%, 50%);\r\n}\r\n\r\n.toggle-button-show {\r\n  background-color: hsl(90, 20%, 10%);\r\n  color: hsl(90, 50%, 50%);\r\n  border: 1px solid hsl(90, 50%, 50%);\r\n}\r\n\r\n.toggle-button-hide {\r\n  background-color: hsl(50, 20%, 10%);\r\n  color: hsl(50, 50%, 50%);\r\n  border: 1px solid hsl(50, 50%, 50%);\r\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/style.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\r\n\r\n/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function (cssWithMappingToString) {\r\n  var list = [];\r\n\r\n  // return the list of modules as css string\r\n  list.toString = function toString() {\r\n    return this.map(function (item) {\r\n      var content = \"\";\r\n      var needLayer = typeof item[5] !== \"undefined\";\r\n      if (item[4]) {\r\n        content += \"@supports (\".concat(item[4], \") {\");\r\n      }\r\n      if (item[2]) {\r\n        content += \"@media \".concat(item[2], \" {\");\r\n      }\r\n      if (needLayer) {\r\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\r\n      }\r\n      content += cssWithMappingToString(item);\r\n      if (needLayer) {\r\n        content += \"}\";\r\n      }\r\n      if (item[2]) {\r\n        content += \"}\";\r\n      }\r\n      if (item[4]) {\r\n        content += \"}\";\r\n      }\r\n      return content;\r\n    }).join(\"\");\r\n  };\r\n\r\n  // import a list of modules into the list\r\n  list.i = function i(modules, media, dedupe, supports, layer) {\r\n    if (typeof modules === \"string\") {\r\n      modules = [[null, modules, undefined]];\r\n    }\r\n    var alreadyImportedModules = {};\r\n    if (dedupe) {\r\n      for (var k = 0; k < this.length; k++) {\r\n        var id = this[k][0];\r\n        if (id != null) {\r\n          alreadyImportedModules[id] = true;\r\n        }\r\n      }\r\n    }\r\n    for (var _k = 0; _k < modules.length; _k++) {\r\n      var item = [].concat(modules[_k]);\r\n      if (dedupe && alreadyImportedModules[item[0]]) {\r\n        continue;\r\n      }\r\n      if (typeof layer !== \"undefined\") {\r\n        if (typeof item[5] === \"undefined\") {\r\n          item[5] = layer;\r\n        } else {\r\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\r\n          item[5] = layer;\r\n        }\r\n      }\r\n      if (media) {\r\n        if (!item[2]) {\r\n          item[2] = media;\r\n        } else {\r\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\r\n          item[2] = media;\r\n        }\r\n      }\r\n      if (supports) {\r\n        if (!item[4]) {\r\n          item[4] = \"\".concat(supports);\r\n        } else {\r\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\r\n          item[4] = supports;\r\n        }\r\n      }\r\n      list.push(item);\r\n    }\r\n  };\r\n  return list;\r\n};\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\r\n\r\nmodule.exports = function (i) {\r\n  return i[1];\r\n};\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar stylesInDOM = [];\r\nfunction getIndexByIdentifier(identifier) {\r\n  var result = -1;\r\n  for (var i = 0; i < stylesInDOM.length; i++) {\r\n    if (stylesInDOM[i].identifier === identifier) {\r\n      result = i;\r\n      break;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction modulesToDom(list, options) {\r\n  var idCountMap = {};\r\n  var identifiers = [];\r\n  for (var i = 0; i < list.length; i++) {\r\n    var item = list[i];\r\n    var id = options.base ? item[0] + options.base : item[0];\r\n    var count = idCountMap[id] || 0;\r\n    var identifier = \"\".concat(id, \" \").concat(count);\r\n    idCountMap[id] = count + 1;\r\n    var indexByIdentifier = getIndexByIdentifier(identifier);\r\n    var obj = {\r\n      css: item[1],\r\n      media: item[2],\r\n      sourceMap: item[3],\r\n      supports: item[4],\r\n      layer: item[5]\r\n    };\r\n    if (indexByIdentifier !== -1) {\r\n      stylesInDOM[indexByIdentifier].references++;\r\n      stylesInDOM[indexByIdentifier].updater(obj);\r\n    } else {\r\n      var updater = addElementStyle(obj, options);\r\n      options.byIndex = i;\r\n      stylesInDOM.splice(i, 0, {\r\n        identifier: identifier,\r\n        updater: updater,\r\n        references: 1\r\n      });\r\n    }\r\n    identifiers.push(identifier);\r\n  }\r\n  return identifiers;\r\n}\r\nfunction addElementStyle(obj, options) {\r\n  var api = options.domAPI(options);\r\n  api.update(obj);\r\n  var updater = function updater(newObj) {\r\n    if (newObj) {\r\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\r\n        return;\r\n      }\r\n      api.update(obj = newObj);\r\n    } else {\r\n      api.remove();\r\n    }\r\n  };\r\n  return updater;\r\n}\r\nmodule.exports = function (list, options) {\r\n  options = options || {};\r\n  list = list || [];\r\n  var lastIdentifiers = modulesToDom(list, options);\r\n  return function update(newList) {\r\n    newList = newList || [];\r\n    for (var i = 0; i < lastIdentifiers.length; i++) {\r\n      var identifier = lastIdentifiers[i];\r\n      var index = getIndexByIdentifier(identifier);\r\n      stylesInDOM[index].references--;\r\n    }\r\n    var newLastIdentifiers = modulesToDom(newList, options);\r\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\r\n      var _identifier = lastIdentifiers[_i];\r\n      var _index = getIndexByIdentifier(_identifier);\r\n      if (stylesInDOM[_index].references === 0) {\r\n        stylesInDOM[_index].updater();\r\n        stylesInDOM.splice(_index, 1);\r\n      }\r\n    }\r\n    lastIdentifiers = newLastIdentifiers;\r\n  };\r\n};\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar memo = {};\r\n\r\n/* istanbul ignore next  */\r\nfunction getTarget(target) {\r\n  if (typeof memo[target] === \"undefined\") {\r\n    var styleTarget = document.querySelector(target);\r\n\r\n    // Special case to return head of iframe instead of iframe itself\r\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\r\n      try {\r\n        // This will throw an exception if access to iframe is blocked\r\n        // due to cross-origin restrictions\r\n        styleTarget = styleTarget.contentDocument.head;\r\n      } catch (e) {\r\n        // istanbul ignore next\r\n        styleTarget = null;\r\n      }\r\n    }\r\n    memo[target] = styleTarget;\r\n  }\r\n  return memo[target];\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction insertBySelector(insert, style) {\r\n  var target = getTarget(insert);\r\n  if (!target) {\r\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\r\n  }\r\n  target.appendChild(style);\r\n}\r\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction insertStyleElement(options) {\r\n  var element = document.createElement(\"style\");\r\n  options.setAttributes(element, options.attributes);\r\n  options.insert(element, options.options);\r\n  return element;\r\n}\r\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction setAttributesWithoutAttributes(styleElement) {\r\n  var nonce =  true ? __webpack_require__.nc : 0;\r\n  if (nonce) {\r\n    styleElement.setAttribute(\"nonce\", nonce);\r\n  }\r\n}\r\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction apply(styleElement, options, obj) {\r\n  var css = \"\";\r\n  if (obj.supports) {\r\n    css += \"@supports (\".concat(obj.supports, \") {\");\r\n  }\r\n  if (obj.media) {\r\n    css += \"@media \".concat(obj.media, \" {\");\r\n  }\r\n  var needLayer = typeof obj.layer !== \"undefined\";\r\n  if (needLayer) {\r\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\r\n  }\r\n  css += obj.css;\r\n  if (needLayer) {\r\n    css += \"}\";\r\n  }\r\n  if (obj.media) {\r\n    css += \"}\";\r\n  }\r\n  if (obj.supports) {\r\n    css += \"}\";\r\n  }\r\n  var sourceMap = obj.sourceMap;\r\n  if (sourceMap && typeof btoa !== \"undefined\") {\r\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\r\n  }\r\n\r\n  // For old IE\r\n  /* istanbul ignore if  */\r\n  options.styleTagTransform(css, styleElement, options.options);\r\n}\r\nfunction removeStyleElement(styleElement) {\r\n  // istanbul ignore if\r\n  if (styleElement.parentNode === null) {\r\n    return false;\r\n  }\r\n  styleElement.parentNode.removeChild(styleElement);\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction domAPI(options) {\r\n  if (typeof document === \"undefined\") {\r\n    return {\r\n      update: function update() {},\r\n      remove: function remove() {}\r\n    };\r\n  }\r\n  var styleElement = options.insertStyleElement(options);\r\n  return {\r\n    update: function update(obj) {\r\n      apply(styleElement, options, obj);\r\n    },\r\n    remove: function remove() {\r\n      removeStyleElement(styleElement);\r\n    }\r\n  };\r\n}\r\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction styleTagTransform(css, styleElement) {\r\n  if (styleElement.styleSheet) {\r\n    styleElement.styleSheet.cssText = css;\r\n  } else {\r\n    while (styleElement.firstChild) {\r\n      styleElement.removeChild(styleElement.firstChild);\r\n    }\r\n    styleElement.appendChild(document.createTextNode(css));\r\n  }\r\n}\r\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://tampermonkey-script/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ \"./src/style.css\");\n/* harmony import */ var _modules_image_converter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/image-converter.js */ \"./src/modules/image-converter.js\");\n/* harmony import */ var _modules_video_converter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/video-converter.js */ \"./src/modules/video-converter.js\");\n/* harmony import */ var _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/icons.js */ \"./src/modules/icons.js\");\n/* harmony import */ var _modules_cache_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/cache.js */ \"./src/modules/cache.js\");\n/* harmony import */ var _modules_messages_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/messages.js */ \"./src/modules/messages.js\");\n/* harmony import */ var _modules_chatlogs_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/chatlogs.js */ \"./src/modules/chatlogs.js\");\n/* harmony import */ var _modules_settings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/settings.js */ \"./src/modules/settings.js\");\n/* harmony import */ var _modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/helpers.js */ \"./src/modules/helpers.js\");\n/* harmony import */ var _modules_chat_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/chat.js */ \"./src/modules/chat.js\");\n/* harmony import */ var _modules_tooltip_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/tooltip.js */ \"./src/modules/tooltip.js\");\n/* harmony import */ var _modules_notifications_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/notifications.js */ \"./src/modules/notifications.js\");\n/* harmony import */ var _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/definitions.js */ \"./src/modules/definitions.js\");\n// styles\r\n\r\n\r\n // image converter\r\n // video converter\r\n\r\n// icons\r\n\r\n\r\n // cache\r\n // messages\r\n // chatlogs\r\n // settings\r\n\r\n// helpers && helpers definitions\r\n\r\n\r\n// chat\r\n\r\n\r\n// notifications\r\n\r\n\r\n// notifications\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Array to store user IDs and their status titles\r\nlet fetchedUsers = JSON.parse(localStorage.getItem('fetchedUsers')) || {};\r\n\r\n(function () {\r\n  // Function to dynamically append font link to the head\r\n  function appendFontLink(fontFamily, fontWeights) {\r\n    // Check if the font link element with the specified class already exists\r\n    const existingFont = document.querySelector(`.font-${fontFamily.replace(/\\s/g, '-')}`);\r\n\r\n    // If it doesn't exist, create a new link element and append it to the document head\r\n    if (!existingFont) {\r\n      const fontLink = document.createElement('link');\r\n      fontLink.rel = 'stylesheet';\r\n      fontLink.href = `https://fonts.googleapis.com/css2?family=${fontFamily.replace(/\\s/g, '+')}:wght@${fontWeights.join(';')}&display=swap`;\r\n      fontLink.classList.add(`font-${fontFamily.replace(/\\s/g, '-')}`);\r\n\r\n      // Append the font link element to the document head\r\n      document.head.appendChild(fontLink);\r\n    }\r\n  }\r\n\r\n  // Specify the font weights you want to include\r\n  const montserratFontWeights = ['100', '200', '300', '400', '500', '600', '700', '800', '900'];\r\n  const orbitronFontWeights = ['400', '500', '600', '700', '800', '900'];\r\n  const robotoMonoFontWeights = ['100', '200', '300', '400', '500', '600', '700'];\r\n\r\n  // Call the function to append Montserrat font link\r\n  appendFontLink('Montserrat', montserratFontWeights);\r\n\r\n  // Call the function to append Orbitron font link\r\n  appendFontLink('Orbitron', orbitronFontWeights);\r\n\r\n  // Call the function to append Roboto Mono font link\r\n  appendFontLink('Roboto Mono', robotoMonoFontWeights);\r\n\r\n  // Define voice speed limits\r\n  const minVoiceSpeed = 0;\r\n  const maxVoiceSpeed = 2.5;\r\n\r\n  // Define voice pitch limits\r\n  const minVoicePitch = 0;\r\n  const maxVoicePitch = 2.0;\r\n\r\n  // Define default voice speed and pitch\r\n  const defaultVoiceSpeed = 1.5;\r\n  const defaultVoicePitch = 1.0;\r\n\r\n  // Retrieve KG_Chat_Empowerment from localStorage or create an object with empty voiceSettings if it doesn't exist\r\n  // This is the main key for the settings\r\n  let KG_Chat_Empowerment = JSON.parse(localStorage.getItem('KG_Chat_Empowerment'));\r\n\r\n  // If KG_Chat_Empowerment doesn't exist in localStorage, create it with an empty voiceSettings object\r\n  if (!KG_Chat_Empowerment) {\r\n    KG_Chat_Empowerment = {\r\n      voiceSettings: {\r\n        voiceSpeed: defaultVoiceSpeed, // Set default values for voiceSpeed\r\n        voicePitch: defaultVoicePitch, // Set default values for voicePitch\r\n      },\r\n      messageSettings: {},\r\n    };\r\n    localStorage.setItem('KG_Chat_Empowerment', JSON.stringify(KG_Chat_Empowerment));\r\n  }\r\n\r\n  // Define the default voice speed and pitch\r\n  let voiceSpeed = KG_Chat_Empowerment.voiceSettings.voiceSpeed !== null\r\n    ? KG_Chat_Empowerment.voiceSettings.voiceSpeed\r\n    : defaultVoiceSpeed; // Default value if KG_Chat_Empowerment.voiceSettings.voiceSpeed is null\r\n\r\n  let voicePitch = KG_Chat_Empowerment.voiceSettings.voicePitch !== null\r\n    ? KG_Chat_Empowerment.voiceSettings.voicePitch\r\n    : defaultVoicePitch; // Default value if KG_Chat_Empowerment.voiceSettings.voicePitch is null\r\n\r\n  // SOUND NOTIFICATION\r\n\r\n  // Function to create the audio context and return a Promise that resolves when the context is ready\r\n  function createAudioContext() {\r\n    const audioContext = new AudioContext();\r\n    return new Promise(resolve => {\r\n      audioContext.onstatechange = function () {\r\n        if (audioContext.state === 'running') {\r\n          resolve(audioContext);\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  // Create the audio context and wait for it to be ready\r\n  const audioContextPromise = createAudioContext();\r\n\r\n  // List of frequencies to play for \"User Left\" && \"User Entered\" && \"New Messages\"\r\n  const userEnteredFrequencies = [300, 600];\r\n  const userLeftFrequencies = [600, 300];\r\n  const usualMessageFrequencies = [500];\r\n  const mentionMessageFrequencies = [600, 800];\r\n\r\n  // Volume of the reader voice\r\n  const voiceVolume = 0.8;\r\n  // Volume of the beep signal\r\n  const beepVolume = 0.2;\r\n  // Duration for each frequency\r\n  const duration = 80;\r\n  // Smooth inception and termination for each note\r\n  const fade = 10;\r\n  // Space between each note to make noticeable pauses\r\n  const delay = 100;\r\n\r\n  // Function to play a beep given a list of frequencies\r\n  function playBeep(frequencies, volume) {\r\n    audioContextPromise.then(audioContext => {\r\n      for (let i = 0; i < frequencies.length; i++) {\r\n        const frequency = frequencies[i];\r\n        if (frequency === 0) {\r\n          // Rest note\r\n          setTimeout(() => { }, duration);\r\n        } else {\r\n          // Play note\r\n          const oscillator = audioContext.createOscillator();\r\n          const gain = audioContext.createGain();\r\n          oscillator.connect(gain);\r\n          oscillator.frequency.value = frequency;\r\n          oscillator.type = \"sine\";\r\n\r\n          // Create low pass filter to cut frequencies below 250Hz\r\n          const lowPassFilter = audioContext.createBiquadFilter();\r\n          lowPassFilter.type = 'lowpass';\r\n          lowPassFilter.frequency.value = 250;\r\n          oscillator.connect(lowPassFilter);\r\n\r\n          // Create high pass filter to cut frequencies above 16kHz\r\n          const highPassFilter = audioContext.createBiquadFilter();\r\n          highPassFilter.type = 'highpass';\r\n          highPassFilter.frequency.value = 16000;\r\n          lowPassFilter.connect(highPassFilter);\r\n\r\n          gain.connect(audioContext.destination);\r\n          gain.gain.setValueAtTime(0, audioContext.currentTime);\r\n          gain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + fade / 1000);\r\n          oscillator.start(audioContext.currentTime + i * delay / 1000);\r\n          oscillator.stop(audioContext.currentTime + (i * delay + duration) / 1000);\r\n          gain.gain.setValueAtTime(volume, audioContext.currentTime + (i * delay + (duration - fade)) / 1000);\r\n          gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + (i * delay + duration) / 1000);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // Create a promise that will resolve when the list of available voices is populated\r\n  const awaitVoices = new Promise(resolve => {\r\n    // Create a speech synthesis object\r\n    const synth = window.speechSynthesis;\r\n    // Retrieve the list of available voices\r\n    let voices = synth.getVoices();\r\n\r\n    // Define the voice names for Pavel and Irina\r\n    const pavelVoiceName = 'Microsoft Pavel - Russian (Russia)';\r\n    const irinaVoiceName = 'Microsoft Irina - Russian (Russia)';\r\n\r\n    // Find and store Pavel's voice\r\n    let pavelVoice = voices.find(voice => voice.name === pavelVoiceName);\r\n    // Find and store Irina's voice\r\n    let irinaVoice = voices.find(voice => voice.name === irinaVoiceName);\r\n\r\n    // If either voice is not found or the voices list is empty, wait for it to populate\r\n    if (!pavelVoice || !irinaVoice || voices.length === 0) {\r\n      synth.addEventListener('voiceschanged', () => {\r\n        voices = synth.getVoices();\r\n        pavelVoice = voices.find(voice => voice.name === pavelVoiceName);\r\n        irinaVoice = voices.find(voice => voice.name === irinaVoiceName);\r\n\r\n        // If both voices are found, continue with the initialization\r\n        if (pavelVoice && irinaVoice) {\r\n          // Define the utterance object as a global variable\r\n          const utterance = new SpeechSynthesisUtterance();\r\n          // Set the \"lang\" property of the utterance object to 'ru-RU'\r\n          utterance.lang = 'ru-RU';\r\n          // Set the \"voice\" property of the utterance object to Pavel's voice\r\n          utterance.voice = irinaVoice;\r\n          // Resolve the promise\r\n          resolve({ synth, utterance, voices, pavelVoice, irinaVoice });\r\n        }\r\n      });\r\n    } else {\r\n      // Define the utterance object as a global variable\r\n      const utterance = new SpeechSynthesisUtterance();\r\n      // Set the \"lang\" property of the utterance object to 'ru-RU'\r\n      utterance.lang = 'ru-RU';\r\n      // Set the \"voice\" property of the utterance object to (Needed) voice\r\n      utterance.voice = irinaVoice;\r\n      // Resolve the promise\r\n      resolve({ synth, utterance, voices, pavelVoice, irinaVoice });\r\n    }\r\n  });\r\n\r\n  async function cleanText(text) {\r\n    return text\r\n      // Replace all hyphens (- U+002D), minus signs (− U+2212), and underscores (_) with spaces\r\n      .replace(/[-−_]/g, ' ')\r\n      // Replace URLs with just the domain name, removing \"https://\", \"http://\", and \"www.\"\r\n      .replace(/https?:\\/\\/(?:www\\.)?([a-zA-Z0-9.-]+)(\\/.*)?/g, (_, p1) => p1)\r\n      .replace(/\\s(?=[?!,.:;@])/g, '')\r\n      // Remove all other symbols completely\r\n      .replace(/[\"#$%&'()*+\\/<=>[\\\\\\]^`{|}~]/g, '')\r\n      // Remove extra spaces and format text\r\n      .split(' ').filter(Boolean).join(' ').trim();\r\n  }\r\n\r\n  // Split text into language blocks (Russian vs. English) based on per-word detection.\r\n  const detectLanguageBlocks = text =>\r\n    text.split(/\\s+/).reduce((blocks, word) => {\r\n      const lang = /[А-Яа-яЁё0-9]/.test(word) ? 'ru' : 'en';\r\n      if (blocks.length && blocks[blocks.length - 1].lang === lang) {\r\n        blocks[blocks.length - 1].text += ' ' + word;\r\n      } else {\r\n        blocks.push({ lang, text: word });\r\n      }\r\n      return blocks;\r\n    }, []);\r\n\r\n  // Fallback: Web Speech API TTS\r\n  async function webTextToSpeech(text, voiceSpeed = voiceSpeed) {\r\n    const { synth, utterance, voice } = await awaitVoices;\r\n    Object.assign(utterance, { text, rate: voiceSpeed, volume: voiceVolume, pitch: voicePitch, voice });\r\n    return new Promise(resolve => { utterance.onend = resolve; synth.speak(utterance); });\r\n  }\r\n\r\n  // Main TTS function: plays each language block in order.\r\n  async function textToSpeech(text, voiceSpeed = voiceSpeed) {\r\n    const shouldUseGoogleTTS = (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.shouldEnableSetting)('sound', 'gTTS');\r\n    // Clean the text using the new cleanText function asynchronously\r\n    const cleanedText = await cleanText(text);\r\n\r\n    // If Google TTS is enabled, use it. Otherwise, fallback to Web Speech API.\r\n    if (shouldUseGoogleTTS) {\r\n      const blocks = detectLanguageBlocks(cleanedText);\r\n      try {\r\n        for (const { lang, text } of blocks) {\r\n          await new Promise((resolve, reject) => {\r\n            fetch(`http://127.0.0.1:5000/speak?text=${encodeURIComponent(text)}&lang=${lang}`)\r\n              .then(res => { if (!res.ok) throw new Error(`HTTP ${res.status}`); return res.arrayBuffer(); })\r\n              .then(buffer => {\r\n                const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n                const audio = new Audio(URL.createObjectURL(new Blob([buffer], { type: 'audio/mp3' })));\r\n                const source = audioContext.createMediaElementSource(audio);\r\n                const gainNode = audioContext.createGain();\r\n\r\n                gainNode.gain.value = 2.0; // Boost volume\r\n\r\n                // Connect the audio source to the gain node and the gain node to the destination (speakers)\r\n                source.connect(gainNode);\r\n                gainNode.connect(audioContext.destination);\r\n\r\n                audio.onended = resolve;\r\n                audio.onerror = reject;\r\n                audio.play();\r\n              })\r\n              .catch(reject);\r\n          });\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Server TTS failed:\", error);\r\n      }\r\n    } else {\r\n      // If Google TTS isn't enabled, fallback to Web Speech API\r\n      await webTextToSpeech(text, voiceSpeed);\r\n    }\r\n  }\r\n\r\n  const verbs = {\r\n    Male: { enter: 'зашёл', leave: 'вышел' },\r\n    Female: { enter: 'зашла', leave: 'вышла' }\r\n  };\r\n\r\n  function getUserGender(userName) {\r\n    const user = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.find((user) => user.name === userName);\r\n    return user ? user.gender : null;\r\n  }\r\n\r\n  // Handles user entering and leaving actions\r\n  function userAction(user, actionType, userGender) {\r\n    const shouldPlayAction = (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.shouldEnableSetting)('sound', 'presence');\r\n    // If neither beep and voice is enabled, exit early.\r\n    if (!shouldPlayAction) return;\r\n\r\n    const gender = userGender || 'Male'; // Default to 'Male' if no gender provided\r\n    const userToTrack = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.find(userToTrack => userToTrack.name === user);\r\n    const action = actionType === \"enter\" ? verbs[gender].enter : verbs[gender].leave;\r\n    const frequencies = actionType === \"enter\" ? userEnteredFrequencies : userLeftFrequencies;\r\n\r\n    playBeep(frequencies, beepVolume);\r\n    setTimeout(() => textToSpeech(`${userToTrack.pronunciation} ${action}`, voiceSpeed), 300);\r\n  }\r\n\r\n\r\n  // EMPOWERMENT PANEL AND USER COUNTER\r\n\r\n  // Retrieve body element to inject this beast elements\r\n  const bodyElement = document.querySelector('body');\r\n  // Create parent container for the beast elements\r\n  const empowermentButtonsPanel = document.createElement('div');\r\n  empowermentButtonsPanel.classList.add(\"empowerment-panel\");\r\n\r\n  // Create chat user count container to store the user count number\r\n  const chatUserCount = document.createElement('div');\r\n  chatUserCount.classList.add(\"chat-user-count\");\r\n  chatUserCount.title = 'Current Chat Users Count';\r\n  chatUserCount.innerHTML = '0';  // Set initial value as 0\r\n\r\n  // Append user count element inside empowerment panel\r\n  empowermentButtonsPanel.appendChild(chatUserCount);\r\n  // Append panel element inside the body\r\n  bodyElement.appendChild(empowermentButtonsPanel);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  // NEW CHAT USER LIST (START)\r\n\r\n  // Function to dynamically apply background color\r\n  function applyDynamicBackgroundColor() {\r\n    // Create a new <style> element\r\n    const newChatUserListStyles = document.createElement('style');\r\n    newChatUserListStyles.classList.add(\"userlist-dynamic-background\");\r\n\r\n    // Get the dynamic background color\r\n    const dynamicBackgroundColor = getComputedStyle(document.querySelector('.chat .messages')).backgroundColor;\r\n\r\n    // Define the styles with only background color\r\n    const userListStyles = `\r\n    #chat-general .smile-tab {\r\n      background-color: ${dynamicBackgroundColor};\r\n    }\r\n    .chat-user-list {\r\n      background-color: ${dynamicBackgroundColor};\r\n    }\r\n  `;\r\n\r\n    // Set the innerHTML of the style element to the styles\r\n    newChatUserListStyles.innerHTML = userListStyles;\r\n    // Append the <style> element to the document head\r\n    document.head.appendChild(newChatUserListStyles);\r\n  }\r\n\r\n  // Call the function to apply the dynamic background color\r\n  applyDynamicBackgroundColor();\r\n\r\n  // Function to calculate time spent on the site\r\n  function calculateTimeOnSite(registeredDate) {\r\n    const totalSeconds = Math.floor((new Date() - new Date(registeredDate)) / 1000);\r\n    const years = Math.floor(totalSeconds / (365 * 24 * 60 * 60));\r\n    const months = Math.floor((totalSeconds % (365 * 24 * 60 * 60)) / (30.44 * 24 * 60 * 60));\r\n    const days = Math.floor((totalSeconds % (30.44 * 24 * 60 * 60)) / (24 * 60 * 60));\r\n    const hours = Math.floor((totalSeconds % (24 * 60 * 60)) / (60 * 60));\r\n    const minutes = Math.floor((totalSeconds % (60 * 60)) / 60);\r\n    const seconds = totalSeconds % 60;\r\n\r\n    const timeComponents = [];\r\n\r\n    if (years > 0) {\r\n      timeComponents.push(`${years} year${years > 1 ? 's' : ''}`);\r\n      if (months > 0) timeComponents.push(`${months} month${months > 1 ? 's' : ''}`);\r\n    } else if (months > 1 || (months === 1 && days > 0)) {\r\n      timeComponents.push(`${months} month${months > 1 ? 's' : ''}`);\r\n      if (days > 0) timeComponents.push(`${days} day${days > 1 ? 's' : ''}`);\r\n    } else if (days > 0) {\r\n      timeComponents.push(`${days} day${days > 1 ? 's' : ''}`);\r\n      if (hours > 0) timeComponents.push(`${hours} hour${hours > 1 ? 's' : ''}`);\r\n      if (minutes > 0) timeComponents.push(`${minutes} minute${minutes > 1 ? 's' : ''}`);\r\n    } else if (hours > 0) {\r\n      timeComponents.push(`${hours} hour${hours > 1 ? 's' : ''}`);\r\n      if (minutes > 0) timeComponents.push(`${minutes} minute${minutes > 1 ? 's' : ''}`);\r\n    } else if (minutes > 0) {\r\n      timeComponents.push(`${minutes} minute${minutes > 1 ? 's' : ''}`);\r\n      if (seconds > 0) timeComponents.push(`${seconds} second${seconds > 1 ? 's' : ''}`);\r\n    } else {\r\n      timeComponents.push(`${seconds} second${seconds > 1 ? 's' : ''}`);\r\n    }\r\n\r\n    return timeComponents.filter(Boolean).join(' '); // Filter out empty strings and join components\r\n  }\r\n\r\n  // Function to get rank information (class, color, and icon) based on status title in English\r\n  function getRankInfo(mainTitle) {\r\n    const statusData = {\r\n      'Экстракибер': { class: 'extra', icon: '🚀', color: '#06B4E9' },\r\n      'Кибергонщик': { class: 'cyber', icon: '🤖', color: '#5681ff' },\r\n      'Супермен': { class: 'superman', icon: '👊', color: '#B543F5' },\r\n      'Маньяк': { class: 'maniac', icon: '🔪', color: '#DA0543' },\r\n      'Гонщик': { class: 'racer', icon: '⚡️️', color: '#FF8C00' },\r\n      'Профи': { class: 'profi', icon: '️💼️', color: '#C1AA00' },\r\n      'Таксист': { class: 'driver', icon: '🚖️', color: '#2DAB4F' },\r\n      'Любитель': { class: 'amateur', icon: '🍆️', color: '#61B5B3' },\r\n      'Новичок': { class: 'newbie', icon: '🐥', color: '#AFAFAF' }\r\n    };\r\n\r\n    const defaultData = { class: 'unknown', icon: '❓', color: '#000000' };\r\n    const rankInfo = statusData[mainTitle] || defaultData;\r\n\r\n    if (rankInfo.class === defaultData.class) {\r\n      console.log(`Class not found for status title: ${mainTitle}. Using default class: ${defaultData.class}`);\r\n    }\r\n\r\n    return rankInfo;\r\n  }\r\n\r\n  // Function to handle private message\r\n  function insertPrivate(userId) {\r\n    const userName = document.querySelector(`.name[data-user=\"${userId}\"]`).textContent;\r\n    const message = `<${userName}>`;\r\n\r\n    const textElement = document.querySelector('.messages .text');\r\n    textElement.value = message;\r\n\r\n    textElement.focus();\r\n    textElement.selectionEnd = textElement.value.length;\r\n  }\r\n\r\n  function createCircularProgress(percentage, color, isRevoked) {\r\n    const svgUrl = \"http://www.w3.org/2000/svg\";\r\n    const size = 20;\r\n    const center = size / 2;\r\n    const strokeWidth = 2;\r\n    const radius = center - strokeWidth;\r\n    const diameter = radius * 2;\r\n    const randomString = Math.random().toString(36).substring(2, 22);\r\n    const scaleMultiplier = !isRevoked && percentage === 0 ? 0.6 : 1;\r\n\r\n    const svg = document.createElementNS(svgUrl, \"svg\");\r\n    Object.entries({\r\n      width: size, height: size, viewBox: `0 0 ${size} ${size}`, xmlns: svgUrl\r\n    }).forEach(([k, v]) => svg.setAttribute(k, v));\r\n    svg.classList.add(\"circularProgress\");\r\n\r\n    if (isRevoked || percentage === 0) {\r\n      if (!isRevoked) {\r\n        const outerCircle = document.createElementNS(svgUrl, \"circle\");\r\n        Object.entries({\r\n          cx: center, cy: center, r: radius, fill: \"none\", stroke: color, \"stroke-width\": strokeWidth\r\n        }).forEach(([k, v]) => outerCircle.setAttribute(k, v));\r\n        outerCircle.classList.add(\"outerCircle\");\r\n        svg.appendChild(outerCircle);\r\n      }\r\n\r\n      const scale = (size / 24) * scaleMultiplier;\r\n      const offset = center - 12 * scale;\r\n      const closeIconGroup = document.createElementNS(svgUrl, \"g\");\r\n      closeIconGroup.setAttribute(\"transform\", `translate(${offset}, ${offset}) scale(${scale})`);\r\n      closeIconGroup.classList.add(\"closeIconGroup\");\r\n\r\n      const path = document.createElementNS(svgUrl, \"path\");\r\n      Object.entries({\r\n        d: \"M18.364 5.636a1 1 0 0 1 0 1.414L13.414 12l4.95 4.95a1 1 0 0 1-1.414 1.414L12 13.414l-4.95 4.95a1 1 0 0 1-1.414-1.414L10.586 12l-4.95-4.95a1 1 0 0 1 1.414-1.414L12 10.586l4.95-4.95a1 1 0 0 1 1.414 0z\",\r\n        fill: color\r\n      }).forEach(([k, v]) => path.setAttribute(k, v));\r\n\r\n      closeIconGroup.appendChild(path);\r\n      svg.appendChild(closeIconGroup);\r\n    } else {\r\n      const defs = document.createElementNS(svgUrl, \"defs\");\r\n      defs.classList.add(\"defs\");\r\n\r\n      const clipPath = document.createElementNS(svgUrl, \"clipPath\");\r\n      clipPath.setAttribute(\"id\", `clipInner-${randomString}`);\r\n      clipPath.classList.add(\"clipPath\");\r\n\r\n      const clipRect = document.createElementNS(svgUrl, \"rect\");\r\n      Object.entries({\r\n        x: center - radius, y: center - radius, width: diameter, height: 0, transform: `rotate(180, ${center}, ${center})`\r\n      }).forEach(([k, v]) => clipRect.setAttribute(k, v));\r\n      clipRect.classList.add(\"clipRect\");\r\n\r\n      const animate = document.createElementNS(svgUrl, \"animate\");\r\n      Object.entries({\r\n        attributeName: \"height\",\r\n        from: 0,\r\n        to: diameter * (percentage / 100),\r\n        begin: \"indefinite\",\r\n        dur: \"1s\",\r\n        fill: \"freeze\",\r\n        calcMode: \"spline\",\r\n        keySplines: \"0.4 0 0.2 1\", // Fast start, smooth stop\r\n        keyTimes: \"0;1\"\r\n      }).forEach(([k, v]) => animate.setAttribute(k, v));\r\n      animate.classList.add(\"animateProfileProgress\");\r\n\r\n      clipRect.appendChild(animate);\r\n      clipPath.appendChild(clipRect);\r\n      defs.appendChild(clipPath);\r\n      svg.appendChild(defs);\r\n\r\n      const outerCircle = document.createElementNS(svgUrl, \"circle\");\r\n      Object.entries({\r\n        cx: center, cy: center, r: radius, fill: \"none\", stroke: color, \"stroke-width\": strokeWidth\r\n      }).forEach(([k, v]) => outerCircle.setAttribute(k, v));\r\n      outerCircle.classList.add(\"outerCircle\");\r\n      svg.appendChild(outerCircle);\r\n\r\n      const innerCircle = document.createElementNS(svgUrl, \"circle\");\r\n      Object.entries({\r\n        cx: center, cy: center, r: radius, fill: color, \"clip-path\": `url(#clipInner-${randomString})`\r\n      }).forEach(([k, v]) => innerCircle.setAttribute(k, v));\r\n      innerCircle.classList.add(\"innerCircle\");\r\n      svg.appendChild(innerCircle);\r\n    }\r\n\r\n    return svg.outerHTML;\r\n  }\r\n\r\n  /**\r\n   * Calculates the percentage of a given number within its nearest range.\r\n   * The function dynamically determines the range based on the input value.\r\n   *\r\n   * @param {number} value - The input value to calculate the percentage for.\r\n   * @returns {number} - The percentage of the input value within its identified range.\r\n   */\r\n  function calculatePercentage(value) {\r\n    // Determine the lower bound of the range (this is smart, not hardcoded)\r\n    const lowerBound = Math.floor(value / 100) * 100; // Nearest lower multiple of 100\r\n    const upperBound = lowerBound + 100; // Nearest upper multiple of 100\r\n\r\n    // Calculate the percentage within the identified range\r\n    const percentage = ((value - lowerBound) / (upperBound - lowerBound)) * 100;\r\n\r\n    return percentage;\r\n  }\r\n\r\n  // Function to create a user element with avatar, name, and profile link based on user details\r\n  function createUserChatElement(userId, mainTitle, userName, bestSpeed, isRevoked) {\r\n    const avatarTimestamp = fetchedUsers[userId]?.avatarTimestamp;\r\n\r\n    // Ensure the bigAvatarUrl is only constructed if avatarTimestamp is not '00'\r\n    const bigAvatarUrl = avatarTimestamp !== '00' ? `/storage/avatars/${userId}_big.png?updated=${avatarTimestamp}` : '';\r\n\r\n    const newUserElement = document.createElement('div');\r\n    // Get rank information (class, color, icon)\r\n    const rankInfo = getRankInfo(mainTitle);\r\n    const rankClass = rankInfo.class;  // Rank class\r\n    const rankColor = rankInfo.color;  // Rank color\r\n    const rankIcon = rankInfo.icon;    // Rank icon (emoji)\r\n\r\n    newUserElement.classList.add(`user${userId}`, rankClass); // Assign the rank class\r\n\r\n    const newAvatarElement = document.createElement('div');\r\n    newAvatarElement.classList.add('avatar');\r\n\r\n    // Only create and append an image element if avatarTimestamp is not '00'\r\n    if (avatarTimestamp !== '00') {\r\n      const avatarImage = document.createElement('img');\r\n      avatarImage.src = bigAvatarUrl;\r\n      newAvatarElement.appendChild(avatarImage);\r\n    } else {\r\n      newAvatarElement.style.fontSize = '1.8rem';\r\n      // Insert a random SVG icon instead of an image when avatarTimestamp is '00'\r\n      newAvatarElement.innerHTML = (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.getRandomEmojiAvatar)();\r\n    }\r\n\r\n    const newNameElement = document.createElement('a');\r\n    newNameElement.classList.add('name');\r\n    newNameElement.title = 'Написать в приват';\r\n    newNameElement.dataset.user = userId;\r\n    newNameElement.textContent = userName;\r\n\r\n    newNameElement.style.setProperty('color', rankColor, 'important');\r\n\r\n    const newProfileElement = document.createElement('a');\r\n    newProfileElement.classList.add('profile');\r\n    const title = `${rankIcon} ${mainTitle} - ${bestSpeed}`;\r\n    (0,_modules_tooltip_js__WEBPACK_IMPORTED_MODULE_10__.createCustomTooltip)(newProfileElement, title);\r\n    newProfileElement.target = '_blank';\r\n    newProfileElement.href = `/profile/${userId}/`;\r\n    let circularProgress = createCircularProgress(calculatePercentage(bestSpeed), rankColor, isRevoked);\r\n    // Use circular progress element for profile navigation from new chat user list\r\n    newProfileElement.innerHTML = circularProgress;\r\n    // Start animation after element is in DOM\r\n    setTimeout(() => {\r\n      const animateElement = newProfileElement.querySelector('.animateProfileProgress');\r\n      if (animateElement) animateElement.beginElement();\r\n    }, 10);\r\n    // Add event listener click with Hold Ctrl Key to open profile into iframe\r\n    newProfileElement.addEventListener('click', function (event) {\r\n      event.preventDefault();\r\n      if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed) {\r\n        // Open the profile in a new tab\r\n        window.open(_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.profileBaseUrl + userId, '_blank');\r\n      } else {\r\n        // Load the profile into the iframe\r\n        loadProfileIntoIframe(_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.profileBaseUrl + userId);\r\n      }\r\n    });\r\n\r\n    // Construct the URL for the messaging interface between two users\r\n    const messageInProfile = `${_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.profileBaseUrl}${_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.myUserId}/messages/${userId}/`;\r\n\r\n    // Attach a click event listener to the newNameElement element\r\n    newNameElement.addEventListener('click', function (event) {\r\n      // Check if both Ctrl and Shift keys are pressed during the click event\r\n      if (event.ctrlKey && event.shiftKey) {\r\n        // If both keys are pressed, open the messaging URL in a new tab\r\n        const newTab = window.open(messageInProfile, '_blank');\r\n        if (newTab) newTab.focus(); // Attempt to make the new tab active\r\n      }\r\n      // Check if only the Ctrl key is pressed\r\n      else if (event.ctrlKey) {\r\n        // If Ctrl is pressed, load the messaging interface URL into the iframe\r\n        loadProfileIntoIframe(messageInProfile);\r\n      }\r\n      // If neither Ctrl nor Shift is pressed, initiate a private chat message\r\n      else {\r\n        // The insertPrivate function handles sending a private message to the specified user\r\n        insertPrivate(userId);\r\n      }\r\n    });\r\n\r\n    newUserElement.appendChild(newAvatarElement);\r\n    newUserElement.appendChild(newNameElement);\r\n    newUserElement.appendChild(newProfileElement);\r\n\r\n    // Check if there is a user in 'usersToTrack' array by their name and state\r\n    const userToTrack = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.find((user) =>\r\n      user.name === userName && user.state === 'thawed'\r\n    );\r\n\r\n    if (userToTrack) {\r\n      const trackedIcon = document.createElement('div');\r\n      trackedIcon.title = 'Tracked user';\r\n      trackedIcon.classList.add('tracked');\r\n      trackedIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.trackedSVG;\r\n      newUserElement.appendChild(trackedIcon);\r\n    }\r\n\r\n    // Check if the user is in the ignore list\r\n    const isIgnoredUser = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.ignored.includes(userName);\r\n\r\n    // Create and hide a message element if the user is in ignored\r\n    if (isIgnoredUser) {\r\n      const ignoredIcon = document.createElement('div');\r\n      ignoredIcon.title = 'Ignored user';\r\n      ignoredIcon.classList.add('ignored');\r\n      ignoredIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.ignoredSVG;\r\n      newUserElement.appendChild(ignoredIcon);\r\n    }\r\n\r\n    // Check if there is an <img> element with a src attribute containing the word \"moderator\" inside the <ins> element\r\n    const hasModeratorIcon = document.querySelector(`.userlist-content ins.user${userId} img[src*=\"moderator\"]`);\r\n\r\n    // Check if the user is in the moderator list\r\n    const isModerator = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.moderator.includes(userName);\r\n\r\n    // If a moderator icon is found or the current user is in the moderator array, append the moderator icon.\r\n    if (hasModeratorIcon || isModerator) {\r\n      const moderatorIcon = document.createElement('div');\r\n      moderatorIcon.classList.add('moderator');\r\n      moderatorIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.moderatorSVG; // Assuming 'icons.moderatorSVG' contains the SVG for the icon\r\n      newUserElement.appendChild(moderatorIcon);\r\n    }\r\n\r\n    return newUserElement;\r\n  }\r\n\r\n  // Function to update users in the custom chat\r\n  async function refreshUserList(retrievedLogin, actionType) {\r\n    try {\r\n      // Get the original user list container\r\n      const originalUserListContainer = document.querySelector('.userlist-content');\r\n\r\n      // Get or create the user list container\r\n      let userListContainer = document.querySelector('.chat-user-list');\r\n      if (!userListContainer) {\r\n        userListContainer = document.createElement('div');\r\n        userListContainer.classList.add('chat-user-list');\r\n\r\n        // Find the element with the class \"userlist\"\r\n        const userlistElement = document.querySelector('.userlist');\r\n\r\n        // Append the userListContainer to the userlistElement if found\r\n        if (userlistElement) {\r\n          userlistElement.appendChild(userListContainer);\r\n        }\r\n      }\r\n\r\n      // Define the rank order\r\n      const rankOrder = ['extra', 'cyber', 'superman', 'maniac', 'racer', 'profi', 'driver', 'amateur', 'newbie'];\r\n\r\n      // Create an object to store subparent elements for each rank class\r\n      const rankSubparents = {};\r\n\r\n      // Check if subparent elements already exist, if not, create them\r\n      rankOrder.forEach(rankClass => {\r\n        const existingSubparent = userListContainer.querySelector(`.rank-group-${rankClass}`);\r\n        if (!existingSubparent) {\r\n          rankSubparents[rankClass] = document.createElement('div');\r\n          rankSubparents[rankClass].classList.add(`rank-group-${rankClass}`);\r\n          userListContainer.appendChild(rankSubparents[rankClass]);\r\n        } else {\r\n          rankSubparents[rankClass] = existingSubparent;\r\n        }\r\n      });\r\n\r\n      // Create a set to store existing user IDs in the updated user list\r\n      const existingUserIds = new Set();\r\n\r\n      // Iterate over each user element in the original user list\r\n      for (const userElement of originalUserListContainer.querySelectorAll('ins')) {\r\n        const nameElement = userElement.querySelector('.name');\r\n        const userId = nameElement.getAttribute('data-user');\r\n        const userName = nameElement.textContent;\r\n\r\n        // Check if the user already exists in the updated user list\r\n        if (!existingUserIds.has(userId)) {\r\n          try {\r\n            // Retrieve the user's profile data\r\n            const { rank: mainTitle, login, registeredDate, bestSpeed, ratingLevel, friends, cars, avatarTimestamp } = await (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.getUserProfileData)(userId);\r\n\r\n            // If the user data is not already stored in the fetchedUsers object\r\n            if (!fetchedUsers[userId]) {\r\n              // Set rank, login, registeredDate, bestSpeed, ratingLevel, friends, cars, and avatarTimestamp\r\n              fetchedUsers[userId] = {\r\n                rank: mainTitle,\r\n                login,\r\n                registered: registeredDate,\r\n                bestSpeed,\r\n                ratingLevel,\r\n                friends,\r\n                cars,\r\n                avatarTimestamp\r\n              };\r\n            } else {\r\n              // Update the user's data\r\n              fetchedUsers[userId].rank = mainTitle;\r\n              fetchedUsers[userId].login = login;\r\n              fetchedUsers[userId].registered = registeredDate;\r\n              fetchedUsers[userId].bestSpeed = bestSpeed;\r\n              fetchedUsers[userId].ratingLevel = ratingLevel;\r\n              fetchedUsers[userId].friends = friends;\r\n              fetchedUsers[userId].cars = cars;\r\n              fetchedUsers[userId].avatarTimestamp = avatarTimestamp;\r\n            }\r\n\r\n            // Logging user action (enter or leave) using the formatted time\r\n            if (retrievedLogin === userName) {\r\n              if (actionType === 'enter') {\r\n                fetchedUsers[userId].visits = (fetchedUsers[userId].visits || 0) + 1;\r\n                fetchedUsers[userId].tracked = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.some(u => u.name === retrievedLogin);\r\n              }\r\n            }\r\n\r\n            // Get the rank info from getRankInfo, which now returns an object with class, color, and icon\r\n            const { class: rankClass } = getRankInfo(mainTitle);  // Destructure the returned object to get the rank class\r\n\r\n            // Check if the user with the same ID already exists in the corresponding rank group\r\n            const existingUserElement = rankSubparents[rankClass].querySelector(`.user${userId}`);\r\n            if (!existingUserElement) {\r\n              const newUserElement = createUserChatElement(userId, mainTitle, userName, bestSpeed, userElement.classList.contains('revoked'));\r\n              // Add the user to the corresponding rank group\r\n              rankSubparents[rankClass].appendChild(newUserElement);\r\n              // Make sure the mutation observer for the new users changed flag to false to make it work\r\n              if (!isInitialObservation) addShakeEffect(newUserElement); // Add shake effect on entered users\r\n            }\r\n\r\n            // Update existing user IDs\r\n            existingUserIds.add(userId);\r\n          } catch (error) {\r\n            console.error(`Error fetching profile summary for user ${userId}:`, error);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Additional removal logic based on your provided code\r\n      userListContainer.querySelectorAll('.chat-user-list [class^=\"user\"]').forEach(userElement => {\r\n        const userId = userElement.querySelector('.name').getAttribute('data-user');\r\n        if (!existingUserIds.has(userId)) {\r\n          userElement.remove();\r\n        }\r\n      });\r\n\r\n      // Sorting logic (applied after all users are created)\r\n      Object.values(rankSubparents).forEach(rankGroup =>\r\n        [...rankGroup.children]\r\n          .sort((a, b) =>\r\n            (fetchedUsers[b.querySelector('.name')?.getAttribute('data-user')]?.bestSpeed || 0) -\r\n            (fetchedUsers[a.querySelector('.name')?.getAttribute('data-user')]?.bestSpeed || 0)\r\n          )\r\n          .forEach(el => rankGroup.appendChild(el))\r\n      );\r\n\r\n      // Update localStorage outside the if conditions\r\n      localStorage.setItem('fetchedUsers', JSON.stringify(fetchedUsers));\r\n\r\n      // Call updateUserCountText to refresh user count display\r\n      (0,_modules_cache_js__WEBPACK_IMPORTED_MODULE_4__.updateUserCountText)();\r\n\r\n    } catch (error) {\r\n      console.error('Error refreshing user list:', error);\r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n  // NEW CHAT USER LIST (END)\r\n\r\n\r\n  // Define reference for chat user list\r\n  const userList = document.querySelector('.userlist-content');\r\n\r\n  // Initialize user tracking map\r\n  let userMap = new Map(); // Store as [userId]: {userName, ...}\r\n  let prevUserCount = 0;\r\n  let isInitialObservation = true; // Initialize the flag for initial observation\r\n\r\n  let isAnimated = false;\r\n\r\n  function logUserAction(userId, actionType) {\r\n    if (userId && actionType) {\r\n      // Initialize user object and ensure actionLog is an array\r\n      fetchedUsers[userId] = fetchedUsers[userId] || {};\r\n      fetchedUsers[userId].actionLog = fetchedUsers[userId].actionLog || [];\r\n\r\n      // Log the action\r\n      fetchedUsers[userId].actionLog.push({\r\n        type: actionType,\r\n        timestamp: (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.getCurrentTimeFormatted)()\r\n      });\r\n    } else {\r\n      console.error('Missing userId or actionType');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the given user count element with the count, adjusting the font size based on the number of digits.\r\n   * @param {HTMLElement} element - The DOM element displaying the user count.\r\n   * @param {number} count - The user count.\r\n   */\r\n  function updateUserCount(element, count) {\r\n    if (!element) return; // Exit if the element doesn't exist.\r\n    const digits = count.toString().length;\r\n    element.textContent = count;\r\n    element.style.fontSize = Math.max(24 - (digits - 1) * 2, 12) + 'px';\r\n  }\r\n\r\n  // Function to animate user count change\r\n  function animateUserCount(actualUserCount, userCountElement) {\r\n    let count = 0;\r\n    const speed = 20;\r\n\r\n    const userCountIncrement = () => {\r\n      if (count <= actualUserCount) {\r\n        const progress = Math.min(count / (actualUserCount || 1), 1); // Handle zero case\r\n        updateUserCount(userCountElement, count++);\r\n        userCountElement.style.filter = `grayscale(${100 - progress * 100}%)`;\r\n        setTimeout(userCountIncrement, speed);\r\n      } else {\r\n        (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.addPulseEffect)(userCountElement);\r\n        isAnimated = true;\r\n      }\r\n    };\r\n\r\n    setTimeout(userCountIncrement, speed);\r\n  }\r\n\r\n  // Mutation Observer for new users\r\n  const chatUsersObserver = new MutationObserver((0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.debounce)((mutations) => {\r\n    mutations.forEach((mutation) => {\r\n      if (mutation.type === 'childList') {\r\n        const soundSwitcher = document.querySelector('#voice, #beep, #silence');\r\n        const isSilence = soundSwitcher && soundSwitcher.id === 'silence';\r\n        const chatHidden = document.querySelector('#chat-wrapper.chat-hidden');\r\n        const userCountElement = document.querySelector('.chat-user-count');\r\n\r\n        if (chatHidden) {\r\n          // If the chat is hidden, update the user count to 0 and exit early\r\n          userCountElement.style.filter = \"grayscale(100%)\";\r\n          userCountElement.textContent = \"0\";\r\n          return;\r\n        }\r\n\r\n        // Build current user map\r\n        const newUsers = new Map(\r\n          Array.from(userList.children)\r\n            .map(child => {\r\n              const nameElement = child.querySelector('.name');\r\n              const userId = nameElement?.getAttribute('data-user');\r\n              const userName = nameElement?.textContent?.trim();\r\n              return userId ? [userId, { userName }] : null;\r\n            })\r\n            .filter(Boolean) // Remove null entries\r\n        );\r\n\r\n        // Handle initial observation\r\n        if (isInitialObservation) {\r\n          if (userCountElement && Number(userCountElement.textContent) === 0 && !isAnimated) {\r\n            animateUserCount(newUsers.size, userCountElement);\r\n          }\r\n          newUsers.forEach((value, key) => userMap.set(key, value));\r\n          setTimeout(() => {\r\n            isInitialObservation = false; // Mark the initial observation as complete\r\n          }, 2000); // After a small delay\r\n          return; // Skip processing for initial load\r\n        }\r\n\r\n        // Detect users who entered (exist in newUsers but not in userMap)\r\n        let entered = [...newUsers].filter(([userId]) => !userMap.has(userId))\r\n          .map(([userId, data]) => ({ userId, ...data }));\r\n\r\n        // Detect users who left (exist in userMap but not in newUsers)\r\n        let left = [...userMap].filter(([userId]) => !newUsers.has(userId))\r\n          .map(([userId, data]) => ({ userId, userName: data.userName }));\r\n\r\n        // Reassign userMap instead of clearing and repopulating it\r\n        userMap = new Map(newUsers);\r\n\r\n        // User count management\r\n        const currentCount = userMap.size;\r\n        if (currentCount !== prevUserCount && isAnimated) {\r\n          updateUserCount(userCountElement, currentCount);\r\n          userCountElement.style.filter = currentCount > 0 ? 'none' : 'grayscale(100%)';\r\n          (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.addPulseEffect)(userCountElement);\r\n        }\r\n\r\n        // Common logic for processing both entered and left users\r\n        function processUserAction(user, actionType) {\r\n          const { userName, userId } = user;\r\n          const userGender = getUserGender(userName);\r\n          const isTracked = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.some(u => u.name === userName && u.state === 'thawed');\r\n\r\n          (0,_modules_notifications_js__WEBPACK_IMPORTED_MODULE_11__.showUserAction)(userName, actionType === \"enter\" ? _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.enterSVG : _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.leaveSVG, actionType === \"enter\");\r\n          refreshUserList(userName, actionType);\r\n          logUserAction(userId, actionType);\r\n\r\n          if (!isSilence && isTracked) {\r\n            userAction(userName, actionType, userGender);\r\n          }\r\n        }\r\n\r\n        // Process entries\r\n        entered.forEach(newUser => processUserAction(newUser, \"enter\"));\r\n\r\n        // Process exits\r\n        left.forEach(oldUser => processUserAction(oldUser, \"leave\"));\r\n\r\n\r\n        prevUserCount = currentCount; // Update previous count for next mutation\r\n      }\r\n    });\r\n  }, _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.debounceTimeout));\r\n\r\n  // Start observing\r\n  chatUsersObserver.observe(userList, { childList: true });\r\n\r\n  // Button to close the chat\r\n  const chatCloseButton = document.querySelector('.mostright');\r\n\r\n  // Event listener for mostright click event\r\n  chatCloseButton.addEventListener('click', () => {\r\n    // Trigger the logic you want to perform when the mostright button is clicked\r\n    setTimeout(() => {\r\n      // Check if the chat is not closed\r\n      const chatHidden = document.querySelector('#chat-wrapper.chat-hidden');\r\n      if (chatHidden) {\r\n        // Avoid \"newMessagesObserver\" run the call functions multiple times when the chat opens again\r\n        isInitialized = false;\r\n      } else {\r\n        // Call the function to assign all the removing functionality again after the chat was closed\r\n        executeMessageRemover();\r\n        // Set chat field focus\r\n        (0,_modules_chat_js__WEBPACK_IMPORTED_MODULE_9__.setChatFieldFocus)();\r\n        // Allow after \"N\" delay to run the \"newMessagesObserver\" call functions safely without repeating\r\n        isInitialized = false;\r\n        setTimeout(() => (isInitialized = false), 3000);\r\n      }\r\n    }, 300);\r\n  });\r\n\r\n  // Function to restore the chat state based on 'shouldShowPopupMessage' key in localStorage\r\n  function restoreChatState() {\r\n    // Main chat parent wrap element\r\n    const chatMainWrapper = document.querySelector('#chat-fixed-placeholder');\r\n\r\n    // Check if the key exists in localStorage\r\n    if ('shouldShowPopupMessage' in localStorage) {\r\n      // Retrieve the value from localStorage\r\n      const shouldShowPopupMessage = JSON.parse(localStorage.getItem('shouldShowPopupMessage'));\r\n\r\n      // Set the display property based on the retrieved value\r\n      chatMainWrapper.style.display = shouldShowPopupMessage ? 'none' : 'unset';\r\n    } else {\r\n      // Default to 'none' if the key doesn't exist\r\n      chatMainWrapper.style.display = 'none';\r\n    }\r\n  }\r\n\r\n  // Call restoreChatState when needed, for example, on page load\r\n  restoreChatState();\r\n\r\n  // Check if the key exists in localStorage\r\n  if (!('shouldShowPopupMessage' in localStorage)) {\r\n    localStorage.setItem('shouldShowPopupMessage', false);\r\n  }\r\n\r\n  // Custom chat hider with hotkeys Ctr + Space\r\n  document.addEventListener('keydown', (event) => {\r\n    // Check if Ctrl key and Space key are pressed simultaneously\r\n    if (event.ctrlKey && event.code === 'Space') {\r\n      // Main chat parent wrap element\r\n      const chatMainWrapper = document.querySelector('#chat-fixed-placeholder');\r\n      // Check if the 'style' attribute is present\r\n      const hasStyleAttribute = chatMainWrapper.hasAttribute('style');\r\n      // Check if the 'display' property is set on chatMainWrapper element\r\n      const isDisplayUnset = chatMainWrapper.style.display === 'unset';\r\n      // Popup messages container element\r\n      const popupMessagesContainer = document.querySelector('.popup-messages-container');\r\n\r\n      // Toggle the display property\r\n      if (hasStyleAttribute) {\r\n        if (isDisplayUnset) {\r\n          // Set the display property to 'none'\r\n          chatMainWrapper.style.display = 'none';\r\n          localStorage.setItem('shouldShowPopupMessage', true);\r\n        } else {\r\n          // Set the display property to 'unset'\r\n          chatMainWrapper.style.display = 'unset';\r\n          localStorage.setItem('shouldShowPopupMessage', false);\r\n\r\n          // Retrieve the chat input field and length popup container based on the current URL\r\n          const { inputField } = retrieveChatElementsByRoomType(); // Use your helper function\r\n\r\n          // Check if inputField is valid before focusing\r\n          if (inputField) {\r\n            inputField.focus(); // Set focus to the chat input field\r\n          } else {\r\n            console.error('Input field not found. Cannot set focus.');\r\n          }\r\n        }\r\n      } else {\r\n        // Initial case: Set the display property to 'none'\r\n        chatMainWrapper.style.display = 'none';\r\n        localStorage.setItem('shouldShowPopupMessage', true);\r\n      }\r\n\r\n      // Remove the element with class 'popup-messages-container' if it exists and display is 'unset'\r\n      if (popupMessagesContainer && hasStyleAttribute && isDisplayUnset) {\r\n        popupMessagesContainer.remove();\r\n      }\r\n    }\r\n  });\r\n\r\n  // EVERY NEW MESSAGE READER\r\n\r\n  // Initialize the variable to keep track of the last username seen\r\n  let lastUsername = null;\r\n\r\n  // Set the flag as false for the mention beep sound to trigger at first usual beep sound for usual messages\r\n  let isMention = false;\r\n\r\n  // Function to check if a username is mentioned in the message\r\n  function isMentionForMe(message) {\r\n    const messageLowercase = message.toLowerCase();\r\n    return _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.mentionKeywords.some(keyword => messageLowercase.includes(keyword.toLowerCase()));\r\n  }\r\n\r\n  function replaceWithPronunciation(text) {\r\n    if (text === null) return text;\r\n\r\n    // Combine all usernames that need replacement\r\n    const allUsernames = [\r\n      ..._modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.map(user => user.name),\r\n      ..._modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usernameReplacements.map(replacement => replacement.original)\r\n    ];\r\n\r\n    // Create a pattern to match any character that is part of a word (including Cyrillic characters).\r\n    const pattern = new RegExp(`(${allUsernames.join('|')})`, 'gu');\r\n\r\n    return text.replace(pattern, (matched) => {\r\n      // Priority 1: Check username replacements\r\n      const replacement = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usernameReplacements.find(r => r.original === matched);\r\n      if (replacement) return replacement.replacement;\r\n\r\n      // Priority 2: Check tracked user pronunciations\r\n      const trackedUser = _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.usersToTrack.find(user => user.name === matched);\r\n      return trackedUser?.pronunciation || matched;\r\n    });\r\n  }\r\n\r\n\r\n\r\n  const rgbToHsl = (r, g, b) => {\r\n    r /= 255;\r\n    g /= 255;\r\n    b /= 255;\r\n\r\n    const max = Math.max(r, g, b);\r\n    const min = Math.min(r, g, b);\r\n    let h, s, l = (max + min) / 2;\r\n\r\n    if (max === min) {\r\n      h = s = 0; // Achromatic\r\n    } else {\r\n      const delta = max - min;\r\n      s = l < 0.5 ? delta / (max + min) : delta / (2 - max - min);\r\n      h = (\r\n        max === r\r\n          ? (g - b) / delta + (g < b ? 6 : 0)\r\n          : max === g\r\n            ? (b - r) / delta + 2\r\n            : (r - g) / delta + 4\r\n      ) / 6;\r\n    }\r\n\r\n    h = Math.round(h * 360); // Convert to degrees\r\n    s = Math.min(Math.round(s * 100), 90); // Cap saturation at 90\r\n    l = Math.round(l * 100); // Convert lightness to 0–100\r\n\r\n    // Adjust hue to allow only 0–230 and 280–360 ranges\r\n    if (h > 215 && h < 280) {\r\n      h = h < 255 ? 215 : 280; // Shift to nearest valid range\r\n    }\r\n\r\n    return { h, s, l };\r\n  };\r\n\r\n\r\n  const hslToRgb = (h, s, l) => {\r\n    s /= 100; l /= 100;\r\n    let r, g, b;\r\n    if (s === 0) r = g = b = l * 255; // Achromatic\r\n    else {\r\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;\r\n      const hue2rgb = (p, q, t) => {\r\n        if (t < 0) t += 1;\r\n        if (t > 1) t -= 1;\r\n        return t < 1 / 6 ? p + (q - p) * 6 * t :\r\n          t < 1 / 2 ? q :\r\n            t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :\r\n              p;\r\n      };\r\n      r = Math.round(hue2rgb(p, q, h / 360 + 1 / 3) * 255);\r\n      g = Math.round(hue2rgb(p, q, h / 360) * 255);\r\n      b = Math.round(hue2rgb(p, q, h / 360 - 1 / 3) * 255);\r\n    }\r\n    return `rgb(${r}, ${g}, ${b})`;\r\n  };\r\n\r\n  // Normalize chat username color to be readable in the personal messages panel\r\n  function normalizeUsernameColor(initialColor) {\r\n    const [r, g, b] = initialColor.match(/\\d+/g).map(Number);\r\n    const { h, s, l } = rgbToHsl(r, g, b);\r\n\r\n    // Adjust lightness to ensure it's at least 50\r\n    const normalizedLightness = l < 50 ? 50 : l;\r\n    const finalColor = hslToRgb(h, s, normalizedLightness);\r\n\r\n    // Round the RGB values in one go\r\n    return finalColor;\r\n  }\r\n\r\n  async function getLatestMessageData() {\r\n    const messageElement = document.querySelector('.messages-content div p:last-of-type');\r\n    if (!messageElement) return null;\r\n\r\n    // Inline helper: collects text parts from a container's child nodes.\r\n    const collectMessageParts = async (container) =>\r\n      Array.from(container.childNodes)\r\n        .map(node =>\r\n          node.nodeType === Node.TEXT_NODE && node.textContent.trim() ? node.textContent.trim() :\r\n            node.nodeName === 'IMG' && node.getAttribute('title') ? node.getAttribute('title') :\r\n              node.nodeName === 'A' && node.getAttribute('href') ? node.getAttribute('href') : ''\r\n        )\r\n        .filter(Boolean);\r\n\r\n    // 1. Extract common message text.\r\n    let finalMessageText = (await collectMessageParts(messageElement)).join(' ').trim();\r\n    let messageType = \"common\"; // Default message type\r\n\r\n    // 2. Check for private messages\r\n    const privateMessageContainer = messageElement.querySelector('.room.private');\r\n    if (privateMessageContainer && privateMessageContainer.textContent.includes('[шепчет ')) {\r\n      const privateMessageElement = messageElement.querySelector('span.private');\r\n      if (privateMessageElement) {\r\n        finalMessageText = (await collectMessageParts(privateMessageElement)).join(' ').trim();\r\n        messageType = \"private\";\r\n      }\r\n    }\r\n\r\n    // 3. Check for system messages\r\n    const systemMessageElement = messageElement.querySelector('.system-message');\r\n    if (systemMessageElement) {\r\n      let systemMessageText = (await collectMessageParts(systemMessageElement)).join(' ').trim();\r\n      systemMessageText = systemMessageText.replace(/<Клавобот>\\s*/g, '');\r\n      finalMessageText = systemMessageText;\r\n      messageType = \"system\";\r\n    }\r\n\r\n    // 4. If still \"common\" and it mentions the user, mark as \"mention\".\r\n    if (messageType === \"common\" && isMentionForMe(finalMessageText)) {\r\n      messageType = \"mention\";\r\n    }\r\n\r\n    // Process localStorage: retrieve or initialize personalMessages.\r\n    const personalMessages = JSON.parse(localStorage.getItem('personalMessages')) || {};\r\n    const getCurrentDate = () => new Date().toLocaleDateString('en-CA');\r\n\r\n    // Extract message metadata.\r\n    const time = messageElement.querySelector('.time')?.textContent || 'N/A';\r\n    const usernameDataElement = messageElement.querySelector('.username span[data-user]');\r\n    const userId = usernameDataElement ? usernameDataElement.getAttribute('data-user') : null;\r\n    const extractedUsername = usernameDataElement ? usernameDataElement.textContent : 'SYSTEM';\r\n    const usernameColor = usernameDataElement ? usernameDataElement.parentElement.style.color : 'rgb(180,180,180)';\r\n    const normalizedColor = normalizeUsernameColor(usernameColor);\r\n    const messageKey = `${time}_${extractedUsername}`;\r\n\r\n    // Check if the message type is \"mention\" or \"private\", and if the username is not in the ignore list\r\n    const shouldSaveMessage = (\r\n      messageType === \"mention\" ||\r\n      messageType === \"private\"\r\n    ) && !_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.ignored.includes(extractedUsername);\r\n\r\n    // If the condition is met, save the message to localStorage\r\n    if (shouldSaveMessage) {\r\n      personalMessages[messageKey] = {\r\n        time,\r\n        date: getCurrentDate(),\r\n        username: extractedUsername,\r\n        usernameColor: normalizedColor,\r\n        message: finalMessageText,\r\n        type: messageType,\r\n        userId\r\n      };\r\n      localStorage.setItem('personalMessages', JSON.stringify(personalMessages));\r\n    }\r\n\r\n    // Extract username (defaulting to \"SYSTEM\") and build prefix.\r\n    const usernameContainer = messageElement.querySelector('.username');\r\n    const usernameText = usernameContainer ? usernameContainer.textContent.replace(/[<>]/g, '') : 'SYSTEM';\r\n\r\n    (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.highlightMentionWords)(); // Apply highlight for all message types\r\n\r\n    let prefix = (messageType === \"mention\" || messageType === \"private\")\r\n      ? `${replaceWithPronunciation(usernameText)} обращается: `\r\n      : (usernameText !== lastUsername ? `${replaceWithPronunciation(usernameText)} пишет: ` : \"\");\r\n\r\n    lastUsername = usernameText;\r\n\r\n    const messageText = prefix + replaceWithPronunciation(finalMessageText);\r\n    return { messageText, usernameText };\r\n  }\r\n\r\n  // Prevent the \"readNewMessages\" function from being called multiple times until all messages in the set have been read\r\n  let isReading = false;\r\n\r\n  // Create a Set to store the new messages\r\n  const newMessages = new Set();\r\n\r\n  // This function adds a new message to the Set and triggers the \"readNewMessages\" function if the Set was empty before\r\n  function addNewMessage(message) {\r\n    // Check if the new message is not already in the Set\r\n    if (!newMessages.has(message)) {\r\n      // Add the new message to the Set\r\n      newMessages.add(message);\r\n      // If the \"readNewMessages\" function is not already in progress, trigger it\r\n      if (!isReading) {\r\n        // Change the flag to true to be initialized accent beep sound for mention message\r\n        isReading = true;\r\n        readNewMessages();\r\n      }\r\n    }\r\n  }\r\n\r\n  // This function reads the new messages from the Set and removes them after reading\r\n  async function readNewMessages() {\r\n    // Read each message in sequence from the Set\r\n    for (let message of newMessages) {\r\n      // Call the textToSpeech function to read the message\r\n      await textToSpeech(message, voiceSpeed);\r\n      // Remove the message from the Set after reading\r\n      newMessages.delete(message);\r\n    }\r\n    // Set the isReading flag to false after reading all messages\r\n    isReading = false;\r\n  }\r\n\r\n\r\n\r\n  function applyChatMessageGrouping() {\r\n    // Get the messages container element\r\n    const messagesContainer = document.getElementById('chat-content');\r\n\r\n    // Get all the chat message elements from the messages container\r\n    const chatMessages = messagesContainer.querySelectorAll('.messages-content div p');\r\n\r\n    // Initialize variables\r\n    let previousUser = null;\r\n    let isFirstMessage = true;\r\n    let spacing = '14px';\r\n\r\n    // Loop through the chat messages\r\n    for (let i = 0; i < chatMessages.length; i++) {\r\n      const message = chatMessages[i];\r\n      const usernameElement = message.querySelector('span.username');\r\n\r\n      // Check if it's a system message with the \"system-message\" class\r\n      const isSystemMessage = message.querySelector('.system-message');\r\n\r\n      if (isSystemMessage) {\r\n        // Apply margins to system messages\r\n        message.style.marginTop = spacing;\r\n        message.style.marginBottom = spacing;\r\n      } else if (usernameElement) { // Check if the message contains a username\r\n        // Get the username from the current message\r\n        const usernameElementWithDataUser = usernameElement.querySelector('span[data-user]');\r\n\r\n        if (!usernameElementWithDataUser) {\r\n          continue; // Skip messages without a data-user element\r\n        }\r\n\r\n        let usernameText = usernameElementWithDataUser.textContent;\r\n\r\n        // Remove the \"<\" and \">\" symbols from the username if they are present\r\n        usernameText = usernameText.replace(/</g, '').replace(/>/g, '');\r\n\r\n        // Apply margin-top for the first message or when the user changes\r\n        if (previousUser === null || usernameText !== previousUser) {\r\n          // Check if it's not the first message overall\r\n          if (!isFirstMessage) {\r\n            // Add margin-top to create separation between the current message and the previous message\r\n            message.style.marginTop = spacing;\r\n          }\r\n        } else {\r\n          // Check if it's not the first message of the current user\r\n          if (!isFirstMessage) {\r\n            // Remove the margin-bottom property from the current message to remove any previously set margin\r\n            message.style.removeProperty('margin-bottom');\r\n          }\r\n        }\r\n\r\n        // Check if there is a next message\r\n        const hasNextMessage = i < chatMessages.length - 1;\r\n\r\n        // Check if there is a next message and it contains a username\r\n        if (hasNextMessage) {\r\n          const nextMessage = chatMessages[i + 1];\r\n          const nextUsernameElement = nextMessage.querySelector('span.username');\r\n\r\n          if (nextUsernameElement) {\r\n            const nextUsernameElementWithDataUser = nextUsernameElement.querySelector('span[data-user]');\r\n\r\n            if (!nextUsernameElementWithDataUser) {\r\n              continue; // Skip messages without a data-user element\r\n            }\r\n\r\n            // Get the username from the next message\r\n            const nextUsernameText = nextUsernameElementWithDataUser.textContent;\r\n\r\n            // Apply margin-bottom for the last message of each user\r\n            if (usernameText !== nextUsernameText) {\r\n              message.style.marginBottom = spacing;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Update the previousUser variable to store the current username\r\n        previousUser = usernameText;\r\n        // Set isFirstMessage to false to indicate that this is not the first message overall\r\n        isFirstMessage = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Call the function to apply chat message grouping\r\n  applyChatMessageGrouping();\r\n\r\n  // Time difference threshold (in milliseconds) to identify spam\r\n  const timeDifferenceThreshold = 400;\r\n  // Message limit per timeDifferenceThreshold\r\n  const messageLimit = 1;\r\n  // Object to track user-specific data\r\n  let userChatData = {};\r\n  // Maximum number of consecutive times a user is allowed to exceed the message limit\r\n  const thresholdMaxTries = 10;\r\n\r\n  // Function to format time difference\r\n  function formatTimeDifference(difference) {\r\n    // Define time units\r\n    const units = ['hour', 'minute', 'second', 'millisecond'];\r\n\r\n    // Calculate values for each time unit\r\n    const values = [\r\n      Math.floor(difference / (1000 * 60 * 60)), // hours\r\n      Math.floor((difference / (1000 * 60)) % 60), // minutes\r\n      Math.floor((difference / 1000) % 60), // seconds\r\n      difference % 1000 // milliseconds\r\n    ];\r\n\r\n    // Map each non-zero value to a formatted string with its corresponding unit\r\n    const formattedStrings = values\r\n      .map((value, index) => (value > 0 ? `${value} ${units[index]}${value > 1 ? 's' : ''}` : ''));\r\n\r\n    // Filter out empty strings (units with a value of 0) and join the remaining strings\r\n    const formattedTime = formattedStrings\r\n      .filter(Boolean)\r\n      .join(' ');\r\n\r\n    // Return the formatted time string\r\n    return formattedTime;\r\n  }\r\n\r\n  // Helper function to remove all messages by a user\r\n  function removeUserMessages(userId) {\r\n    const userMessages = document.querySelectorAll(`.messages-content span[data-user=\"${userId}\"]`);\r\n    userMessages.forEach(message => {\r\n      const pTag = message.closest('p');\r\n      if (pTag) {\r\n        pTag.remove();\r\n      }\r\n    });\r\n  }\r\n\r\n  const digits = '0-9';\r\n  const whitespaces = '\\\\s';\r\n  const latinChars = 'a-zA-Z';\r\n  const cyrillicChars = 'а-яА-ЯёЁ';\r\n  const commonSymbols = '!@#$%^&*()-_=+[\\\\]{}|;:\\'\",.<>/?`~';\r\n\r\n  // Special symbols as characters\r\n  const copyrightSymbol = '\\\\u00A9'; // ©\r\n  const trademarkSymbol = '\\\\u2122'; // ™\r\n  const registeredSymbol = '\\\\u00AE'; // ®\r\n  const leftDoubleAngleQuote = '\\\\u00AB'; // «\r\n  const rightDoubleAngleQuote = '\\\\u00BB'; // »\r\n  const plusMinus = '\\\\u00B1'; // ±\r\n  const multiplication = '\\\\u00D7'; // ×\r\n  const division = '\\\\u00F7'; // ÷\r\n  const degreeSymbol = '\\\\u00B0'; // °\r\n  const notEqual = '\\\\u2260'; // ≠\r\n  const lessThanOrEqual = '\\\\u2264'; // ≤\r\n  const greaterThanOrEqual = '\\\\u2265'; // ≥\r\n  const infinity = '\\\\u221E'; // ∞\r\n  const euroSymbol = '\\\\u20AC'; // €\r\n  const poundSymbol = '\\\\u00A3'; // £\r\n  const yenSymbol = '\\\\u00A5'; // ¥\r\n  const sectionSymbol = '\\\\u00A7'; // §\r\n  const bulletPoint = '\\\\u2022'; // •\r\n  const ellipsis = '\\\\u2026'; // …\r\n  const minus = '\\\\u2212'; // −\r\n  const enDash = '\\\\u2013'; // –\r\n  const emDash = '\\\\u2014'; // —\r\n\r\n  // Arrow and Mathematical symbols as Unicode escape sequences\r\n  const leftArrow = '\\\\u2190'; // ←\r\n  const rightArrow = '\\\\u2192'; // →\r\n  const upArrow = '\\\\u2191'; // ↑\r\n  const downArrow = '\\\\u2193'; // ↓\r\n\r\n  const half = '\\\\u00BD'; // ½\r\n  const oneThird = '\\\\u2153'; // ⅓\r\n  const twoThirds = '\\\\u2154'; // ⅔\r\n\r\n  const summation = '\\\\u2211'; // ∑\r\n  const acuteAccent = '\\\\u00B4'; // ´\r\n\r\n  const emojiRanges = '\\\\uD83C-\\\\uDBFF\\\\uDC00-\\\\uDFFF';\r\n\r\n  // Initialized to store characters found in a message that are not allowed\r\n  let disallowedChars = null;\r\n\r\n  function messageContainsAllowedChars(message) {\r\n    const allowedCharsRegex = new RegExp(\r\n      `[${digits}${latinChars}${cyrillicChars}${whitespaces}${commonSymbols}` +\r\n      `${copyrightSymbol}${trademarkSymbol}${registeredSymbol}${leftDoubleAngleQuote}${rightDoubleAngleQuote}` +\r\n      `${plusMinus}${multiplication}${division}${degreeSymbol}${notEqual}${lessThanOrEqual}${greaterThanOrEqual}` +\r\n      `${infinity}${euroSymbol}${poundSymbol}${yenSymbol}${sectionSymbol}${bulletPoint}${ellipsis}${minus}${enDash}${emDash}` +\r\n      `${leftArrow}${rightArrow}${upArrow}${downArrow}${half}${oneThird}${twoThirds}${summation}` +\r\n      `${acuteAccent}${emojiRanges}]+`, 'gu' // previous 'g'\r\n    );\r\n\r\n    const allowedChars = message.match(allowedCharsRegex);\r\n\r\n    if (allowedChars && allowedChars.join('') === message) {\r\n      return true;\r\n    } else {\r\n      disallowedChars = message.replace(allowedCharsRegex, '');\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Helper function to handle threshold check\r\n  function handleThresholdExceeded(userId, generateLogUserInfo) {\r\n    if (userChatData[userId].thresholdMaxTries >= thresholdMaxTries) {\r\n      // Set 'banned' to true after passing the max thresholdMaxTries to remove user messages passing the messages limit checking\r\n      userChatData[userId].banned = true;\r\n      console.log(generateLogUserInfo(), 'color: pink');\r\n      console.log(`%c${userChatData[userId].userName} cannot send messages anymore`, 'color: pink');\r\n    }\r\n  }\r\n\r\n  // Function to track and handle spam messages\r\n  function banSpammer() {\r\n    // Get the current timestamp\r\n    const currentTime = new Date().getTime();\r\n\r\n    // Select the last p element in the chat\r\n    const latestMessage = document.querySelector('.messages-content p:last-child');\r\n\r\n    if (latestMessage) {\r\n      // Get user ID from the last message\r\n      const userIdElement = latestMessage.querySelector('span[data-user]');\r\n      const userId = userIdElement ? userIdElement.getAttribute('data-user') : null;\r\n\r\n      // Initialize user-specific data outside the if block\r\n      if (!userChatData[userId]) {\r\n        userChatData[userId] = {\r\n          messagesCount: 0,\r\n          thresholdMaxTries: 0,\r\n          time: currentTime,\r\n          userName: userIdElement ? userIdElement.textContent : 'Unknown User',\r\n          previousTime: null,\r\n          firstInteraction: true,\r\n          banned: false\r\n        };\r\n      }\r\n\r\n      // Calculate time difference\r\n      const timeDifference = currentTime - userChatData[userId].time;\r\n\r\n      // Function to generate log information dynamically\r\n      function generateLogUserInfo() {\r\n        return `%cID: ${userId}, Name: ${userChatData[userId].userName}, ` +\r\n          `Time Difference: ${formatTimeDifference(timeDifference)}, ` +\r\n          `Messages Count: ${userChatData[userId].messagesCount}, ` +\r\n          `Spam Tries: ${userChatData[userId].thresholdMaxTries}, ` +\r\n          `Banned: ${userChatData[userId].banned}`;\r\n      }\r\n\r\n      // Check if the message contains not allowed chars\r\n      if (!messageContainsAllowedChars(latestMessage.textContent, userId) && !userChatData[userId].banned) {\r\n        // Increase thresholdMaxTries on every limit pass\r\n        userChatData[userId].thresholdMaxTries++;\r\n        // If the message contains not allowed chars, log the information\r\n        console.log(\r\n          `%c${userChatData[userId].userName} has sent a message with not allowed characters ${disallowedChars}.\r\n          Threshold: ${userChatData[userId].thresholdMaxTries}.`,\r\n          'color: orange;'\r\n        );\r\n        handleThresholdExceeded(userId, generateLogUserInfo);\r\n      }\r\n\r\n      // Special handling for the first interaction\r\n      if (userChatData[userId].firstInteraction) {\r\n        console.log(`%c${userChatData[userId].userName} posted the first message for the current chat session.`, 'color: yellow');\r\n        userChatData[userId].firstInteraction = false;\r\n      }\r\n\r\n      // Check if the user is banned\r\n      else if (userChatData[userId].banned) {\r\n        // Remove all the messages by that user continuously until banned\r\n        removeUserMessages(userId);\r\n      } else {\r\n        if (timeDifference < timeDifferenceThreshold) {\r\n          // Check if the time difference is less than the threshold\r\n          userChatData[userId].messagesCount++;\r\n\r\n          if (userChatData[userId].messagesCount > messageLimit) {\r\n            // Remove all messages by that user if messages limit was exceeded\r\n            removeUserMessages(userId);\r\n\r\n            // Increase thresholdMaxTries on every limit pass\r\n            userChatData[userId].thresholdMaxTries++;\r\n\r\n            handleThresholdExceeded(userId, generateLogUserInfo);\r\n\r\n            // Log the information immediately after updating the values if not banned\r\n            if (!userChatData[userId].banned) {\r\n              console.log(generateLogUserInfo(), 'color: red');\r\n            }\r\n          } else {\r\n            // Log the information immediately after updating the values if not banned and not exceeding the limit\r\n            console.log(generateLogUserInfo(), 'color: green');\r\n          }\r\n        } else {\r\n          // If none of the above conditions are met, update user-specific data for the current interaction\r\n          userChatData[userId].previousTime = userChatData[userId].time;\r\n          userChatData[userId].time = currentTime;\r\n          userChatData[userId].messagesCount = 1;\r\n\r\n          // Log the information immediately after updating the values if not banned and not exceeding the limit\r\n          console.log(generateLogUserInfo(), 'color: green');\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  // POPUP MESSAGES START\r\n\r\n  // Set the maximum number of popup messages to display globally\r\n  const maxPopupMessagesCount = 10;\r\n\r\n  // Define an object to store the hue for each username\r\n  const usernameHueMap = {};\r\n  // Increase step for noticeable color changes\r\n  const hueStep = 15;\r\n\r\n  // Define the function to show popup messages when the main chat is hidden by hotkeys Ctrl + Space (only)\r\n  function showPopupMessage() {\r\n    // Check if the key 'shouldShowPopupMessage' exists and has a value of true\r\n    const shouldShowPopupMessage = localStorage.getItem('shouldShowPopupMessage');\r\n\r\n    // Stop execution if shouldShowPopupMessage is false\r\n    if (shouldShowPopupMessage !== 'true') {\r\n      return;\r\n    }\r\n\r\n    // Get the last message in the chat\r\n    const latestMessage = document.querySelector('.messages-content p:last-of-type');\r\n\r\n    if (latestMessage) {\r\n      // Extract elements for time and username from the latest message\r\n      const time = latestMessage.querySelector('.time');\r\n      const username = latestMessage.querySelector('.username');\r\n\r\n      const nodes = Array.from(latestMessage.childNodes);\r\n      const elements = nodes.map(node => {\r\n        if (node.nodeType === Node.TEXT_NODE) {\r\n          return { type: 'text', value: node.nodeValue.replace(/ /g, '\\u00A0') }; // Replace spaces with Unicode non-breaking space\r\n        } else if (node.nodeType === Node.ELEMENT_NODE) {\r\n          if (node.tagName.toLowerCase() === 'a' && node.classList.contains('private')) {\r\n            return { type: 'text', value: '📢\\u00A0' };\r\n          }\r\n          if (node.tagName.toLowerCase() === 'span' && node.classList.contains('private')) {\r\n            return { type: 'text', value: node.textContent.replace(/ /g, '\\u00A0') };\r\n          }\r\n          if (node.tagName.toLowerCase() === 'img') {\r\n            return { type: 'img', title: node.getAttribute('title') };\r\n          }\r\n          if (node.tagName.toLowerCase() === 'a') {\r\n            return { type: 'anchor', href: node.getAttribute('href') };\r\n          }\r\n        }\r\n      }).filter(Boolean);\r\n\r\n      // Extract relevant data from the time and username elements\r\n      const cleanTime = time.textContent.replace(/[\\[\\]]/g, '');\r\n      const cleanUsername = username.textContent.replace(/[<>]/g, '');\r\n\r\n      // Check if the hue for this username is already stored\r\n      let hueForUsername = usernameHueMap[cleanUsername];\r\n\r\n      // If the hue is not stored, generate a new random hue with the specified step\r\n      if (!hueForUsername) {\r\n        hueForUsername = Math.floor(Math.random() * (360 / hueStep)) * hueStep;\r\n        // Store the generated hue for this username\r\n        usernameHueMap[cleanUsername] = hueForUsername;\r\n      }\r\n\r\n      // Create or get the main container for all messages\r\n      let popupMessagesContainer = document.querySelector('.popup-messages-container');\r\n      if (!popupMessagesContainer) {\r\n        popupMessagesContainer = document.createElement('div');\r\n        popupMessagesContainer.classList.add('popup-messages-container');\r\n        document.body.appendChild(popupMessagesContainer);\r\n      }\r\n\r\n      // Check if the total number of messages in the container exceeds the maximum\r\n      if (popupMessagesContainer.childElementCount >= maxPopupMessagesCount) {\r\n        // Get the oldest message\r\n        const oldestMessage = popupMessagesContainer.firstChild;\r\n\r\n        // Apply a CSS class to initiate the fade-out animation\r\n        oldestMessage.classList.add('fade-out');\r\n\r\n        // After the animation duration, remove the message from the DOM\r\n        setTimeout(() => {\r\n          popupMessagesContainer.removeChild(oldestMessage);\r\n        }, 300); // Adjust the time to match your CSS animation duration\r\n      }\r\n\r\n      // Create a container div for each message\r\n      const popupChatMessage = document.createElement('div');\r\n      popupChatMessage.classList.add('popup-chat-message');\r\n      // Apply the hue-rotate filter to the entire message container\r\n      popupChatMessage.style.filter = `hue-rotate(${hueForUsername}deg)`;\r\n\r\n      // Append time SVG icon before the time\r\n      const timeIcon = document.createElement('div');\r\n      timeIcon.classList.add('time-icon');\r\n      timeIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.clockSVG;\r\n\r\n      // Append spans for each part with respective classes\r\n      const timeElement = document.createElement('div');\r\n      timeElement.classList.add('time');\r\n      timeElement.textContent = cleanTime;\r\n\r\n      // Append user SVG icon after the time\r\n      const userIcon = document.createElement('div');\r\n      userIcon.classList.add('user-icon');\r\n      userIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.userSVG;\r\n\r\n      const usernameElement = document.createElement('div');\r\n      usernameElement.classList.add('username');\r\n      usernameElement.textContent = cleanUsername;\r\n\r\n      // Append action SVG icon after the username\r\n      const actionIcon = document.createElement('div');\r\n      actionIcon.classList.add('action-icon');\r\n      actionIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.actionSVG;\r\n\r\n      const messageElement = document.createElement('div');\r\n      messageElement.classList.add('message');\r\n\r\n      // Append elements to the message container\r\n      popupChatMessage.appendChild(timeIcon);\r\n      popupChatMessage.appendChild(timeElement);\r\n      popupChatMessage.appendChild(userIcon);\r\n      popupChatMessage.appendChild(usernameElement);\r\n      popupChatMessage.appendChild(actionIcon);\r\n      popupChatMessage.appendChild(messageElement);\r\n\r\n      // Fill the message container with text, images, and anchors\r\n      elements.forEach(element => {\r\n        const elementContainer = document.createElement('div');\r\n\r\n        if (element.type === 'text') {\r\n          elementContainer.textContent = element.value;\r\n        } else if (element.type === 'img') {\r\n          elementContainer.innerHTML = `&nbsp;${element.title}&nbsp;`;\r\n        } else if (element.type === 'anchor') {\r\n          elementContainer.innerHTML = `&nbsp;${element.href}&nbsp;`;\r\n        }\r\n\r\n        messageElement.appendChild(elementContainer);\r\n      });\r\n\r\n      // Append the message container to the main container\r\n      popupMessagesContainer.appendChild(popupChatMessage);\r\n    }\r\n  }\r\n\r\n  // POPUP MESSAGES END\r\n\r\n  // Function to convert Cyrillic characters to Latin\r\n  function convertCyrillicToLatin(input) {\r\n    const cyrillicToLatinMap = {\r\n      'А': 'A', 'Б': 'B', 'В': 'V', 'Г': 'G', 'Д': 'D',\r\n      'Е': 'E', 'Ё': 'Yo', 'Ж': 'Zh', 'З': 'Z', 'И': 'I',\r\n      'Й': 'Y', 'К': 'K', 'Л': 'L', 'М': 'M', 'Н': 'N',\r\n      'О': 'O', 'П': 'P', 'Р': 'R', 'С': 'S', 'Т': 'T',\r\n      'У': 'U', 'Ф': 'F', 'Х': 'Kh', 'Ц': 'Ts', 'Ч': 'Ch',\r\n      'Ш': 'Sh', 'Щ': 'Shch', 'Ъ': 'y', // 'ъ' maps to 'y'\r\n      'Ы': 'Y', 'Ь': 'i', // 'ь' maps to 'i'\r\n      'Э': 'E', 'Ю': 'Yu', 'Я': 'Ya',\r\n      'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd',\r\n      'е': 'e', 'ё': 'yo', 'ж': 'zh', 'з': 'z', 'и': 'i',\r\n      'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n',\r\n      'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't',\r\n      'у': 'u', 'ф': 'f', 'х': 'kh', 'ц': 'ts', 'ч': 'ch',\r\n      'ш': 'sh', 'щ': 'shch', 'ъ': 'y', // 'ъ' maps to 'y'\r\n      'ы': 'y', 'ь': 'i', // 'ь' maps to 'i'\r\n      'э': 'e', 'ю': 'yu', 'я': 'ya'\r\n    };\r\n\r\n    // Convert the input string to Latin using the mapping\r\n    return input.split('').map(char => cyrillicToLatinMap[char] || char).join('');\r\n  }\r\n\r\n  // Function to convert Russian usernames\r\n  function convertRussianUsernameToLatin(username) {\r\n    // Use the conversion function on the username\r\n    return convertCyrillicToLatin(username);\r\n  }\r\n\r\n  // Skip reading the messages on page load to read them normally when the user is present and the page is stable\r\n  let isInitialized = false;\r\n  // Define the maximum number of messages per user\r\n  const maxMessagesPerUser = 5;\r\n\r\n  // Function to remove all messages from users in the ignored\r\n  function removeIgnoredUserMessages() {\r\n    document.querySelectorAll('.messages-content p').forEach(message => {\r\n      const usernameElement = message.querySelector('.username'); // Adjust selector if needed\r\n      const username = usernameElement?.textContent?.replace(/[<>]/g, '') || null;\r\n\r\n      if (username && _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.ignored.includes(username)) {\r\n        // console.log(`Hidden message from ignored user: ${username}`);\r\n        // Convert Cyrillic username to Latin\r\n        const latinUsername = convertRussianUsernameToLatin(username);\r\n        message.classList.add('ignored-user', latinUsername);\r\n        message.style.display = 'none'; // Hide the message\r\n      }\r\n    });\r\n  }\r\n\r\n  // Function to play sound as a notification for system message banned\r\n  function playSound() {\r\n    const marioGameOver = 'https://github.com/VimiummuimiV/Sounds/raw/refs/heads/main/Mario_Game_Over.mp3';\r\n    const audio = new Audio(marioGameOver);\r\n    audio.play();\r\n  }\r\n\r\n  // Function to detect a ban message based on the message text content\r\n  function isBanMessage(messageText) {\r\n    if (!messageText) return false; // Return false if messageText is null, undefined, or an empty string\r\n    return ['Клавобот', 'Пользователь', 'заблокирован'].every(word => messageText.includes(word));\r\n  }\r\n\r\n  /**\r\n   * Normalizes the color of usernames and resets their filter based on the specified mode.\r\n   *\r\n   * @param {NodeList|Element} usernameElements - A NodeList of username elements or a single username element.\r\n   * @param {string} mode - The mode of operation; either 'one' to process a single username or 'all' to process multiple.\r\n   */\r\n  function normalizeAndResetUsernames(usernameElements, mode) {\r\n    if (!usernameElements) return; // Skip processing if undefined or null\r\n\r\n    if (mode === 'one') {\r\n      // Process a single username element.\r\n      const userSpan = usernameElements.querySelector('span[data-user]');\r\n      if (!userSpan) return; // Skip processing if child span is missing\r\n      const computedColor = getComputedStyle(usernameElements).color;\r\n      const normalizedColor = normalizeUsernameColor(computedColor);\r\n      usernameElements.style.setProperty('color', normalizedColor, 'important');\r\n      userSpan.style.setProperty('filter', 'invert(0)', 'important');\r\n    } else if (mode === 'all') {\r\n      // Process all username elements using forEach with return (which acts like continue)\r\n      Array.from(usernameElements).forEach(usernameElement => {\r\n        if (!usernameElement) return; // Skip this iteration if the element is falsy\r\n        const userSpan = usernameElement.querySelector('span[data-user]');\r\n        if (!userSpan) return; // Skip if child span is missing\r\n        const computedColor = getComputedStyle(usernameElement).color;\r\n        const normalizedColor = normalizeUsernameColor(computedColor);\r\n        usernameElement.style.setProperty('color', normalizedColor, 'important');\r\n        userSpan.style.setProperty('filter', 'invert(0)', 'important');\r\n      });\r\n    } else {\r\n      console.error(\"Invalid mode. Use 'one' or 'all'.\");\r\n    }\r\n  }\r\n\r\n  // Create a mutation observer to watch for new messages being added\r\n  const newMessagesObserver = new MutationObserver(async mutations => {\r\n    // If isInitialized is false, return without doing anything\r\n    if (!isInitialized) {\r\n      isInitialized = true;\r\n\r\n      // Normalize chat usernames color for dark theme\r\n      const allUsernameElements = document.querySelectorAll('.username'); // Get all username elements\r\n      normalizeAndResetUsernames(allUsernameElements, 'all'); // Process all username elements\r\n\r\n      return; // Stop processing further\r\n    }\r\n\r\n    for (let mutation of mutations) {\r\n      if (mutation.type === 'childList') {\r\n        for (let node of mutation.addedNodes) {\r\n          if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'P') {\r\n            const singleUsernameElement = node.querySelector('.username'); // Get a single username element\r\n            if (singleUsernameElement) normalizeAndResetUsernames(singleUsernameElement, 'one'); // Process the single username element\r\n\r\n            // Retrieve the previous message text from localStorage\r\n            const previousMessageText = localStorage.getItem('previousMessageText');\r\n\r\n            // Get the latest message data (returns only messageText and usernameText)\r\n            const latestMessageData = await getLatestMessageData();\r\n            const currentMessageText = latestMessageData?.messageText || null;\r\n            const currentMessageUsername = latestMessageData?.usernameText || null;\r\n            console.log(currentMessageText);\r\n\r\n            // Convert Cyrillic username to Latin\r\n            const latinUsername = convertRussianUsernameToLatin(currentMessageUsername);\r\n\r\n            // Check for a ban message and play sound if detected\r\n            if (isBanMessage(currentMessageText)) {\r\n              console.log('Ban message detected:', currentMessageText);\r\n              playSound();\r\n            }\r\n\r\n            // Hide message if the username is in the ignored list\r\n            if (currentMessageUsername && _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.ignored.includes(currentMessageUsername)) {\r\n              node.classList.add('ignored-user', latinUsername);\r\n              node.style.display = 'none';\r\n              continue;\r\n            }\r\n\r\n            // Get sound switcher and message mode elements\r\n            const soundSwitcher = document.querySelector('#voice, #beep, #silence');\r\n            const isVoice = soundSwitcher && soundSwitcher.id === 'voice';\r\n            const isBeep = soundSwitcher && soundSwitcher.id === 'beep';\r\n            const messageMode = document.querySelector('#every-message, #mention-message');\r\n            const isEveryMessageMode = messageMode && messageMode.id === 'every-message';\r\n            const isMentionMessageMode = messageMode && messageMode.id === 'mention-message';\r\n\r\n            // Check if the message contains a private indicator\r\n            const privateMessageIndicator = '[шепчет вам]';\r\n            const privateMessageContainer = node.querySelector('.room.private');\r\n            const isPrivateMessage = privateMessageContainer && privateMessageContainer.textContent.includes(privateMessageIndicator);\r\n\r\n            // If voice mode is enabled and the message is new, trigger text-to-speech\r\n            if (isVoice && isInitialized && currentMessageText && currentMessageText !== previousMessageText) {\r\n              localStorage.setItem('previousMessageText', currentMessageText);\r\n              if (currentMessageUsername && !currentMessageUsername.includes(_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.myNickname)) {\r\n                const shouldRead = isEveryMessageMode || (isMentionMessageMode && isMention) || isPrivateMessage;\r\n                if (shouldRead) {\r\n                  addNewMessage(currentMessageText);\r\n                }\r\n              }\r\n            }\r\n\r\n            // If beep mode is enabled and the message is new, play beep sound\r\n            if (isBeep && isInitialized && currentMessageText && currentMessageText !== previousMessageText) {\r\n              localStorage.setItem('previousMessageText', currentMessageText);\r\n              if (currentMessageUsername && !currentMessageUsername.includes(_modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.myNickname)) {\r\n                const shouldBeep = isEveryMessageMode || (isMentionMessageMode && isMention) || isPrivateMessage;\r\n                if (shouldBeep) {\r\n                  const useMentionFrequency = !isEveryMessageMode || isMention;\r\n                  playBeep(useMentionFrequency ? mentionMessageFrequencies : usualMessageFrequencies, beepVolume);\r\n                  if (isMention) isMention = false;\r\n                }\r\n              }\r\n            }\r\n\r\n            // If the page is initialized, perform various UI updates and processing\r\n            if (isInitialized) {\r\n              attachEventsToMessages();\r\n              (0,_modules_image_converter_js__WEBPACK_IMPORTED_MODULE_1__.convertImageLinksToImage)('generalMessages');\r\n              (0,_modules_video_converter_js__WEBPACK_IMPORTED_MODULE_2__.convertVideoLinksToPlayer)('generalMessages');\r\n              (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.processEncodedLinks)('generalMessages');\r\n              applyChatMessageGrouping();\r\n              (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.scrollMessagesToBottom)();\r\n              banSpammer();\r\n              showPopupMessage();\r\n              (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.updatePersonalMessageCounts)();\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  // Observe changes to the messages container element\r\n  const messagesContainer = document.querySelector('.messages-content div');\r\n  newMessagesObserver.observe(messagesContainer, { childList: true, subtree: true });\r\n\r\n\r\n  // SOUND GRAPHICAL SWITCHER\r\n\r\n  // Declare variables for the sound switcher button and its icon\r\n  let soundSwitcher, soundSwitcherIcon;\r\n  // Declare variables for the message mode button and its icon\r\n  let messageMode, messageModeIcon;\r\n\r\n  function addJumpEffect(element, initialTranslateX = 0, initialTranslateY = 0) {\r\n    // Define keyframes with specified percentages, scale effect, and calc for Y translation\r\n    const keyframes = [\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}%)) scale(1)` }, // 0%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% - 60%)) scale(1.1)` }, // 20%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% + 15%)) scale(1)` }, // 40%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% - 20%)) scale(1.05)` }, // 60%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% + 8%)) scale(1)` }, // 75%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% - 10%)) scale(1.05)` }, // 85%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}% + 4%)) scale(1)` }, // 92%\r\n      { transform: `translate(${initialTranslateX}%, calc(${initialTranslateY}%)) scale(1)` } // 100%\r\n    ];\r\n\r\n    // Animation options\r\n    const options = {\r\n      duration: 500, // Total animation duration in ms (adjust as needed)\r\n      easing: 'ease', // Smooth easing between keyframes\r\n      iterations: 1 // Play once\r\n    };\r\n\r\n    // Start the animation\r\n    const animation = element.animate(keyframes, options);\r\n\r\n    // Optional: Return a promise that resolves when animation completes\r\n    return animation.finished;\r\n  }\r\n\r\n  // Helper function to add shake effect\r\n  function addShakeEffect(element) {\r\n    element.classList.add('shake-effect');\r\n    setTimeout(() => {\r\n      element.classList.remove('shake-effect');\r\n    }, 500);\r\n  }\r\n\r\n  // CREATE SOUND SWITCHER BUTTON (START)\r\n\r\n  function createSoundSwitcherButton() {\r\n    // Create a new element with class 'sound-switcher-button' and id 'silence'\r\n    soundSwitcher = document.createElement('div');\r\n    // Retrieve the value from localStorage key \"messageNotificationState\"\r\n    const messageNotificationState = KG_Chat_Empowerment.messageSettings.messageNotificationState || 'silence';\r\n    // Add the class 'sound-switcher-button' to the 'soundSwitcher' element\r\n    soundSwitcher.classList.add(\"empowerment-button\", \"sound-switcher-button\");\r\n    // Initial button id if the localStorage key isn't created with assigned value by user\r\n    soundSwitcher.id = messageNotificationState;\r\n    // Retrieve the value from localStorage key \"messageNotificationTitle\"\r\n\r\n    // Retrieve the value from KG_Chat_Empowerment.messageSettings.messageNotificationTitle\r\n    const messageNotificationTitle = KG_Chat_Empowerment.messageSettings.messageNotificationTitle || 'Do not disturb';\r\n    // Assign title for the current notification state\r\n    soundSwitcher.title = messageNotificationTitle;\r\n\r\n    // Create sound switcher button icon container\r\n    soundSwitcherIcon = document.createElement('span');\r\n    // Add class to icon container\r\n    soundSwitcherIcon.classList.add('sound-switcher-icon');\r\n\r\n    // Append icon container inside sound switcher button\r\n    soundSwitcher.appendChild(soundSwitcherIcon);\r\n    // Append sound switcher button to chat buttons panel\r\n    empowermentButtonsPanel.appendChild(soundSwitcher);\r\n  } createSoundSwitcherButton();\r\n\r\n  // Add the isAltKeyPressed condition to the soundSwitcher event listener\r\n  soundSwitcher.addEventListener('click', function (event) {\r\n    // Only execute the code if both isCtrlKeyPressed and isAltKeyPressed are false\r\n    if (!_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed && !_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isAltKeyPressed) {\r\n\r\n      // Get progress bar elements if they exist in the DOM\r\n      let currentVoiceSpeed = document.querySelector('.current-voice-speed');\r\n      let currentVoicePitch = document.querySelector('.current-voice-pitch');\r\n\r\n      // Remove voice speed setting progress bar\r\n      if (currentVoiceSpeed) {\r\n        currentVoiceSpeed.remove();\r\n      }\r\n\r\n      // Remove voice pitch setting progress bar\r\n      if (currentVoicePitch) {\r\n        currentVoicePitch.remove();\r\n      }\r\n\r\n      // Add pulse effect for soundSwitcher\r\n      (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.addPulseEffect)(this);\r\n\r\n      switch (this.id) {\r\n        case 'silence':\r\n          this.id = 'beep';\r\n          this.title = 'Notify with beep signal';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationState = 'beep';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationTitle = 'Notify with beep signal';\r\n          break;\r\n        case 'beep':\r\n          this.id = 'voice';\r\n          this.title = 'Notify with voice API';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationState = 'voice';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationTitle = 'Notify with voice API';\r\n          break;\r\n        case 'voice':\r\n          this.id = 'silence';\r\n          this.title = 'Do not disturb';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationState = 'silence';\r\n          KG_Chat_Empowerment.messageSettings.messageNotificationTitle = 'Do not disturb';\r\n          break;\r\n      }\r\n      // Stringify KG_Chat_Empowerment before updating in localStorage\r\n      localStorage.setItem('KG_Chat_Empowerment', JSON.stringify(KG_Chat_Empowerment));\r\n\r\n      updateSoundSwitcherIcon();\r\n    }\r\n  });\r\n\r\n  function updateSoundSwitcherIcon() {\r\n    switch (soundSwitcher.id) {\r\n      case 'silence':\r\n        soundSwitcherIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.silenceSVG;\r\n        break;\r\n      case 'beep':\r\n        soundSwitcherIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.beepSVG;\r\n        break;\r\n      case 'voice':\r\n        soundSwitcherIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.voiceSVG;\r\n        break;\r\n    }\r\n  } updateSoundSwitcherIcon();\r\n\r\n  // This function combines the results of the above functions to return an object\r\n  // with both the speed and pitch percentages as strings with a \"%\" sign appended.\r\n  function getVoiceSettingsPercentage() {\r\n    const speedPercent = ((voiceSpeed - minVoiceSpeed) / (maxVoiceSpeed - minVoiceSpeed)) * 100;\r\n    const pitchPercent = ((voicePitch - minVoicePitch) / (maxVoicePitch - minVoicePitch)) * 100;\r\n\r\n    return {\r\n      speed: `${speedPercent}%`,\r\n      pitch: `${pitchPercent}%`,\r\n    };\r\n  }\r\n\r\n  /*\r\n  * Shows the current voice speed or pitch as a span element with appropriate styles.\r\n  * If the Ctrl key is pressed, displays the current voice speed.\r\n  * If the Alt key is pressed, displays the current voice pitch.\r\n  */\r\n  function showVoiceSettings() {\r\n    let voiceSettings = document.querySelector('.voice-settings');\r\n    let currentVoiceSpeed = document.querySelector('.current-voice-speed');\r\n    let currentVoicePitch = document.querySelector('.current-voice-pitch');\r\n\r\n    if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed) {\r\n      // Create voiceSettings if it doesn't exist\r\n      if (!voiceSettings) {\r\n        voiceSettings = document.createElement('div');\r\n        voiceSettings.classList.add('voice-settings');\r\n        soundSwitcher.appendChild(voiceSettings);\r\n        void voiceSettings.offsetWidth;\r\n        voiceSettings.style.opacity = '1';\r\n      }\r\n\r\n      // Remove currentVoicePitch if it exists\r\n      if (currentVoicePitch) {\r\n        currentVoicePitch.remove();\r\n      }\r\n\r\n      // Create currentVoiceSpeed if it doesn't exist\r\n      if (!currentVoiceSpeed) {\r\n        currentVoiceSpeed = document.createElement('span');\r\n        currentVoiceSpeed.classList.add('current-voice-speed');\r\n        voiceSettings.appendChild(currentVoiceSpeed);\r\n      }\r\n\r\n      // Create progress text info for voice speed\r\n      let voiceSpeedInfo = voiceSettings.querySelector('.current-voice-speed .voice-value-info');\r\n      if (!voiceSpeedInfo) {\r\n        voiceSpeedInfo = document.createElement('span');\r\n        voiceSpeedInfo.classList.add(\"voice-speed\", \"voice-value-info\");\r\n        voiceSettings.querySelector('.current-voice-speed').appendChild(voiceSpeedInfo);\r\n      }\r\n\r\n      if (voiceSpeedInfo) {\r\n        // Set the text content of voice speed\r\n        if (voiceSpeed <= minVoiceSpeed || voiceSpeed >= maxVoiceSpeed) {\r\n          voiceSpeedInfo.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.rangeIsOutSVG;\r\n        } else {\r\n          voiceSpeedInfo.innerHTML = `SPEED ${Number(voiceSpeed).toFixed(1)}`;\r\n        }\r\n      }\r\n\r\n      // Create a new progress element if it doesn't exist for speed\r\n      let voiceSpeedProgress = voiceSettings.querySelector('.current-voice-speed .voice-speed-progress');\r\n      if (!voiceSpeedProgress) {\r\n        voiceSpeedProgress = document.createElement('span');\r\n        voiceSpeedProgress.classList.add('voice-speed-progress');\r\n        // Create the progress fill element\r\n        let fill = document.createElement('span');\r\n        fill.classList.add('voice-speed-progress-fill');\r\n        // Append the fill element to the progress element\r\n        voiceSpeedProgress.appendChild(fill);\r\n        // Append the progress element to the current voice speed container\r\n        voiceSettings.querySelector('.current-voice-speed').appendChild(voiceSpeedProgress);\r\n      }\r\n\r\n      // Update progress fill width based on voice speed percentage\r\n      voiceSpeedProgress.querySelector('.voice-speed-progress-fill').style.width = getVoiceSettingsPercentage().speed;\r\n\r\n      // Clear any existing timeout on voiceSettings and set a new one\r\n      if (voiceSettings.timeoutId) {\r\n        clearTimeout(voiceSettings.timeoutId);\r\n      }\r\n\r\n      voiceSettings.timeoutId = setTimeout(() => {\r\n        voiceSettings.style.opacity = '0';\r\n        setTimeout(() => {\r\n          voiceSettings.remove();\r\n        }, 500);\r\n      }, 2000);\r\n\r\n    } else if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isAltKeyPressed) {\r\n      // Create voiceSettings if it doesn't exist\r\n      if (!voiceSettings) {\r\n        voiceSettings = document.createElement('div');\r\n        voiceSettings.classList.add('voice-settings');\r\n        soundSwitcher.appendChild(voiceSettings);\r\n        void voiceSettings.offsetWidth;\r\n        voiceSettings.style.opacity = '1';\r\n      }\r\n\r\n      // Remove currentVoiceSpeed if it exists\r\n      if (currentVoiceSpeed) {\r\n        currentVoiceSpeed.remove();\r\n      }\r\n\r\n      // Create currentVoicePitch if it doesn't exist\r\n      if (!currentVoicePitch) {\r\n        currentVoicePitch = document.createElement('span');\r\n        currentVoicePitch.classList.add('current-voice-pitch');\r\n        voiceSettings.appendChild(currentVoicePitch);\r\n      }\r\n\r\n      // Create progress text info for voice pitch\r\n      let voicePitchInfo = voiceSettings.querySelector('.current-voice-pitch .voice-value-info');\r\n      if (!voicePitchInfo) {\r\n        voicePitchInfo = document.createElement('span');\r\n        voicePitchInfo.classList.add(\"voice-pitch\", \"voice-value-info\");\r\n        voiceSettings.querySelector('.current-voice-pitch').appendChild(voicePitchInfo);\r\n      }\r\n\r\n      if (voicePitchInfo) {\r\n        // Set the text content of voice pitch\r\n        if (voicePitch <= minVoicePitch || voicePitch >= maxVoicePitch) {\r\n          voicePitchInfo.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.rangeIsOutSVG;\r\n        } else {\r\n          voicePitchInfo.innerHTML = `PITCH ${voicePitch.toFixed(1)}`;\r\n        }\r\n      }\r\n\r\n      // Create a new progress element if it doesn't exist for pitch\r\n      let pitchProgress = voiceSettings.querySelector('.current-voice-pitch .voice-pitch-progress');\r\n      if (!pitchProgress) {\r\n        pitchProgress = document.createElement('span');\r\n        pitchProgress.classList.add('voice-pitch-progress');\r\n        // Create the progress fill element\r\n        let fill = document.createElement('span');\r\n        fill.classList.add('voice-pitch-progress-fill');\r\n        // Append the fill element to the progress element\r\n        pitchProgress.appendChild(fill);\r\n        // Append the progress element to the current voice pitch container\r\n        voiceSettings.querySelector('.current-voice-pitch').appendChild(pitchProgress);\r\n      }\r\n\r\n      // Update progress fill width based on voice pitch percentage\r\n      pitchProgress.querySelector('.voice-pitch-progress-fill').style.width = getVoiceSettingsPercentage().pitch;\r\n\r\n      // Clear any existing timeout on voiceSettings and set a new one\r\n      if (voiceSettings.timeoutId) {\r\n        clearTimeout(voiceSettings.timeoutId);\r\n      }\r\n\r\n      voiceSettings.timeoutId = setTimeout(() => {\r\n        voiceSettings.style.opacity = '0';\r\n        setTimeout(() => {\r\n          voiceSettings.remove();\r\n        }, 500);\r\n      }, 2000);\r\n\r\n    } else {\r\n      // If neither Ctrl nor Alt is pressed, remove voiceSettings if it exists\r\n      if (voiceSettings) {\r\n        voiceSettings.remove();\r\n      }\r\n    }\r\n  }\r\n\r\n  let holdTimeout = null;\r\n  let holdInterval = null;\r\n\r\n  // Replace original click/contextmenu listeners with mousedown\r\n  soundSwitcher.addEventListener('mousedown', handleMouseDown);\r\n  soundSwitcher.addEventListener('contextmenu', (event) => event.preventDefault());\r\n\r\n  function handleMouseDown(event) {\r\n    event.preventDefault(); // Prevent context menu on right-click\r\n\r\n    const params = getAdjustmentParams(event);\r\n    if (!params) return;\r\n\r\n    const { prop, step } = params;\r\n    adjustValue(prop, step); // Initial adjustment\r\n\r\n    // Set up delayed repeat\r\n    holdTimeout = setTimeout(() => {\r\n      holdInterval = setInterval(() => {\r\n        const canContinue = adjustValue(prop, step);\r\n        if (!canContinue) clearInterval(holdInterval);\r\n      }, 100);\r\n    }, 500);\r\n\r\n    // Cleanup listeners\r\n    const stopHolding = () => {\r\n      clearTimeout(holdTimeout);\r\n      clearInterval(holdInterval);\r\n      soundSwitcher.removeEventListener('mouseup', stopHolding);\r\n      soundSwitcher.removeEventListener('mouseleave', stopHolding);\r\n    };\r\n\r\n    soundSwitcher.addEventListener('mouseup', stopHolding);\r\n    soundSwitcher.addEventListener('mouseleave', stopHolding);\r\n  }\r\n\r\n  function getAdjustmentParams(event) {\r\n    const isLeft = event.button === 0;\r\n    // const isRight = event.button === 2; // Unused declaration\r\n    const isCtrl = event.ctrlKey || event.metaKey;\r\n    const isAlt = event.altKey;\r\n\r\n    if (!isCtrl && !isAlt) return null;\r\n\r\n    const prop = isCtrl ? 'voiceSpeed' : 'voicePitch';\r\n    const step = isLeft ? -0.1 : 0.1;\r\n\r\n    // Boundary checks\r\n    const current = KG_Chat_Empowerment.voiceSettings[prop];\r\n    const [min, max] = prop === 'voiceSpeed'\r\n      ? [minVoiceSpeed, maxVoiceSpeed]\r\n      : [minVoicePitch, maxVoicePitch];\r\n\r\n    if ((step < 0 && current <= min) || (step > 0 && current >= max)) return null;\r\n\r\n    return { prop, step };\r\n  }\r\n\r\n  function adjustValue(prop, step) {\r\n    const current = parseFloat(KG_Chat_Empowerment.voiceSettings[prop]);\r\n    const [min, max] = prop === 'voiceSpeed'\r\n      ? [minVoiceSpeed, maxVoiceSpeed]\r\n      : [minVoicePitch, maxVoicePitch];\r\n\r\n    const newValue = current + step;\r\n    const clamped = Math.min(max, Math.max(min, newValue));\r\n\r\n    if (current === clamped) return false; // No change\r\n\r\n    updateVoiceSetting(prop, clamped);\r\n    return (step > 0 ? clamped < max : clamped > min);\r\n  }\r\n\r\n  // Function to update the voice setting, round the value, and update storage\r\n  function updateVoiceSetting(prop, value) {\r\n    // Round the value to one decimal place\r\n    const roundedValue = parseFloat(value.toFixed(1));\r\n    // Update the voice setting in the application state\r\n    KG_Chat_Empowerment.voiceSettings[prop] = roundedValue;\r\n    // Update voiceSpeed and voicePitch variables\r\n    if (prop === 'voiceSpeed') {\r\n      voiceSpeed = roundedValue;\r\n    } else if (prop === 'voicePitch') {\r\n      voicePitch = roundedValue;\r\n    }\r\n    // Store the updated state in localStorage\r\n    localStorage.setItem('KG_Chat_Empowerment', JSON.stringify(KG_Chat_Empowerment));\r\n    // Show the updated voice settings\r\n    showVoiceSettings();\r\n  }\r\n\r\n  // CREATE SOUND SWITCHER BUTTON (END)\r\n\r\n\r\n  // CREATE MESSAGE MODE BUTTON (START)\r\n\r\n  function createMessageModeButton() {\r\n    // Create a new element with class 'message-mode-button' and id 'every-messages'\r\n    messageMode = document.createElement('div');\r\n    // Retrieve the value from KG_Chat_Empowerment.messageSettings.messageModeState\r\n    const messageModeState = KG_Chat_Empowerment.messageSettings.messageModeState || 'every-message';\r\n    // Add the class 'message-mode-button' to the 'messagesMode' element\r\n    messageMode.classList.add(\"empowerment-button\", \"message-mode-button\");\r\n    // Initial button id if the localStorage key isn't created with assigned value by user\r\n    messageMode.id = messageModeState;\r\n\r\n    // Retrieve the value from KG_Chat_Empowerment.messageSettings.messageModeTitle\r\n    const messageModeTitle = KG_Chat_Empowerment.messageSettings.messageModeTitle || 'Notify about every message';\r\n    // Assign title for the current notification state\r\n    messageMode.title = messageModeTitle;\r\n\r\n    // Create message mode button icon container\r\n    messageModeIcon = document.createElement('span');\r\n    // Add class to icon container\r\n    messageModeIcon.classList.add('message-mode-icon');\r\n\r\n    // Append icon container inside message mode button\r\n    messageMode.appendChild(messageModeIcon);\r\n    // Append sound switcher button to chat buttons panel\r\n    empowermentButtonsPanel.appendChild(messageMode);\r\n  } createMessageModeButton();\r\n\r\n  // Add the isAltKeyPressed condition to the messagesMode event listener\r\n  messageMode.addEventListener('click', function (event) {\r\n    // Only execute when isCtrlKeyPressed or isAltKeyPressed are false\r\n    if (!_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed || !_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isAltKeyPressed) {\r\n\r\n      // Add pulse effect for messageMode\r\n      (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.addPulseEffect)(this);\r\n\r\n      switch (this.id) {\r\n        case 'every-message':\r\n          this.id = 'mention-message';\r\n          this.title = 'Notify about mention message';\r\n          KG_Chat_Empowerment.messageSettings.messageModeState = 'mention-message';\r\n          KG_Chat_Empowerment.messageSettings.messageModeTitle = 'Notify about mention message';\r\n          break;\r\n        case 'mention-message':\r\n          this.id = 'every-message';\r\n          this.title = 'Notify about every message';\r\n          KG_Chat_Empowerment.messageSettings.messageModeState = 'every-message';\r\n          KG_Chat_Empowerment.messageSettings.messageModeTitle = 'Notify about every message';\r\n          break;\r\n      }\r\n\r\n      // Stringify KG_Chat_Empowerment before updating in localStorage\r\n      localStorage.setItem('KG_Chat_Empowerment', JSON.stringify(KG_Chat_Empowerment));\r\n\r\n      updateMessageModeIcon();\r\n    }\r\n  });\r\n\r\n  function updateMessageModeIcon() {\r\n    switch (messageMode.id) {\r\n      case 'every-message':\r\n        messageModeIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.modeEverySVG;\r\n        break;\r\n      case 'mention-message':\r\n        messageModeIcon.innerHTML = _modules_icons_js__WEBPACK_IMPORTED_MODULE_3__.modeMentionSVG;\r\n        break;\r\n    }\r\n  } updateMessageModeIcon();\r\n\r\n  // CREATE MESSAGE MODE BUTTON (END)\r\n\r\n\r\n  // 1. CREATE CACHE (START)\r\n  (0,_modules_cache_js__WEBPACK_IMPORTED_MODULE_4__.createCacheButton)(empowermentButtonsPanel);\r\n  // CREATE CACHE (END)\r\n\r\n  // 2. CREATE PERSONAL MESSAGES (START)\r\n  (0,_modules_messages_js__WEBPACK_IMPORTED_MODULE_5__.createPersonalMessagesButton)(empowermentButtonsPanel);\r\n  // CREATE PERSONAL MESSAGES (END)\r\n\r\n  // 3. CREATE CHAT LOGS (START)\r\n  (0,_modules_chatlogs_js__WEBPACK_IMPORTED_MODULE_6__.createChatLogsButton)(empowermentButtonsPanel);\r\n  // CREATE CHAT LOGS (END)\r\n\r\n  // 4. CREATE SETTINGS (START)\r\n  (0,_modules_settings_js__WEBPACK_IMPORTED_MODULE_7__.createSettingsButton)(empowermentButtonsPanel);\r\n  // CREATE SETTINGS (END)\r\n\r\n\r\n  // Function to retrieve the chat input field and length popup container based on the current URL\r\n  function retrieveChatElementsByRoomType() {\r\n    const currentURL = window.location.href; // Get the current URL\r\n    let inputField, lengthPopupContainer;\r\n\r\n    if (currentURL.includes('gamelist')) {\r\n      inputField = document.querySelector('#chat-general .text'); // Selector for the general chat input\r\n      lengthPopupContainer = document.querySelector('#chat-general .messages'); // Selector for the general chat messages\r\n    } else if (currentURL.includes('gmid')) {\r\n      inputField = document.querySelector('[id^=\"chat-game\"] .text'); // Selector for the game chat input\r\n      lengthPopupContainer = document.querySelector('[id^=\"chat-game\"] .messages'); // Selector for the game chat messages\r\n    } else {\r\n      console.error('No matching room type found in the URL.');\r\n      return null; // Return null if no matching type is found\r\n    }\r\n\r\n    return { inputField, lengthPopupContainer }; // Return both the input field and the length popup container\r\n  }\r\n\r\n\r\n  // CHAT POPUP INDICATOR LENGTH (START)\r\n\r\n  // Select the input element and length popup container using the helper function\r\n  const { inputField: chatField, lengthPopupContainer } = retrieveChatElementsByRoomType();\r\n\r\n  const lengthPopup = document.createElement('div');\r\n  lengthPopup.className = 'length-field-popup';\r\n\r\n  lengthPopupContainer.appendChild(lengthPopup);\r\n\r\n  // Initialize once at startup\r\n  const textMeasurementCanvas = document.createElement('canvas');\r\n  const textMeasurementContext = textMeasurementCanvas.getContext('2d');\r\n\r\n  let isPopupVisible = false;\r\n  let previousLength = 0;\r\n  let hidePopupTimeout;\r\n\r\n  // Function to update the color of the length popup\r\n  function updateLengthPopupColor(length) {\r\n    if (!lengthPopup) {\r\n      console.error('lengthPopup is not defined');\r\n      return;\r\n    }\r\n\r\n    let textColor;\r\n\r\n    // Determine color based on the length\r\n    if (length === 0) {\r\n      textColor = 'hsl(200, 20%, 50%)'; // Light Blue\r\n    } else if (length >= 1 && length <= 90) {\r\n      textColor = 'hsl(120, 100%, 40%)'; // Bright Green\r\n    } else if (length > 90 && length <= 100) {\r\n      const factor = (length - 90) / 10;\r\n      const h = Math.round(120 + factor * (60 - 120)); // Interpolating hue\r\n      textColor = `hsl(${h}, 100%, 40%)`;\r\n    } else if (length > 100 && length <= 190) {\r\n      textColor = 'hsl(60, 100%, 50%)'; // Bright Yellow\r\n    } else if (length > 190 && length <= 200) {\r\n      const factor = (length - 190) / 10;\r\n      const h = Math.round(60 + factor * (30 - 60)); // Interpolating hue\r\n      textColor = `hsl(${h}, 100%, 50%)`;\r\n    } else if (length > 200 && length <= 250) {\r\n      textColor = 'hsl(40, 100%, 50%)'; // Orange (Updated)\r\n    } else if (length > 250 && length <= 300) {\r\n      const factor = (length - 250) / 50;\r\n      const h = Math.round(40 + factor * (0 - 40)); // Interpolating hue\r\n      textColor = `hsl(${h}, 100%, 70%)`;\r\n    } else {\r\n      textColor = 'hsl(0, 100%, 70%)'; // Red (Updated)\r\n    }\r\n\r\n    // Apply the text color to the length popup\r\n    lengthPopup.style.color = textColor;\r\n  }\r\n\r\n  // Then use them in your measurement function\r\n  function updatePopupMetrics(text) {\r\n    // Get current font from input field\r\n    const computedStyle = getComputedStyle(chatField);\r\n    textMeasurementContext.font = `${computedStyle.fontWeight} ${computedStyle.fontSize} ${computedStyle.fontFamily}`;\r\n\r\n    // Measure text\r\n    const textWidth = textMeasurementContext.measureText(text).width;\r\n\r\n    // Calculate position\r\n    const newLeft = chatField.offsetLeft + textWidth + 5;\r\n    const maxLeft = chatField.offsetLeft + chatField.offsetWidth - lengthPopup.offsetWidth;\r\n    lengthPopup.style.left = `${Math.min(newLeft, maxLeft)}px`;\r\n  }\r\n\r\n  // Only update content/position without animation\r\n  function updateLengthPopup(length) {\r\n    let displayText;\r\n\r\n    displayText = length > previousLength ? `${length} 🡆` :\r\n      length < previousLength ? `🡄 ${length}` :\r\n        `${length}`;\r\n\r\n    lengthPopup.textContent = displayText;\r\n    updateLengthPopupColor(length);\r\n    previousLength = length;\r\n  }\r\n\r\n  function togglePopup(show) {\r\n    if (isPopupVisible === show) return;\r\n    lengthPopup.classList.toggle('bounce-in', show);\r\n    lengthPopup.classList.toggle('bounce-out', !show);\r\n    isPopupVisible = show;\r\n    if (!show) setTimeout(() => lengthPopup.classList.remove('bounce-out'), 500);\r\n  }\r\n\r\n  function resetPopup() {\r\n    updateLengthPopup(0);\r\n    Object.assign(lengthPopup.style, { left: '0px', color: 'hsl(200, 20%, 50%)' });\r\n  }\r\n\r\n  chatField.addEventListener('input', () => {\r\n    clearTimeout(hidePopupTimeout);\r\n    updateLengthPopup(chatField.value.length);\r\n    updatePopupMetrics(chatField.value);\r\n    togglePopup(true);\r\n    hidePopupTimeout = setTimeout(() => togglePopup(false), 1000);\r\n  });\r\n\r\n  chatField.addEventListener('keydown', (e) => {\r\n    if (e.key !== 'Enter') return;\r\n    resetPopup();\r\n    togglePopup(true);\r\n    hidePopupTimeout = setTimeout(() => togglePopup(false), 1000);\r\n  });\r\n\r\n  // CHAT POPUP INDICATOR LENGTH (END)\r\n\r\n\r\n  // REMOVE UNWANTED MESSAGES\r\n\r\n  /*\r\n  ** This algorithm enables the removal of unpleasant messages in the chat that are unwanted.\r\n  ** The messages are saved in localStorage and remain there until they are visible in the chat.\r\n  ** Once a message is no longer visible in the chat, its corresponding value in localStorage is also removed.\r\n  ** This method is helpful in storing only necessary unwanted messages, preventing an overgrowth of values over time.\r\n  */\r\n\r\n  function executeMessageRemover() {\r\n    attachEventsToMessages();\r\n    createToggleButton();\r\n    wipeDeletedMessages();\r\n  } // executeMessageRemover function END\r\n\r\n  // Function to assign styles to the delete button\r\n  function assignDeleteButtonStyles(deleteButton, event) {\r\n    // Set the delete button styles\r\n    deleteButton.style.position = 'fixed';\r\n    deleteButton.style.top = `${event.clientY}px`;\r\n    deleteButton.style.left = `${event.clientX}px`;\r\n    deleteButton.style.zIndex = 999;\r\n    deleteButton.style.padding = '8px 16px';\r\n    deleteButton.style.backgroundColor = 'hsl(0, 50%, 20%)';\r\n    deleteButton.style.color = 'hsl(0, 60%, 70%)';\r\n    deleteButton.style.border = '1px solid hsl(0, 50%, 35%)';\r\n    deleteButton.style.transition = 'all 0.3s';\r\n    deleteButton.style.filter = 'brightness(1)';\r\n\r\n    // Set the hover styles\r\n    deleteButton.addEventListener('mouseenter', () => {\r\n      deleteButton.style.filter = 'brightness(1.5)';\r\n    });\r\n\r\n    // Set the mouse leave styles\r\n    deleteButton.addEventListener('mouseleave', () => {\r\n      deleteButton.style.filter = 'brightness(1)';\r\n    });\r\n  }\r\n\r\n  // Functions to assign selection to the messages\r\n  function assignMessageSelection(message) {\r\n    message.style.setProperty('background-color', 'hsla(0, 50%, 30%, .5)', 'important');\r\n    message.style.setProperty('box-shadow', 'inset 0px 0px 0px 1px rgb(191, 64, 64)', 'important');\r\n    message.style.setProperty('background-clip', 'padding-box', 'important');\r\n  }\r\n  // Clear the selection\r\n  function clearMessageSelection() {\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n    messages.forEach(message => {\r\n      message.style.removeProperty('background-color');\r\n      message.style.removeProperty('box-shadow');\r\n      message.style.removeProperty('background-clip');\r\n    });\r\n  }\r\n\r\n  // Declare a new Set to hold selected messages\r\n  const selectedMessages = new Set();\r\n  // To store the data of the right mouse button drag\r\n  let isDragging = false;\r\n  let isRightMouseButton = false;\r\n\r\n  // Function to attach events on every message what doesn't have any event assigned\r\n  function attachEventsToMessages() {\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n    // Store timeoutID to regulate it by multiple events\r\n    let timeoutId = null;\r\n\r\n    messages.forEach(message => {\r\n      // Check if the element has the 'contextmenu' id before adding a new event listener\r\n      if (!message.hasAttribute('id') || message.getAttribute('id') !== 'contextmenu') {\r\n\r\n        message.addEventListener('mousedown', event => {\r\n          isRightMouseButton = event.button === 2;\r\n          if (isRightMouseButton) {\r\n            isDragging = true;\r\n            clearTimeout(timeoutId);\r\n\r\n            // Extract content from various types of child nodes\r\n            const messageContent = getMessageContent(message);\r\n            if (!selectedMessages.has(messageContent)) {\r\n              selectedMessages.add(messageContent);\r\n              console.log('Added new message inside the selectedMessages Set:', messageContent);\r\n            }\r\n\r\n            assignMessageSelection(message);\r\n          }\r\n        });\r\n\r\n        message.addEventListener('mouseup', event => {\r\n          isRightMouseButton = event.button === 2;\r\n          if (isRightMouseButton) {\r\n            isDragging = false;\r\n          }\r\n        });\r\n\r\n        message.addEventListener('mouseover', event => {\r\n          if (isDragging && isRightMouseButton) {\r\n            // Extract content from various types of child nodes\r\n            const messageContent = getMessageContent(message);\r\n            if (!selectedMessages.has(messageContent)) {\r\n              selectedMessages.add(messageContent);\r\n              console.log('Added new message inside the selectedMessages Set:', messageContent);\r\n            }\r\n\r\n            assignMessageSelection(message);\r\n          }\r\n        });\r\n\r\n        // Add id contextmenu to check in the future if the element has the event\r\n        message.setAttribute('id', 'contextmenu');\r\n        // Add an event listener for right-clicks on messages\r\n        message.addEventListener('contextmenu', event => {\r\n          // Prevent the default context menu from appearing\r\n          event.preventDefault();\r\n          // Wrap the message into visible selection to visually know what message will be deleted\r\n          assignMessageSelection(message);\r\n\r\n          // Check if a delete-message button already exists in the document\r\n          const deleteButton = document.querySelector('.delete-message');\r\n\r\n          if (deleteButton) {\r\n            // If it exists, remove it\r\n            deleteButton.remove();\r\n          }\r\n\r\n          // Create a new delete-message button\r\n          const newDeleteButton = document.createElement('button');\r\n          newDeleteButton.innerText = 'Delete';\r\n          newDeleteButton.classList.add('delete-message');\r\n\r\n          // Attach event click to new delete-message button\r\n          newDeleteButton.addEventListener('click', () => {\r\n            deleteSelectedMessages(message);\r\n            newDeleteButton.remove();\r\n            createToggleButton();\r\n            selectedMessages.clear();\r\n          });\r\n\r\n          // Style the delete button\r\n          assignDeleteButtonStyles(newDeleteButton, event);\r\n\r\n          // Set the hover styles\r\n          newDeleteButton.addEventListener('mouseenter', () => {\r\n            newDeleteButton.style.filter = 'brightness(1.5)';\r\n          });\r\n\r\n          // Set the mouse leave styles\r\n          newDeleteButton.addEventListener('mouseleave', () => {\r\n            newDeleteButton.style.filter = 'brightness(1)';\r\n          });\r\n\r\n          // Append the new delete-message button to the document body\r\n          document.body.appendChild(newDeleteButton);\r\n\r\n          function hideDeleteButton() {\r\n            // Set a new timeout to remove the delete button\r\n            timeoutId = setTimeout(() => {\r\n              if (!newDeleteButton.matches(':hover')) {\r\n                newDeleteButton.remove();\r\n                clearMessageSelection(message);\r\n                selectedMessages.clear();\r\n              }\r\n            }, 1000);\r\n          }\r\n\r\n          hideDeleteButton();\r\n\r\n          // Add event listener for the mouseleave event on the delete button\r\n          newDeleteButton.addEventListener('mouseleave', () => {\r\n            hideDeleteButton();\r\n          });\r\n\r\n          // Add event listener for the mouseenter event on the delete button to clear the previous timeout\r\n          newDeleteButton.addEventListener('mouseenter', () => {\r\n            clearTimeout(timeoutId);\r\n          });\r\n\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  // Function to extract content from various types of child nodes within a message element\r\n  function getMessageContent(messageElement) {\r\n    // Query the .time and .username elements\r\n    const timeElement = messageElement.querySelector('.time');\r\n    const usernameElement = messageElement.querySelector('.username');\r\n\r\n    // Extract content from .time and .username elements\r\n    const timeContent = timeElement ? timeElement.textContent.trim() : '';\r\n    const usernameContent = usernameElement ? ` ${usernameElement.textContent.trim()} ` : '';\r\n\r\n    // Extract content from other types of child nodes\r\n    const otherContentArray = Array.from(messageElement.childNodes)\r\n      .filter(node => node !== timeElement && node !== usernameElement)\r\n      .map(node => {\r\n        if (node.nodeType === Node.TEXT_NODE) {\r\n          return node.textContent; // Handle #text node without trimming\r\n        } else if (node.tagName === 'A') {\r\n          return node.getAttribute('href').trim(); // Handle #anchor (link) node\r\n        } else if (node.tagName === 'IMG') {\r\n          return node.title.trim(); // Handle #img node\r\n        } else if (node.tagName === 'IFRAME') {\r\n          return node.getAttribute('src').trim(); // Handle #iframe node\r\n        }\r\n        return ''; // Return empty string for other node types\r\n      });\r\n\r\n    // Concatenate content while respecting the order of child nodes\r\n    const allContentArray = [timeContent, usernameContent, ...otherContentArray];\r\n\r\n    return allContentArray.join('');\r\n  }\r\n\r\n  function deleteSelectedMessages() {\r\n    // Retrieve and backup all current selectedMessages and convert into Array\r\n    const messagesToDelete = [...selectedMessages];\r\n\r\n    // Get all message elements\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n\r\n    // Loop over each selected message content\r\n    messagesToDelete.forEach((messageContent) => {\r\n      // Find the corresponding DOM element\r\n      const messageElement = Array.from(messages).find(message => getMessageContent(message) === messageContent);\r\n\r\n      // Check if the element is found before using it\r\n      if (messageElement) {\r\n        // Retrieve the stored deleted messages array, or create an empty array if none exist\r\n        const deletedMessages = JSON.parse(localStorage.getItem('deletedChatMessagesContent') || '[]');\r\n        // Add the deleted message content to the array if it doesn't already exist\r\n        if (!deletedMessages.includes(messageContent)) {\r\n          deletedMessages.push(messageContent);\r\n        }\r\n        // Store the updated deleted messages array in localStorage\r\n        localStorage.setItem('deletedChatMessagesContent', JSON.stringify(deletedMessages));\r\n        // Remove the message from the selectedMessages Set\r\n        selectedMessages.delete(messageContent);\r\n      }\r\n    });\r\n\r\n    // Hide all the messages that match the localStorage value\r\n    wipeDeletedMessages();\r\n  }\r\n\r\n  function wipeDeletedMessages() {\r\n    // Retrieve and parse the stored deleted messages\r\n    const deletedMessages = JSON.parse(localStorage.getItem('deletedChatMessagesContent') || '[]');\r\n\r\n    // If there are no deleted messages in localStorage, return early\r\n    if (deletedMessages.length === 0) return;\r\n\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n    // Convert the deleted messages into a Set for faster lookup\r\n    const deletedMessagesSet = new Set(deletedMessages);\r\n\r\n    // Collect the current messages content into an array for easy comparison\r\n    const currentMessagesContent = Array.from(messages).map(message => getMessageContent(message));\r\n\r\n    // Filter out the deleted messages that no longer exist in the current messages\r\n    const newDeletedMessages = deletedMessages.filter(content => currentMessagesContent.includes(content));\r\n\r\n    // Hide messages in the chat that match the deleted messages\r\n    messages.forEach(message => {\r\n      if (deletedMessagesSet.has(getMessageContent(message))) {\r\n        message.style.display = 'none';\r\n      }\r\n    });\r\n\r\n    // Store the updated deleted messages array in localStorage\r\n    localStorage.setItem('deletedChatMessagesContent', JSON.stringify(newDeletedMessages));\r\n  } // wipeDeletedMessages END\r\n\r\n  // Declare toggleButton variable outside of the function so it is a global variable\r\n  let toggleButton;\r\n\r\n  // Function to create the button only if localStorage \"deletedChatMessagesContent\" has at least one deleted message value\r\n  function createToggleButton() {\r\n    // Retrieve the stored deleted messages array\r\n    const deletedMessages = JSON.parse(localStorage.getItem('deletedChatMessagesContent') || '[]');\r\n\r\n    // Only create the toggle button if there are deleted messages to show/hide\r\n    if (deletedMessages.length > 0) {\r\n      // Check if the button already exists in the DOM\r\n      toggleButton = document.getElementById('toggleButton');\r\n      if (toggleButton === null) {\r\n        // Create the toggle button\r\n        toggleButton = document.createElement('button');\r\n        toggleButton.id = 'toggleButton';\r\n        toggleButton.classList.add(\"toggle-button-hidden\");\r\n        toggleButton.addEventListener('click', toggleHiddenMessages);\r\n        toggleButton.style.position = 'absolute';\r\n        toggleButton.style.top = '0';\r\n        toggleButton.style.right = '0';\r\n        toggleButton.style.padding = '8px 16px';\r\n        // Initial textContent if at least one message is hidden\r\n        toggleButton.innerText = 'Hidden';\r\n        // Initial styles for the Hidden button\r\n        toggleButton.style.transition = 'filter 300ms';\r\n        toggleButton.style.filter = 'hue-rotate(0) brightness(1)';\r\n        let backupTextContent = toggleButton.textContent;\r\n\r\n        // Set the hover styles\r\n        toggleButton.addEventListener('mouseenter', () => {\r\n          if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed) {\r\n            backupTextContent = toggleButton.textContent;\r\n            toggleButton.textContent = 'Restore';\r\n            toggleButton.style.filter = 'hue-rotate(180deg) brightness(2)';\r\n          } else {\r\n            toggleButton.style.filter = 'hue-rotate(0) brightness(2)';\r\n          }\r\n        });\r\n\r\n        // Set the mouse leave styles\r\n        toggleButton.addEventListener('mouseleave', () => {\r\n          const isRestore = toggleButton.textContent === 'Restore';\r\n          if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed || !_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed && isRestore) {\r\n            toggleButton.textContent = backupTextContent;\r\n          }\r\n          toggleButton.style.filter = 'hue-rotate(0) brightness(1)';\r\n        });\r\n\r\n        messagesContainer.appendChild(toggleButton);\r\n      }\r\n    }\r\n  } // createToggleButton END\r\n\r\n  // Function to toggle messages display state from \"NONE\" to \"BLOCK\" and reverse\r\n  function toggleHiddenMessages() {\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n    // Retrieve the stored deleted messages array\r\n    const deletedMessages = JSON.parse(localStorage.getItem('deletedChatMessagesContent') || '[]');\r\n\r\n    if (_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed) {\r\n      // Set deletedChatMessagesContent in local storage as an empty array\r\n      localStorage.setItem('deletedChatMessagesContent', JSON.stringify([]));\r\n\r\n      // Display all messages\r\n      messages.forEach(message => {\r\n        message.style.display = 'block';\r\n        message.style.removeProperty('background-color');\r\n        message.style.removeProperty('box-shadow');\r\n        message.style.removeProperty('background-clip');\r\n      });\r\n\r\n      toggleButton.remove();\r\n    }\r\n\r\n    if (!_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.isCtrlKeyPressed) {\r\n\r\n      // Check if there are any deleted messages in the local storage\r\n      if (deletedMessages.length === 0) {\r\n        // Hide the toggle button if there are no deleted messages\r\n        toggleButton.style.display = 'none';\r\n        return;\r\n      } else {\r\n        // Show the toggle button if there are deleted messages\r\n        toggleButton.style.display = 'block';\r\n      }\r\n\r\n      // Toggle the display of each message that matches the key \"deletedChatMessagesContent\" data\r\n      messages.forEach(message => {\r\n        const messageContent = getMessageContent(message);\r\n\r\n        if (deletedMessages.includes(messageContent)) {\r\n          // Show hidden messages if innerText is \"Hidden\" and display equal \"NONE\"\r\n          if (toggleButton.innerText === 'Hidden') {\r\n            if (message.style.display === 'none') {\r\n              // Change display to \"BLOCK\"\r\n              message.style.display = 'block';\r\n              // Wrap the message into visible selection to visually know what message will be deleted\r\n              message.style.setProperty('background-color', 'hsla(0, 50%, 30%, .5)', 'important');\r\n              message.style.setProperty('box-shadow', 'inset 0px 0px 0px 1px rgb(191, 64, 64)', 'important');\r\n              message.style.setProperty('background-clip', 'padding-box', 'important');\r\n            }\r\n            // Show hidden messages if innerText is \"Show\" and display equal \"NONE\"\r\n          } else if (toggleButton.innerText === 'Show') {\r\n            if (message.style.display === 'none') {\r\n              message.style.display = 'block';\r\n              // Wrap the message into visible selection to visually know what message will be deleted\r\n              message.style.setProperty('background-color', 'hsla(0, 50%, 30%, .5)', 'important');\r\n              message.style.setProperty('box-shadow', 'inset 0px 0px 0px 1px rgb(191, 64, 64)', 'important');\r\n              message.style.setProperty('background-clip', 'padding-box', 'important');\r\n            }\r\n          } else if (toggleButton.innerText === 'Hide') {\r\n            if (message.style.display === 'block') {\r\n              message.style.display = 'none';\r\n              message.style.removeProperty('background-color');\r\n              message.style.removeProperty('box-shadow');\r\n              message.style.removeProperty('background-clip');\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      // Toggle the button text and style\r\n      if (toggleButton.innerText === 'Hide') {\r\n        toggleButton.innerText = 'Show';\r\n        toggleButton.className = 'toggle-button-show'; // Replace the class with the show style\r\n      } else {\r\n        toggleButton.innerText = 'Hide';\r\n        toggleButton.className = 'toggle-button-hide'; // Replace the class with the hide style\r\n      }\r\n\r\n    }\r\n\r\n  } // toggleHiddenMessages END\r\n\r\n  // create a new MutationObserver to wait for the chat to fully load with all messages\r\n  let waitForChatObserver = new MutationObserver(() => {\r\n    // Get the container for all chat messages\r\n    const messagesContainer = document.querySelector('.messages-content div');\r\n    // Get all the message elements from messages container\r\n    const messages = document.querySelectorAll('.messages-content div p');\r\n\r\n    // check if the chat element has been added to the DOM\r\n    if (document.contains(messagesContainer)) {\r\n\r\n      // check if there are at least 20 messages in the container\r\n      if (messages.length >= 20) {\r\n        // stop observing the DOM\r\n        waitForChatObserver.disconnect();\r\n        // Remove ignored users' messages if the page is not initialized\r\n        removeIgnoredUserMessages();\r\n        // Convert image links to visible image containers\r\n        (0,_modules_image_converter_js__WEBPACK_IMPORTED_MODULE_1__.convertImageLinksToImage)('generalMessages');\r\n        // Convert YouTube links to visible iframe containers\r\n        (0,_modules_video_converter_js__WEBPACK_IMPORTED_MODULE_2__.convertVideoLinksToPlayer)('generalMessages'); // For general chat\r\n        // Decodes links within the general messages section.\r\n        (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.processEncodedLinks)('generalMessages');\r\n        // Restore chat tab from localStorage\r\n        (0,_modules_chat_js__WEBPACK_IMPORTED_MODULE_9__.restoreChatTab)();\r\n        // Call the function with the selector for the input field\r\n        (0,_modules_chat_js__WEBPACK_IMPORTED_MODULE_9__.setupInputBackup)('#chat-general .text');\r\n        // Call the function eo re-highlight all the mention words of the messages\r\n        (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.highlightMentionWords)();\r\n        // Call the function to apply the chat message grouping\r\n        applyChatMessageGrouping();\r\n        // Call the function to scroll to the bottom of the chat\r\n        (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.scrollMessagesToBottom)();\r\n        // Call the function to refresh the user list and clear the cache if needed\r\n        (0,_modules_helpers_js__WEBPACK_IMPORTED_MODULE_8__.refreshFetchedUsers)(false, _modules_definitions_js__WEBPACK_IMPORTED_MODULE_12__.cacheRefreshThresholdHours);\r\n        // Refresh experimental custom chat user list on old list changes\r\n        refreshUserList();\r\n        // Call the setChatFieldFocus function when the page loads\r\n        (0,_modules_chat_js__WEBPACK_IMPORTED_MODULE_9__.setChatFieldFocus)();\r\n        // Execute the function to trigger the process of chat cleaning after the youtube and images convertation to avoid issues\r\n        executeMessageRemover();\r\n        // Initialize the input field listener to handle message sending when Enter is pressed\r\n        (0,_modules_chat_js__WEBPACK_IMPORTED_MODULE_9__.setupChatInputListener)();\r\n      }\r\n    }\r\n  });\r\n\r\n  // start observing the DOM for changes\r\n  waitForChatObserver.observe(document, { childList: true, subtree: true });\r\n})();\n\n//# sourceURL=webpack://tampermonkey-script/./src/main.js?");

/***/ }),

/***/ "./src/modules/cache.js":
/*!******************************!*\
  !*** ./src/modules/cache.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCacheButton: () => (/* binding */ createCacheButton),\n/* harmony export */   updateUserCountText: () => (/* binding */ updateUserCountText)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/modules/helpers.js\");\n/* harmony import */ var _notifications_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./notifications.js */ \"./src/modules/notifications.js\");\n/* harmony import */ var _icons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons.js */ \"./src/modules/icons.js\");\n/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./definitions.js */ \"./src/modules/definitions.js\");\n// helpers && helpers definitions\r\n\r\n\r\n// notifications\r\n\r\n\r\n// icons\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Array to store user IDs and their status titles\r\nlet fetchedUsers = JSON.parse(localStorage.getItem('fetchedUsers')) || {};\r\n\r\n// Rank order mapping\r\nconst rankOrder = {\r\n  'Экстракибер': 1,\r\n  'Кибергонщик': 2,\r\n  'Супермен': 3,\r\n  'Маньяк': 4,\r\n  'Гонщик': 5,\r\n  'Профи': 6,\r\n  'Таксист': 7,\r\n  'Любитель': 8,\r\n  'Новичок': 9\r\n};\r\n\r\n// Rank color mapping\r\nconst rankColors = {\r\n  'Экстракибер': '#06B4E9', // Light Blue\r\n  'Кибергонщик': '#5681ff', // Medium Blue\r\n  'Супермен': '#B543F5', // Purple\r\n  'Маньяк': '#DA0543', // Red\r\n  'Гонщик': '#FF8C00', // Orange\r\n  'Профи': '#C1AA00', // Yellow\r\n  'Таксист': '#2DAB4F', // Green\r\n  'Любитель': '#61B5B3', // Light Cyan\r\n  'Новичок': '#AFAFAF' // Grey\r\n};\r\n\r\n\r\n// Global function to prepend an emoticon to the visits element in the cache panel.\r\nfunction updateVisitsEmoticon(visitsElement) {\r\n  // Convert content to number; exit if invalid\r\n  const count = Number(visitsElement.textContent);\r\n  if (isNaN(count)) return console.warn('Invalid visits count!');\r\n\r\n  // Select emoticon: 0–10: 💧, 11–20: 💦, 21–30: 🌊, above 30: 🔥\r\n  const emoticon = count <= 10 ? '💧' : count <= 20 ? '💦' : count <= 30 ? '🌊' : '🔥';\r\n\r\n  visitsElement.textContent = `${emoticon} ${count}`;\r\n}\r\n\r\n// Function to display the cached user list panel\r\nfunction showCachePanel() {\r\n  // Check if the panel already exists\r\n  const existingPanel = document.querySelector('.cached-users-panel');\r\n  if (existingPanel) {\r\n    existingPanel.remove(); // Remove the settings panel\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)('hide');\r\n    return; // Return immediately to prevent further execution\r\n  }\r\n\r\n  // Remove any previous panel before creating a new one\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removePreviousPanel)();\r\n\r\n  // Initialize users by parsing fetched data or setting as empty object\r\n  let users = fetchedUsers;\r\n\r\n  // Create a container div with class 'cached-users-panel'\r\n  const cachedUsersPanel = document.createElement('div');\r\n  cachedUsersPanel.className = 'cached-users-panel popup-panel';\r\n\r\n  // Define the event handler function for the cache panel\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_3__.state.panelsEvents.handleCacheKeydown = (event) => { // Assign the function to the object\r\n    if (event.key === 'Escape') {\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerTargetElement)(cachedUsersPanel, 'hide');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)('hide');\r\n      document.removeEventListener('keydown', _definitions_js__WEBPACK_IMPORTED_MODULE_3__.state.panelsEvents.handleCacheKeydown); // Remove the event listener\r\n    }\r\n  };\r\n\r\n  // Attach the event listener\r\n  document.addEventListener('keydown', _definitions_js__WEBPACK_IMPORTED_MODULE_3__.state.panelsEvents.handleCacheKeydown);\r\n\r\n  // Create a container div with class 'panel-header'\r\n  const panelHeaderContainer = document.createElement('div');\r\n  panelHeaderContainer.className = 'panel-header';\r\n\r\n  // Create a container div with class 'drop-time'\r\n  const dropTime = document.createElement('div');\r\n  dropTime.className = 'drop-time';\r\n\r\n  // Create span with description for threshold time element\r\n  const dropTimeThresholdDescription = document.createElement('span');\r\n  dropTimeThresholdDescription.className = 'drop-time-threshold-description';\r\n  dropTimeThresholdDescription.textContent = '🚧 Threshold';\r\n\r\n  const dropTimeThreshold = document.createElement('span');\r\n  dropTimeThreshold.className = 'drop-time-threshold';\r\n\r\n  // Get the value from the localStorage key 'cacheRefreshThresholdHours'\r\n  const storedThresholdTime = localStorage.getItem('cacheRefreshThresholdHours');\r\n  // Update the innerHTML with the stored value (default to '00:00:00' if the key is not set)\r\n  dropTimeThreshold.innerHTML = storedThresholdTime || '00:00:00';\r\n  // Attach click event to the dropTimeThreshold element\r\n  dropTimeThreshold.addEventListener('click', setCacheRefreshTime);\r\n\r\n  // Create span with description for expiration time element\r\n  const dropTimeExpirationDescription = document.createElement('span');\r\n  dropTimeExpirationDescription.className = 'drop-time-expiration-description';\r\n  dropTimeExpirationDescription.textContent = '💣 Countdown';\r\n\r\n  const dropTimeExpiration = document.createElement('span');\r\n  dropTimeExpiration.className = 'drop-time-expiration';\r\n\r\n  // Function to prompt the user for a cache refresh time and update the content\r\n  function setCacheRefreshTime() {\r\n    let isValidInput = false;\r\n\r\n    // Keep prompting the user until valid input is provided or they click \"Cancel\"\r\n    while (!isValidInput) {\r\n      // Prompt the user for a time\r\n      const userInput = prompt('Enter a cache refresh time (e.g., HH, HH:mm, or HH:mm:ss):');\r\n\r\n      // Get the dropTimeThreshold element\r\n      const dropTimeThreshold = document.querySelector('.drop-time-threshold');\r\n\r\n      // Validate the user input\r\n      const timeRegex = /^([0-9]+|[01][0-9]|2[0-4])(:([0-5]?[0-9])(:([0-5]?[0-9]))?)?$/; // HH, HH:mm, or HH:mm:ss\r\n\r\n      if (userInput === null) {\r\n        // User clicked \"Cancel,\" exit the loop\r\n        isValidInput = true;\r\n      } else if (timeRegex.test(userInput)) {\r\n        // Valid input, extract hours and set default values for minutes and seconds if not provided\r\n        const formattedInput = userInput.split(':');\r\n        const hours = ('0' + formattedInput[0]).slice(-2);\r\n        const minutes = ('0' + (formattedInput[1] || '00')).slice(-2);\r\n        const seconds = ('0' + (formattedInput[2] || '00')).slice(-2);\r\n\r\n        // Update the content of the dropTimeThreshold element\r\n        dropTimeThreshold.textContent = `${hours}:${minutes}:${seconds}`;\r\n\r\n        // Combine the values and store in localStorage with the key 'cacheRefreshThresholdHours'\r\n        const formattedTime = `${hours}:${minutes}:${seconds}`;\r\n        localStorage.setItem('cacheRefreshThresholdHours', formattedTime);\r\n\r\n        // Remove fetchedUsers, lastClearTime, and nextClearTime keys\r\n        localStorage.removeItem('fetchedUsers');\r\n        localStorage.removeItem('lastClearTime');\r\n        localStorage.removeItem('nextClearTime');\r\n\r\n        // Reload the current page after (N) time after changing the cache threshold\r\n        setTimeout(() => location.reload(), 1000);\r\n\r\n        // Set isValidInput to true to exit the loop\r\n        isValidInput = true;\r\n      } else {\r\n        // Alert the user for invalid input\r\n        alert('Invalid time format. Please enter a valid time in the format HH, HH:mm, or HH:mm:ss.');\r\n      }\r\n    }\r\n  }\r\n\r\n  // Append the childs to the drop time parent element\r\n  dropTime.appendChild(dropTimeThresholdDescription);\r\n  dropTime.appendChild(dropTimeThreshold);\r\n  dropTime.appendChild(dropTimeExpirationDescription);\r\n  dropTime.appendChild(dropTimeExpiration);\r\n\r\n  // Append the drop time element to the panel header container\r\n  panelHeaderContainer.appendChild(dropTime);\r\n\r\n  // Create a container div for the search input\r\n  const cacheSearchContainer = document.createElement('div');\r\n  cacheSearchContainer.className = 'search-for-cached-users';\r\n\r\n  // Create the input field for searching users\r\n  const cacheSearchInput = document.createElement('input');\r\n  cacheSearchInput.className = 'cached-users-search-input';\r\n  cacheSearchInput.type = 'text';\r\n\r\n  // Append search input to the search container\r\n  cacheSearchContainer.appendChild(cacheSearchInput);\r\n\r\n  // Add click event listener to clear the search input by LMB click with Ctrl key pressed\r\n  cacheSearchInput.addEventListener('click', () => _helpers_js__WEBPACK_IMPORTED_MODULE_0__.isCtrlKeyPressed && (cacheSearchInput.value = ''));\r\n\r\n  // Add event listener to listen for keydown events\r\n  cacheSearchInput.addEventListener('keydown', async (event) => {\r\n    const oldUsersContainer = document.querySelector('.old-users');\r\n    const newUsersContainer = document.querySelector('.new-users');\r\n    const fetchedUsersContainer = document.querySelector('.fetched-users');\r\n\r\n    // Handle Backspace key\r\n    if (event.key === 'Backspace' && event.target.value.length === 0) {\r\n      oldUsersContainer.style.display = 'grid';\r\n      newUsersContainer.style.display = 'grid';\r\n\r\n      const searchResultsContainer = document.querySelector('.search-results');\r\n      if (searchResultsContainer && fetchedUsersContainer) {\r\n        fetchedUsersContainer.removeChild(searchResultsContainer);\r\n      }\r\n    }\r\n    // Handle Enter key\r\n    else if (event.key === 'Enter') {\r\n      const inputValue = event.target.value.trim();\r\n\r\n      // If input is empty, set it to 'user '\r\n      if (inputValue.length === 0) {\r\n        event.preventDefault(); // Prevent the default behavior\r\n        event.target.value = 'user '; // Set input to 'user '\r\n      }\r\n    }\r\n  });\r\n\r\n  // Create a function to handle the search process\r\n  const handleSearch = async (username) => {\r\n    const oldUsersContainer = document.querySelector('.old-users');\r\n    const newUsersContainer = document.querySelector('.new-users');\r\n    const fetchedUsersContainer = document.querySelector('.fetched-users');\r\n\r\n    if (username) {\r\n      // Temporarily hide old and new user containers\r\n      oldUsersContainer.style.display = 'none';\r\n      newUsersContainer.style.display = 'none';\r\n\r\n      // Find or create the search results container\r\n      let searchResultsContainer = document.querySelector('.search-results');\r\n      if (!searchResultsContainer) {\r\n        searchResultsContainer = createUserContainer('search-results');\r\n        fetchedUsersContainer.appendChild(searchResultsContainer); // Append if it's newly created\r\n      } else {\r\n        // Clear previous search results if the container already exists\r\n        searchResultsContainer.innerHTML = null; // Clear existing elements\r\n      }\r\n\r\n      const userElements = []; // Initialize userElements array\r\n\r\n      try {\r\n        // Fetch user IDs by username\r\n        const userIds = await (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getUserIDsByName)(username);\r\n\r\n        // Iterate over each user ID and retrieve profile data\r\n        await Promise.all(userIds.map(async (userId) => {\r\n          // Retrieve the user's profile data once\r\n          const profileData = await (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getUserProfileData)(userId, false); // Do not touch localStorage key \"fetchedUsers\"\r\n\r\n          // Create user element data using the retrieved profile data\r\n          const userData = {\r\n            rank: profileData.rank, // Assign rank directly\r\n            login: profileData.login,\r\n            registered: profileData.registeredDate, // Set registered to registeredDate\r\n            bestSpeed: profileData.bestSpeed,\r\n            ratingLevel: profileData.ratingLevel,\r\n            friends: profileData.friends,\r\n            cars: profileData.cars,\r\n            avatarTimestamp: profileData.avatarTimestamp,\r\n            avatar: profileData.avatar // Include avatar in userData\r\n          };\r\n\r\n          // Create the user element with userId and userData\r\n          const userElementData = createCachePanelUserElement(userId, userData);\r\n          if (userElementData) {\r\n            userElements.push(userElementData);\r\n          }\r\n        }));\r\n\r\n        // Sort userElements by rank and best speed\r\n        userElements.sort((a, b) =>\r\n          a.order !== b.order ? a.order - b.order : b.bestSpeed - a.bestSpeed\r\n        );\r\n\r\n        // Append user elements to the search results container\r\n        userElements.forEach(({ userElement }) => {\r\n          searchResultsContainer.appendChild(userElement);\r\n        });\r\n\r\n        // Create and append the description for search results\r\n        const searchDescription = createDescription(`Search Results for: ${username}`, 'search-results-description');\r\n        searchResultsContainer.prepend(searchDescription); // Append description as the first element\r\n\r\n      } catch (error) {\r\n        console.error('Error fetching user profile:', error);\r\n\r\n        // Create an error message element and append it to the container\r\n        const errorMessage = document.createElement('div');\r\n        errorMessage.className = 'error-message';\r\n        errorMessage.textContent = `Error fetching user profile: ${error.message}`;\r\n        searchResultsContainer.appendChild(errorMessage);\r\n      }\r\n    }\r\n  };\r\n\r\n  // Debounce the handleSearch function to prevent excessive calls\r\n  cacheSearchInput.addEventListener(\r\n    'input',\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.debounce)((event) => {\r\n      const inputValue = event.target.value.trim();\r\n      const searchMode = localStorage.getItem('cachePanelSearchMode');\r\n\r\n      // Extract username if input starts with 'user ', or use input directly in 'fetch' mode\r\n      const username = inputValue.startsWith('user ')\r\n        ? inputValue.substring(5).trim()\r\n        : (searchMode === 'fetch' ? inputValue : '');\r\n\r\n      // Trigger search if a valid username exists\r\n      if (username) handleSearch(username);\r\n    }, _definitions_js__WEBPACK_IMPORTED_MODULE_3__.debounceTimeout)\r\n  );\r\n\r\n  // Append the search container to the panel header container\r\n  panelHeaderContainer.appendChild(cacheSearchContainer);\r\n\r\n  // Use a mutation observer to wait for the element to appear in the DOM\r\n  const observer = new MutationObserver(mutations => {\r\n    if (mutations.some(mutation => mutation.type === 'childList' && mutation.addedNodes.length > 0)) {\r\n      const cachePanelSearchInput = document.querySelector('.cached-users-search-input');\r\n      const cachePanelLogins = Array.from(document.querySelectorAll('.fetched-users .login'));\r\n\r\n      // Fuzzy match scoring function\r\n      const getFuzzyMatchScore = (query, text) => {\r\n        let score = 0, queryIndex = 0;\r\n        for (const char of text.toLowerCase()) {\r\n          if (queryIndex < query.length && char === query[queryIndex].toLowerCase()) {\r\n            score += 2; // Increment score for matching character\r\n            queryIndex++; // Increment index for the next character\r\n          }\r\n        }\r\n        return queryIndex === query.length ? score : 0;\r\n      };\r\n\r\n      // Filter items based on input query\r\n      const filterItems = query => {\r\n        cachePanelLogins.forEach(item => {\r\n          const userContainer = item.closest('.user-item');\r\n          userContainer.style.display = (!query || getFuzzyMatchScore(query, item.textContent) > 0) ? 'grid' : 'none';\r\n        });\r\n      };\r\n\r\n      // Set focus to the search input field\r\n      cachePanelSearchInput.focus();\r\n\r\n      // Add input event listener to filter items as the user types\r\n      cachePanelSearchInput.addEventListener('input', () => filterItems(cachePanelSearchInput.value.trim()));\r\n\r\n      observer.disconnect();\r\n    }\r\n  });\r\n\r\n  // Start observing the panel header container for changes\r\n  observer.observe(panelHeaderContainer, { childList: true, subtree: true });\r\n\r\n  // Create a container div with class 'panel-control-buttons'\r\n  const panelControlButtons = document.createElement('div');\r\n  panelControlButtons.className = 'panel-control-buttons';\r\n  panelControlButtons.style.display = 'flex';\r\n\r\n  // Create cache panel search mode button with the provided SVG icon\r\n  const cachePanelSearchMode = document.createElement('div');\r\n  cachePanelSearchMode.className = 'large-button user-mode-button';\r\n  cachePanelSearchMode.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_2__.usersSVG;\r\n\r\n  // Set the initial value or existing for cachePanelSearchMode if it doesn't exist\r\n  const currentSearchMode = localStorage.getItem('cachePanelSearchMode') || (localStorage.setItem('cachePanelSearchMode', 'cache'), 'cache');\r\n\r\n  // Set the title dynamically\r\n  cachePanelSearchMode.title = `Current active mode: ${currentSearchMode}`;\r\n\r\n  // Function to update styles based on the current mode\r\n  function updateStyles(mode) {\r\n    const button = cachePanelSearchMode;\r\n\r\n    // Toggle classes by removing and adding the appropriate class\r\n    button.classList.toggle('cache-mode-button', mode === 'cache');\r\n    button.classList.toggle('fetch-mode-button', mode !== 'cache');\r\n  }\r\n\r\n  // Initial mode setup based on the current mode\r\n  updateStyles(currentSearchMode);\r\n\r\n  // Add click event listener to the cache panel search mode button\r\n  cachePanelSearchMode.addEventListener('click', () => {\r\n    // Toggle between 'cache' and 'fetch' values\r\n    const currentMode = localStorage.getItem('cachePanelSearchMode');\r\n    const newMode = currentMode === 'cache' ? 'fetch' : 'cache';\r\n    // Set new mode in localStorage\r\n    localStorage.setItem('cachePanelSearchMode', newMode);\r\n    // Update styles based on the new mode\r\n    updateStyles(newMode);\r\n    // Set the title dynamically based on the new mode\r\n    cachePanelSearchMode.title = `Current active mode: ${newMode}`;\r\n    // Optional: Log the current mode for debugging\r\n    // console.log(`Current mode: ${newMode}`);\r\n  });\r\n\r\n  // Append the search mode button to the panel header container\r\n  panelControlButtons.appendChild(cachePanelSearchMode);\r\n\r\n  // Create a clear cache button with the provided SVG icon\r\n  const clearCacheButton = document.createElement('div');\r\n  clearCacheButton.className = 'large-button panel-header-clear-button';\r\n  clearCacheButton.title = 'Clear cache';\r\n  clearCacheButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_2__.trashSVG;\r\n\r\n  // Add a click event listener to the clear cache button\r\n  clearCacheButton.addEventListener('click', () => {\r\n    // Call the helper function to hide and remove the cachedUsersPanel\r\n    hideCachePanel();\r\n    // Clear the cache manually and reset the timer\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.refreshFetchedUsers)(true, _definitions_js__WEBPACK_IMPORTED_MODULE_3__.cacheRefreshThresholdHours);\r\n\r\n    // Set the user count element to 0\r\n    const userCountElement = document.querySelector('.cache-panel-load-button .cache-user-count');\r\n    if (userCountElement) userCountElement.textContent = '0'; // Set the user count to 0\r\n  });\r\n\r\n  // Append the clear cache button to the panel header container\r\n  panelControlButtons.appendChild(clearCacheButton);\r\n\r\n  // Create a close button with the provided SVG icon\r\n  const closePanelButton = document.createElement('div');\r\n  closePanelButton.className = 'large-button panel-header-close-button';\r\n  closePanelButton.title = 'Close panel';\r\n  closePanelButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_2__.closeSVG;\r\n\r\n  // Add a click event listener to the close panel button\r\n  closePanelButton.addEventListener('click', () => {\r\n    // Remove the cached-users-panel when the close button is clicked\r\n    hideCachePanel();\r\n  });\r\n\r\n  // Append the close button to the panel header container\r\n  panelControlButtons.appendChild(closePanelButton);\r\n\r\n  // Append the panel control buttons element inside the panel header container\r\n  panelHeaderContainer.appendChild(panelControlButtons);\r\n\r\n  // Create a container div with class 'fetched-users'\r\n  const fetchedUsersContainer = document.createElement('div');\r\n  fetchedUsersContainer.className = 'fetched-users';\r\n\r\n  // Function to create a user container with common styles\r\n  function createUserContainer(isOldUser) {\r\n    const userContainer = document.createElement('div');\r\n    userContainer.className = 'users-container';\r\n    // Add a modifier class based on whether it's an old or new user\r\n    userContainer.classList.add(isOldUser ? 'old-users' : 'new-users');\r\n    return userContainer;\r\n  }\r\n\r\n  // Create containers for old and new users\r\n  const oldUsersContainer = createUserContainer(true);\r\n  const newUsersContainer = createUserContainer(false);\r\n\r\n  // Function to create a description with customizable text and class\r\n  function createDescription(text, className) {\r\n    const description = document.createElement('span');\r\n    description.className = `description ${className}`; // Add common 'description' class with the specific className\r\n    description.textContent = text;\r\n    return description;\r\n  }\r\n\r\n  // Create descriptions\r\n  const oldUsersDescription = createDescription('Active Users', 'old-users-description');\r\n  const newUsersDescription = createDescription('New Registrations', 'new-users-description');\r\n\r\n  // Append descriptions to their respective containers\r\n  oldUsersContainer.appendChild(oldUsersDescription); // Append description to old users container\r\n  newUsersContainer.appendChild(newUsersDescription); // Append description to new users container\r\n\r\n  // Append containers to the fetchedUsersContainer\r\n  fetchedUsersContainer.appendChild(oldUsersContainer);\r\n  fetchedUsersContainer.appendChild(newUsersContainer);\r\n\r\n  // Create an array to hold user elements\r\n  const userElements = [];\r\n\r\n  // Flag to control if action log processing should continue\r\n  let shouldProcessActionLog = true;\r\n\r\n  // Get current date for comparison\r\n  const currentDate = new Date();\r\n\r\n  // Helper function to check if registered date is within the last 24 hours\r\n  const isNewUser = (registered) => {\r\n    const registeredDate = new Date(registered);\r\n    const timeDifference = currentDate - registeredDate; // Difference in milliseconds\r\n    return timeDifference <= 24 * 60 * 60 * 1000; // 24 hours in milliseconds\r\n  };\r\n\r\n  // This function creates a user element for the cache panel with detailed user information and metrics.\r\n  const createCachePanelUserElement = (userId, userData) => {\r\n    // Create the main container for the user.\r\n    const userElement = document.createElement('div');\r\n    userElement.className = 'user-item';\r\n\r\n    // Create an avatar container.\r\n    const avatarElement = document.createElement('div');\r\n    avatarElement.className = 'avatar';\r\n\r\n    // Handle avatar URL and display logic.\r\n    const avatarTimestamp = fetchedUsers[userId]?.avatarTimestamp;\r\n    const bigAvatarUrl = `/storage/avatars/${userId}_big.png`;\r\n\r\n    if ((avatarTimestamp && avatarTimestamp !== '00') || (userData.avatar && Object.keys(userData.avatar).length > 0)) {\r\n      const finalAvatarUrl = `${bigAvatarUrl}?updated=${avatarTimestamp}`;\r\n      const imgElement = document.createElement('img');\r\n      imgElement.src = finalAvatarUrl;\r\n      imgElement.alt = `${userData.login}'s avatar`;\r\n      imgElement.style.objectFit = 'cover';\r\n      avatarElement.appendChild(imgElement);\r\n    } else {\r\n      // Display a random emoji avatar if no avatar is available.\r\n      avatarElement.innerHTML = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getRandomEmojiAvatar)();\r\n    }\r\n\r\n    // Create the user data container and append login and rank elements.\r\n    const userDataElement = document.createElement('div');\r\n    userDataElement.className = 'user-data';\r\n\r\n    // Create a container to hold the login and visits elements\r\n    const loginContainer = document.createElement('div');\r\n    loginContainer.className = 'login-container';\r\n\r\n    // Create the login element with a link to the user's profile\r\n    const loginElement = document.createElement('a');\r\n    loginElement.className = 'login';\r\n    loginElement.textContent = userData.login;\r\n    loginElement.href = `https://klavogonki.ru/profile/${userId}`;\r\n\r\n    // Append the login element to the container\r\n    loginContainer.appendChild(loginElement);\r\n\r\n    // Define the URL for user profile messaging\r\n    const profileUrl = _definitions_js__WEBPACK_IMPORTED_MODULE_3__.profileBaseUrl + userId;\r\n    const messageInProfile = `${_definitions_js__WEBPACK_IMPORTED_MODULE_3__.profileBaseUrl}${_definitions_js__WEBPACK_IMPORTED_MODULE_3__.myUserId}/messages/${userId}/`;\r\n\r\n    // Attach a click event listener to the loginElement element\r\n    loginElement.addEventListener('click', function (event) {\r\n      event.preventDefault(); // Prevent the default link action\r\n\r\n      // Check if both Ctrl and Shift keys are pressed during the click event\r\n      if (event.ctrlKey && event.shiftKey) {\r\n        const newTab = window.open(messageInProfile, '_blank'); // Open the messaging page in a new window\r\n        if (newTab) newTab.focus(); // Attempt to make the new tab active\r\n      }\r\n      // Check if only the Ctrl key is pressed\r\n      else if (event.ctrlKey) {\r\n        loadProfileIntoIframe(messageInProfile); // Load the messaging profile into the iframe\r\n      }\r\n      // If Ctrl is not pressed, load the regular profile into the iframe\r\n      else {\r\n        loadProfileIntoIframe(profileUrl); // Load the regular profile into the iframe\r\n      }\r\n    });\r\n\r\n    // Assuming 'userData' and 'userId' are available\r\n    if (userData.visits !== undefined) {\r\n      const visitsElement = document.createElement('span');\r\n      visitsElement.className = 'visits';\r\n      // Add dynamic class based on whether the user is tracked or untracked\r\n      visitsElement.classList.add(userData.tracked ? 'tracked' : 'untracked');\r\n      visitsElement.textContent = userData.visits;\r\n      visitsElement.dataset.userId = userId;\r\n      // Call the function to prepend an emoticon\r\n      updateVisitsEmoticon(visitsElement);\r\n\r\n      // Add the visitsElement to the fetchedUsersContainer\r\n      loginContainer.appendChild(visitsElement);\r\n\r\n      // Add click event listener to visitsElement\r\n      visitsElement.addEventListener('click', (event) => {\r\n        shouldProcessActionLog = true; // Set back to true to resume processing the action log\r\n        const userId = visitsElement.dataset.userId; // Get the userId from the dataset\r\n        const user = fetchedUsers[userId]; // Retrieve the user data\r\n        const actionLog = user ? user.actionLog : null; // Access actionLog if user exists\r\n\r\n        if (user) {\r\n          // Check if the action log container already exists\r\n          let actionLogContainer = document.querySelector('.action-log');\r\n          if (!actionLogContainer) {\r\n            // Create a container for the action log display if it doesn't exist\r\n            actionLogContainer = document.createElement('div');\r\n            actionLogContainer.className = 'action-log';\r\n\r\n            // Append the action log container to the specific container (fetchedUsersContainer)\r\n            fetchedUsersContainer.appendChild(actionLogContainer);\r\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.adjustVisibility)(actionLogContainer, 'show', 1);\r\n          } else {\r\n            // Clear all child elements using replaceChildren (it's an empty operation for now)\r\n            actionLogContainer.replaceChildren();\r\n          }\r\n\r\n          if (actionLog && shouldProcessActionLog) {\r\n            for (let index = 0; index < actionLog.length; index++) {\r\n              if (!shouldProcessActionLog) break;\r\n              const action = actionLog[index];\r\n              if (typeof action !== \"object\" || action === null) continue;\r\n              const { type, timestamp } = action;\r\n              const userAction = userData?.login || \"Unknown User\";\r\n              const actionIconType = type === 'enter' ? _icons_js__WEBPACK_IMPORTED_MODULE_2__.enterSVG : _icons_js__WEBPACK_IMPORTED_MODULE_2__.leaveSVG;\r\n              const userPresence = type === 'enter';\r\n              // Use IIFE to capture the current value of shouldProcessActionLog\r\n              ((currentShouldProcess) => {\r\n                setTimeout(() => {\r\n                  if (currentShouldProcess) {\r\n                    (0,_notifications_js__WEBPACK_IMPORTED_MODULE_1__.createStaticNotification)(userAction, actionIconType, timestamp, userPresence, 'cachePanel');\r\n                  }\r\n                }, 10 * (index + 1));\r\n              })(shouldProcessActionLog);\r\n            }\r\n          }\r\n\r\n          const closeActionLog = (e) => {\r\n            if (!actionLogContainer.contains(e.target) || e.code === 'Space') {\r\n              if (e.code === 'Space') e.preventDefault(); // Prevent the default space key behavior\r\n              (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.adjustVisibility)(actionLogContainer, 'hide', 0);\r\n              shouldProcessActionLog = false;\r\n              ['click', 'keydown'].forEach(event => document.removeEventListener(event, closeActionLog));\r\n            }\r\n          };\r\n\r\n          ['click', 'keydown'].forEach(event => document.addEventListener(event, closeActionLog));\r\n\r\n          // Prevent the click on visitsElement from propagating, so it doesn't close immediately\r\n          event.stopPropagation();\r\n        } else {\r\n          console.error('User data not found');\r\n        }\r\n      });\r\n    }\r\n\r\n    // Append login container to user data element\r\n    userDataElement.appendChild(loginContainer);\r\n\r\n    const rankElement = document.createElement('div');\r\n    rankElement.className = 'rank';\r\n    rankElement.textContent = userData.rank || 'N/A';\r\n    rankElement.style.color = rankColors[userData.rank] || 'white';\r\n\r\n    // Append rank element to the user data element\r\n    userDataElement.appendChild(rankElement);\r\n\r\n    // Add a registered date element with hover behavior.\r\n    const registeredElement = document.createElement('div');\r\n    registeredElement.className = 'registered';\r\n    registeredElement.textContent = userData.registered || 'N/A';\r\n\r\n    let hoverTimer;\r\n    const originalContent = registeredElement.textContent;\r\n\r\n    registeredElement.addEventListener('mouseover', () => {\r\n      clearTimeout(hoverTimer);\r\n      hoverTimer = setTimeout(() => {\r\n        registeredElement.textContent = calculateTimeOnSite(userData.registered);\r\n      }, 300);\r\n    });\r\n\r\n    registeredElement.addEventListener('mouseout', () => {\r\n      clearTimeout(hoverTimer);\r\n      registeredElement.textContent = originalContent;\r\n    });\r\n\r\n    // Append registered element to user data element\r\n    userDataElement.appendChild(registeredElement);\r\n\r\n    // Helper function to create metric elements (speed, rating, etc.).\r\n    const createMetricElement = (className, color, icon, value, title, url) => {\r\n      const element = document.createElement('span');\r\n      element.className = className;\r\n      element.style.color = color;\r\n      element.innerHTML = `${icon}${value || 0}&nbsp;&nbsp;`;\r\n      element.title = title;\r\n      element.style.cursor = 'pointer';\r\n      element.addEventListener('click', () => loadProfileIntoIframe(url));\r\n      return element;\r\n    };\r\n\r\n    // Create individual metric elements for the user.\r\n    const bestSpeedElement = createMetricElement(\r\n      'best-speed',\r\n      'cyan',\r\n      '🚀',\r\n      userData.bestSpeed,\r\n      'Best speed',\r\n      `https://klavogonki.ru/u/#/${userId}/stats/normal/`\r\n    );\r\n\r\n    const ratingLevelElement = createMetricElement(\r\n      'rating-level',\r\n      'gold',\r\n      '⭐',\r\n      userData.ratingLevel,\r\n      'Rating level',\r\n      `https://klavogonki.ru/top/rating/today?s=${userData.login}`\r\n    );\r\n\r\n    const carsElement = createMetricElement(\r\n      'cars-count',\r\n      'lightblue',\r\n      '🚖',\r\n      userData.cars,\r\n      'Cars count',\r\n      `https://klavogonki.ru/u/#/${userId}/car/`\r\n    );\r\n\r\n    const friendsElement = createMetricElement(\r\n      'friends-count',\r\n      'lightgreen',\r\n      '🤝',\r\n      userData.friends,\r\n      'Friends count',\r\n      `https://klavogonki.ru/u/#/${userId}/friends/list/`\r\n    );\r\n\r\n    // Group all metrics into a container.\r\n    const userMetrics = document.createElement('div');\r\n    userMetrics.className = 'user-metrics';\r\n\r\n    // Append metrics elements into metrics wrapper\r\n    userMetrics.append(bestSpeedElement, ratingLevelElement, carsElement, friendsElement);\r\n\r\n    // Append all the groups of elements\r\n    userElement.append(avatarElement, userDataElement, userMetrics);\r\n\r\n    // Return the created user element and its relevant data.\r\n    return {\r\n      userElement,\r\n      order: rankOrder[userData.rank] || 10,\r\n      bestSpeed: userData.bestSpeed || 0,\r\n      registered: userData.registered\r\n    };\r\n  };\r\n\r\n  // Check if the current mode is 'cache'\r\n  if (localStorage.getItem('cachePanelSearchMode') === 'cache') {\r\n    // Iterate through each user\r\n    Object.keys(users).forEach(async (userId) => {\r\n      const userData = users[userId];\r\n      const userElementData = createCachePanelUserElement(userId, userData);\r\n      userElements.push(userElementData);\r\n    });\r\n\r\n    // Sort userElements by rank and best speed\r\n    userElements.sort((a, b) =>\r\n      // First by rank, then by speed\r\n      a.order !== b.order ? a.order - b.order : b.bestSpeed - a.bestSpeed\r\n    );\r\n\r\n    // Distribute userElements into new or old users containers\r\n    userElements.forEach(({ userElement, registered }) => {\r\n      // Choose container\r\n      const targetContainer = isNewUser(registered) ? newUsersContainer : oldUsersContainer;\r\n      // Append userElement\r\n      targetContainer.appendChild(userElement);\r\n    });\r\n  }\r\n\r\n  // Append the panel-header container to the cached-users-panel\r\n  cachedUsersPanel.appendChild(panelHeaderContainer);\r\n  // Append the fetched-users container to the cached-users-panel\r\n  cachedUsersPanel.appendChild(fetchedUsersContainer);\r\n  // Append the cached-users-panel to the body\r\n  document.body.appendChild(cachedUsersPanel);\r\n\r\n  // Create and append scroll buttons\r\n  const {\r\n    scrollButtonsContainer\r\n  } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.createScrollButtons)(fetchedUsersContainer);\r\n  cachedUsersPanel.appendChild(scrollButtonsContainer);\r\n\r\n  // Fade in the cached users panel\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerTargetElement)(cachedUsersPanel, 'show');\r\n\r\n  // Show the dimming background\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)('show');\r\n\r\n  // Function to update the remaining time\r\n  function updateRemainingTime() {\r\n    const lastClearTime = localStorage.getItem('lastClearTime');\r\n    const nextClearTime = localStorage.getItem('nextClearTime');\r\n    const dropTimeExpiration = document.querySelector('.drop-time-expiration');\r\n\r\n    if (lastClearTime && nextClearTime && dropTimeExpiration) {\r\n      const currentTime = new Date().getTime();\r\n\r\n      // Calculate the remaining time until the next cache clear\r\n      const remainingTime = nextClearTime - currentTime;\r\n\r\n      // If remaining time is zero or less, execute the refreshFetchedUsers function\r\n      remainingTime <= 0\r\n        ? (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.refreshFetchedUsers)(true, _definitions_js__WEBPACK_IMPORTED_MODULE_3__.cacheRefreshThresholdHours)\r\n        : updatedropTimeExpiration(dropTimeExpiration, remainingTime);\r\n    }\r\n  }\r\n\r\n  // Create a mapping of seconds to clock emojis\r\n  const emojiMap = {\r\n    0: '🕛',\r\n    5: '🕐',\r\n    10: '🕑',\r\n    15: '🕒',\r\n    20: '🕓',\r\n    25: '🕔',\r\n    30: '🕕',\r\n    35: '🕖',\r\n    40: '🕗',\r\n    45: '🕘',\r\n    50: '🕙',\r\n    55: '🕚',\r\n  };\r\n\r\n  // Function to update the drop-time-expiration span\r\n  function updatedropTimeExpiration(dropTimeExpiration, remainingTime) {\r\n    // Calculate hours, minutes, and seconds\r\n    const hours = String(Math.floor(remainingTime / (60 * 60 * 1000))).padStart(2, '0');\r\n    const minutes = String(Math.floor((remainingTime % (60 * 60 * 1000)) / (60 * 1000))).padStart(2, '0');\r\n    const seconds = String(Math.floor((remainingTime % (60 * 1000)) / 1000)).padStart(2, '0');\r\n\r\n    // Create the formatted time string\r\n    const remainingTimeString = `${hours}:${minutes}:${seconds}`;\r\n\r\n    // Determine the current seconds\r\n    const parsedSeconds = parseInt(seconds, 10);\r\n\r\n    // Use the parsed seconds to find the emoji index, moving one forward\r\n    const nextInterval = Math.ceil(parsedSeconds / 5) * 5; // Move to the next 5-second mark\r\n    const currentEmoji = emojiMap[nextInterval] || emojiMap[0]; // Default to 00 if not found\r\n\r\n    // Update the drop-time-expiration span with the time and emoji\r\n    dropTimeExpiration.textContent = `${remainingTimeString} ${currentEmoji}`;\r\n  }\r\n\r\n  // Call the function to update the remaining time every second\r\n  setInterval(updateRemainingTime, 1000);\r\n\r\n  // Initial update\r\n  updateRemainingTime();\r\n} // showCachePanel END\r\n\r\n// Global function to smoothly hide and remove the cachedUsersPanel\r\nfunction hideCachePanel() {\r\n  const cachedUsersPanel = document.querySelector('.cached-users-panel');\r\n\r\n  if (cachedUsersPanel) {\r\n    // Call the fade function for the cachedUsersPanel\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerTargetElement)(cachedUsersPanel, 'hide');\r\n    // Call the fade function for the dimming element\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)('hide');\r\n  }\r\n} // hideCachePanel END\r\n\r\nfunction createCacheButton(panel) {\r\n  // Create a new element with class 'cache-panel-load-button'\r\n  const showUserListCacheButton = document.createElement('div');\r\n\r\n  // Add the classes to the button\r\n  showUserListCacheButton.classList.add(\"empowerment-button\", \"cache-panel-load-button\");\r\n\r\n  // Apply cache-specific styles\r\n  showUserListCacheButton.style.position = 'relative';\r\n  showUserListCacheButton.style.zIndex = '3';\r\n\r\n  // Set the inner HTML with the icon (using the global variable or later fix)\r\n  showUserListCacheButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_2__.userlistCacheSVG; // Adjust this later as needed\r\n\r\n  // Create the small indicator for user count\r\n  const cacheUserCount = document.createElement('div');\r\n  cacheUserCount.classList.add('cache-user-count');\r\n\r\n  // Initially set the count based on localStorage\r\n  const cacheUserCountValue = Object.keys(fetchedUsers).length;\r\n  cacheUserCount.textContent = cacheUserCountValue;\r\n\r\n  showUserListCacheButton.appendChild(cacheUserCount);\r\n\r\n  // Assign a title to the button\r\n  showUserListCacheButton.title = 'Show Cache Panel';\r\n\r\n  // Add a click event listener to the button\r\n  showUserListCacheButton.addEventListener('click', function () {\r\n    // Add pulse effect for the button (ensure addPulseEffect is defined or imported)\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addPulseEffect)(showUserListCacheButton);\r\n\r\n    // Call showCachePanel to show the cache panel (ensure showCachePanel is defined or imported)\r\n    showCachePanel();\r\n  });\r\n\r\n  // Append the button to the provided panel\r\n  panel.appendChild(showUserListCacheButton);\r\n}\r\n\r\n// Function to update the user count displayed near the cache button based on localStorage\r\nfunction updateUserCountText() {\r\n  const userCountElement = document.querySelector('.cache-panel-load-button .cache-user-count');\r\n  if (!userCountElement) return; // Ensure the element exists\r\n\r\n  // Get count from state instead of localStorage\r\n  const newUserCount = Object.keys(fetchedUsers).length.toString();\r\n\r\n  // Update the text content and add pulse effect if the count has changed\r\n  if (newUserCount !== userCountElement.textContent) {\r\n    userCountElement.textContent = newUserCount;\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addPulseEffect)(userCountElement);\r\n  }\r\n}\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/cache.js?");

/***/ }),

/***/ "./src/modules/chat.js":
/*!*****************************!*\
  !*** ./src/modules/chat.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getChatElements: () => (/* binding */ getChatElements),\n/* harmony export */   getChatSystemMessage: () => (/* binding */ getChatSystemMessage),\n/* harmony export */   restoreChatTab: () => (/* binding */ restoreChatTab),\n/* harmony export */   setChatFieldFocus: () => (/* binding */ setChatFieldFocus),\n/* harmony export */   setupChatInputListener: () => (/* binding */ setupChatInputListener),\n/* harmony export */   setupInputBackup: () => (/* binding */ setupInputBackup)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/modules/helpers.js\");\n// helpers\r\n\r\n\r\n// ========================================================================\r\n// DEFINITIONS\r\n// ========================================================================\r\n\r\nconst currentLocationIncludes = part => window.location.href.includes(part);\r\n\r\nconst extraTimeout = 5000;\r\nconst minimalTimeout = 1000;\r\n\r\nconst blockedChatMessage = 'Вы не можете отправлять сообщения';\r\nconst lostConnectionMessage = 'Связь с сервером потеряна';\r\n\r\n// ========================================================================\r\n// HELPER FUNCTIONS\r\n// ========================================================================\r\n\r\n// ---- DOM Utilities ----\r\n// Dynamically retrieves the current chat elements based on the active tab.\r\nconst getChatElements = () => {\r\n  const activeTab = localStorage.getItem('activeChatTab');\r\n  const isGameLocation = window.location.href.includes('gmid');\r\n\r\n  // Default to general chat elements\r\n  const chatFieldSelector = isGameLocation\r\n    ? (activeTab === 'game' ? '[id^=\"chat-game\"] .text' : '#chat-general .text')\r\n    : '#chat-general .text';\r\n\r\n  const chatSendSelector = isGameLocation\r\n    ? (activeTab === 'game' ? '[id^=\"chat-game\"] .send' : '#chat-general .send')\r\n    : '#chat-general .send';\r\n\r\n  // Get the currently active tab based on localStorage's activeTab value (used for restore)\r\n  const activeChatTab = document.querySelector(\r\n    isGameLocation\r\n      ? (activeTab === 'game' ? '.game.c' : '.general.c') // Select the active tab (game or general)\r\n      : (activeTab === 'general' ? '.general.c' : '.game.c') // If activeTab is general, select general\r\n  );\r\n\r\n  // Get next tab to switch (either general or game)\r\n  const nextChatTab = document.querySelector(\r\n    isGameLocation\r\n      ? (document.querySelector('.game.c.active') ? '.general.c' : '.game.c')\r\n      : (document.querySelector('.general.c.active') ? '.game.c' : '.general.c')\r\n  );\r\n\r\n  return {\r\n    chatField: document.querySelector(chatFieldSelector),\r\n    chatSend: document.querySelector(chatSendSelector),\r\n    activeChatTab, // Return the currently active tab element (either general or game)\r\n    nextChatTab, // Return the next tab to switch to\r\n    chatHidden: document.querySelector('#chat-wrapper.chat-hidden')\r\n  };\r\n};\r\n\r\n// ---- Chat System Helpers ----\r\n// Extracts a system message from the chat field's value.\r\n// Returns the message string if found, or null otherwise.\r\nfunction getChatSystemMessage(chatField) {\r\n  if (!chatField) return null;\r\n  const value = chatField.value;\r\n  if (value.includes(blockedChatMessage)) return blockedChatMessage;\r\n  if (value.includes(lostConnectionMessage)) return lostConnectionMessage;\r\n  return null;\r\n}\r\n\r\n// ========================================================================\r\n// CHAT CONNECTION RESTORATION AND UNBLOCK HANDLER\r\n// ========================================================================\r\nif (currentLocationIncludes('gamelist')) {\r\n  // Function to handle changes when the chat field is disabled.\r\n  function handleChatStateChange(timeout, chatField, chatSend) {\r\n    if (chatField.disabled) {\r\n      const systemMessage = getChatSystemMessage(chatField);\r\n      if (systemMessage === blockedChatMessage) {\r\n        // Re-enable the chat field and send button, and update their styles.\r\n        chatField.disabled = chatSend.disabled = false;\r\n        chatSend.style.setProperty('background-color', 'rgb(160, 35, 35)', 'important');\r\n        chatSend.style.setProperty(\r\n          'background-image',\r\n          `url(\"data:image/svg+xml,${encodeURIComponent(icons.deniedSVG)}\")`,\r\n          'important'\r\n        );\r\n        chatSend.style.setProperty('background-repeat', 'no-repeat', 'important');\r\n        chatSend.style.setProperty('background-position', 'center', 'important');\r\n        chatSend.style.setProperty('color', 'transparent', 'important');\r\n        chatField.value = null;\r\n        console.log('Chat field was blocked, re-enabled.');\r\n      } else if (systemMessage === lostConnectionMessage) {\r\n        // Schedule a reload using timeout.\r\n        console.log('Lost connection, reloading...');\r\n        setTimeout(() => {\r\n          window.location.reload();\r\n        }, timeout);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Create a MutationObserver to watch for attribute changes.\r\n  const observer = new MutationObserver(() => {\r\n    // Get updated chat elements.\r\n    const { chatField, chatSend } = getChatElements();\r\n    // Handle the change when the 'disabled' attribute is modified.\r\n    handleChatStateChange(extraTimeout, chatField, chatSend);\r\n  });\r\n\r\n  // Get the chat field element.\r\n  const { chatField: chatInputText } = getChatElements();\r\n  // Start observing the chatField for changes to the 'disabled' attribute.\r\n  if (chatInputText)\r\n    observer.observe(chatInputText, { attributes: true, attributeFilter: ['disabled'] });\r\n\r\n  // Compact visibilitychange event: When the document becomes visible,\r\n  // set a shorter timeout duration and check the chat state.\r\n  document.addEventListener('visibilitychange', () => {\r\n    if (document.visibilityState === 'visible') {\r\n      const { chatField, chatSend } = getChatElements();\r\n      handleChatStateChange(minimalTimeout, chatField, chatSend);\r\n    }\r\n  });\r\n}\r\n\r\n// ========================================================================\r\n// CHAT FOCUS\r\n// ========================================================================\r\n\r\n// Function to set focus on the chat input field based on the active tab.\r\nfunction setChatFieldFocus() {\r\n  const { chatHidden, chatField } = getChatElements(); // Get chat field elements\r\n\r\n  if (!chatHidden && chatField) {\r\n    chatField.focus(); // Set focus on the chat input field\r\n  }\r\n}\r\n\r\n// ========================================================================\r\n// CHAT SWITCHER  \r\n// ========================================================================\r\n\r\nfunction switchChatByKeydown() {\r\n  const { nextChatTab, chatField, chatHidden } = getChatElements();\r\n\r\n  if (!chatHidden && nextChatTab) {\r\n    nextChatTab.click();\r\n    chatField?.focus();\r\n  }\r\n}\r\n\r\nfunction switchChatByClick(event) {\r\n  console.log('Clicked element:', event.target);\r\n  const activeTab = event.target.classList.contains('general') ? 'general' : 'game';\r\n  localStorage.setItem('activeChatTab', activeTab);\r\n}\r\n\r\n// Function to restore the active chat tab and set focus on the chat input.\r\nfunction restoreChatTab() {\r\n  const { activeChatTab, chatField } = getChatElements();\r\n  activeChatTab?.click();\r\n  chatField?.focus();\r\n}\r\n\r\n// ========================================================================\r\n// CHAT EVENTS & LISTENERS\r\n// ========================================================================\r\n\r\n\r\n[...document.querySelectorAll('.general.c, .game.c')].forEach(tab =>\r\n  tab.addEventListener('click', switchChatByClick)\r\n);\r\n\r\ndocument.addEventListener('keydown', event => {\r\n  if (event.key === 'Tab') {\r\n    switchChatByKeydown();\r\n    event.preventDefault();\r\n  }\r\n});\r\n\r\n// ========================================================================\r\n// INPUT BACKUP & RESTORATION\r\n// ========================================================================\r\n\r\nfunction setupInputBackup() {\r\n  const { chatField } = getChatElements();\r\n  if (chatField) {\r\n    chatField.value = localStorage.getItem('inputBackup') || '';\r\n\r\n    chatField.addEventListener('input', (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.debounce)(() => {\r\n      if (!getChatSystemMessage(chatField)) localStorage.setItem('inputBackup', chatField.value);\r\n    }, 250));\r\n\r\n    chatField.addEventListener('keydown', event => {\r\n      if (event.key === 'Enter') localStorage.removeItem('inputBackup');\r\n    });\r\n  }\r\n}\r\n\r\n// ========================================================================\r\n// MESSAGE SENDING\r\n// ========================================================================\r\n\r\n// Compact function to break text into pieces of up to 300 characters.\r\nfunction breakSentence(text) {\r\n  const maxLength = 300;\r\n  return text.split(' ').reduce((acc, word) => {\r\n    const last = acc[acc.length - 1];\r\n    return (last + ' ' + word).trim().length > maxLength\r\n      ? [...acc, word]\r\n      : [...acc.slice(0, -1), (last + ' ' + word).trim()];\r\n  }, ['']);\r\n}\r\n\r\nasync function sendMessageInParts(message) {\r\n  const pieces = breakSentence(message);\r\n  const { chatField, chatSend } = getChatElements();\r\n  const isLongMessage = message.length > 300;\r\n\r\n  if (isLongMessage) {\r\n    chatField.disabled = true;\r\n  }\r\n\r\n  for (let index = 0; index < pieces.length; index++) {\r\n    const fullMessage = pieces[index];\r\n    chatField.value = fullMessage;\r\n    console.log(`Sending piece ${index + 1}: \"${fullMessage}\" (Length: ${fullMessage.length})`);\r\n    chatSend.click();\r\n\r\n    if (index < pieces.length - 1) {\r\n      const randomDelay = Math.floor(Math.random() * 500) + 500;\r\n      console.log(`Waiting for ${randomDelay} ms before sending the next piece.`);\r\n      await new Promise(resolve => setTimeout(resolve, randomDelay));\r\n    }\r\n  }\r\n\r\n  if (isLongMessage) {\r\n    chatField.disabled = false;\r\n  }\r\n}\r\n\r\n// ========================================================================\r\n// CHAT INPUT EVENTS\r\n// ========================================================================\r\n\r\nfunction setupChatInputListener() {\r\n  const { chatField } = getChatElements();\r\n  chatField.setAttribute('maxlength', '1000');\r\n\r\n  chatField.addEventListener('paste', event => {\r\n    event.preventDefault();\r\n    const pastedValue = event.clipboardData.getData('text');\r\n    let processedValue = pastedValue;\r\n\r\n    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isValidEncodedURL)(pastedValue)) {\r\n      processedValue = decodeURL(pastedValue);\r\n    }\r\n\r\n    const start = chatField.selectionStart;\r\n    const end = chatField.selectionEnd;\r\n    chatField.value = chatField.value.slice(0, start) + processedValue + chatField.value.slice(end);\r\n    chatField.setSelectionRange(start + processedValue.length, start + processedValue.length);\r\n  });\r\n\r\n  chatField.addEventListener('keydown', event => {\r\n    const message = chatField.value;\r\n    if (event.key === 'Enter') {\r\n      if (message.length > 300) {\r\n        event.preventDefault();\r\n        sendMessageInParts(message);\r\n        console.log(`Long message processed: \"${message}\"`);\r\n        chatField.value = '';\r\n      } else {\r\n        console.log(`Short message processed: \"${message}\"`);\r\n      }\r\n    }\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/chat.js?");

/***/ }),

/***/ "./src/modules/chatlogs.js":
/*!*********************************!*\
  !*** ./src/modules/chatlogs.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createChatLogsButton: () => (/* binding */ createChatLogsButton)\n/* harmony export */ });\n/* harmony import */ var _image_converter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-converter.js */ \"./src/modules/image-converter.js\");\n/* harmony import */ var _video_converter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./video-converter.js */ \"./src/modules/video-converter.js\");\n/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons */ \"./src/modules/icons.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.js */ \"./src/modules/helpers.js\");\n/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./definitions.js */ \"./src/modules/definitions.js\");\n // image converter\r\n // video converter\r\n\r\n// icons\r\n\r\n\r\n// helpers\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Define dynamic variables\r\nlet {\r\n  panelsEvents,\r\n  isCtrlKeyPressed\r\n} = _definitions_js__WEBPACK_IMPORTED_MODULE_4__.state;\r\n\r\n// Function to create the button for opening chat logs\r\nfunction createChatLogsButton(panel) {\r\n  const showChatLogsButton = document.createElement('div');\r\n  showChatLogsButton.classList.add(\"empowerment-button\", \"chat-logs-button\");\r\n\r\n  showChatLogsButton.style.position = 'relative';\r\n  showChatLogsButton.style.zIndex = '1';\r\n  showChatLogsButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.chatLogsSVG; // Add icon\r\n\r\n  showChatLogsButton.title = 'Show Chat Logs';\r\n\r\n  showChatLogsButton.addEventListener('click', async function () {\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.addPulseEffect)(showChatLogsButton); // Add pulse effect\r\n    await showChatLogsPanel();\r\n  });\r\n\r\n  panel.appendChild(showChatLogsButton);\r\n}\r\n\r\n// Function to fetch chat logs from the specified URL for a given date\r\nconst fetchChatLogs = async (date, messagesContainer) => {\r\n  // Clear the messagesContainer if it exists\r\n  messagesContainer && (messagesContainer.innerHTML = '');\r\n\r\n  // Generate a random 20-digit number\r\n  const randomParam = Math.floor(Math.random() * 10 ** 20);\r\n\r\n  // Construct the URL to fetch chat logs for the specified date with the random parameter\r\n  const url = `https://klavogonki.ru/chatlogs/${date}.html?rand=${randomParam}`;\r\n\r\n  // Function to parse the HTML and extract chat log entries\r\n  const parseChatLog = (html) => {\r\n    const doc = new DOMParser().parseFromString(html, 'text/html');\r\n\r\n    return [...doc.querySelectorAll('.ts')].map((timeElement) => {\r\n      const usernameElement = timeElement.nextElementSibling;\r\n      const messageNode = usernameElement?.nextSibling;\r\n\r\n      const extractMessageText = (node) => {\r\n        if (!node) return '';\r\n        return [...node.childNodes].reduce((acc, child) => {\r\n          if (child.nodeType === Node.TEXT_NODE) {\r\n            acc += child.textContent;\r\n          } else if (child.nodeType === Node.ELEMENT_NODE) {\r\n            if (child.tagName === 'A') {\r\n              acc += child.getAttribute('href');\r\n            } else if (child.tagName === 'BR') {\r\n              return acc;\r\n            }\r\n          }\r\n          return acc;\r\n        }, '').trim();\r\n      };\r\n\r\n      if (usernameElement?.classList.contains('mn') && messageNode) {\r\n        let messageText = '';\r\n\r\n        if (messageNode.nodeType === Node.ELEMENT_NODE) {\r\n          messageText = extractMessageText(messageNode);\r\n        } else if (messageNode.nodeType === Node.TEXT_NODE) {\r\n          const nextSibling = usernameElement.nextElementSibling;\r\n          if (nextSibling && nextSibling.tagName === 'A') {\r\n            messageText = `${messageNode.textContent.trim()} ${nextSibling.getAttribute('href')}`;\r\n          } else {\r\n            messageText = messageNode.textContent.trim();\r\n          }\r\n        }\r\n\r\n        if (!messageText) {\r\n          const combinedText = extractMessageText(usernameElement.nextSibling);\r\n          messageText = combinedText;\r\n        }\r\n\r\n        return {\r\n          time: timeElement.textContent.trim().replace(/[\\[\\]]/g, ''),\r\n          username: usernameElement.textContent.trim().replace(/<|>/g, ''),\r\n          message: messageText || null,\r\n        };\r\n      }\r\n\r\n      // Handle case where username is not found, and instead, `mne` class is present (system message)\r\n      const systemMessageElement = timeElement.nextElementSibling;\r\n      if (systemMessageElement && systemMessageElement.classList.contains('mne')) {\r\n        // Extract the text directly from the <font> element\r\n        const messageText = systemMessageElement.textContent.trim();\r\n        return {\r\n          time: timeElement.textContent.trim().replace(/[\\[\\]]/g, ''),\r\n          username: 'SYSTEM', // Set username as 'SYSTEM' for system messages\r\n          message: messageText || null,\r\n        };\r\n      }\r\n\r\n      return null;\r\n    }).filter(Boolean);\r\n  };\r\n\r\n  try {\r\n    // Fetch chat logs from the URL\r\n    const response = await fetch(url);\r\n    if (!response.ok) {\r\n      throw new Error('Network response was not ok');\r\n    }\r\n\r\n    // Get the HTML content\r\n    const html = await response.text();\r\n\r\n    // Limit the size of the HTML to 5KB\r\n    const sizeLimitKB = 1000; // Set the size limit in KB\r\n    const sizeLimitBytes = sizeLimitKB * 1024; // Convert KB to bytes\r\n    const htmlContent = html.length > sizeLimitBytes ? html.slice(0, sizeLimitBytes) : html;\r\n\r\n    // Parse the HTML and extract chat logs\r\n    const chatlogs = parseChatLog(htmlContent);\r\n\r\n    const limitReached = html.length > sizeLimitBytes;\r\n\r\n    // Step 1: Remove consecutive duplicate messages\r\n    const noSpamMessages = [];\r\n    let lastMessage = null;\r\n\r\n    for (const log of chatlogs) {\r\n      const isDifferentMessage = log.message !== lastMessage?.message;\r\n      const isDifferentUser = log.username !== lastMessage?.username;\r\n\r\n      // Include the message if:\r\n      // - It's the first message, or\r\n      // - It's a different message or from a different user\r\n      if (isDifferentMessage || isDifferentUser) {\r\n        noSpamMessages.push(log);\r\n        lastMessage = log;\r\n      }\r\n    }\r\n\r\n    // Step 2: Filter out messages from ignored users\r\n    const finalChatlogs = noSpamMessages.filter((log) => !_definitions_js__WEBPACK_IMPORTED_MODULE_4__.ignored.includes(log.username));\r\n\r\n    // Return the filtered chat logs, size of HTML, URL, and info\r\n    return {\r\n      chatlogs: finalChatlogs,\r\n      url: url,\r\n      size: htmlContent.length,\r\n      info: limitReached,\r\n      error: null,\r\n    }\r\n  } catch (error) {\r\n    // Handle other errors (e.g., parsing errors)\r\n    return {\r\n      chatlogs: [],\r\n      url: url,\r\n      size: 0,\r\n      error: error.message,\r\n    }\r\n  }\r\n}\r\n\r\nconst minDate = '2012-02-12'; // Define the minimum date\r\n\r\nfunction getRandomDateInRange() {\r\n  const startDate = new Date(minDate); // Start date\r\n  const endDate = new Date(); // Current date\r\n\r\n  // Calculate the difference in milliseconds\r\n  const dateDifference = endDate - startDate;\r\n\r\n  // Generate a random number of milliseconds between 0 and dateDifference\r\n  const randomMilliseconds = Math.floor(Math.random() * dateDifference);\r\n\r\n  // Create a random date by adding the random milliseconds to the start date\r\n  const randomDate = new Date(startDate.getTime() + randomMilliseconds);\r\n\r\n  // Format the date to 'YYYY-MM-DD' using Intl.DateTimeFormat\r\n  const formattedDate = new Intl.DateTimeFormat('en-CA').format(randomDate);\r\n\r\n  return formattedDate;\r\n}\r\n\r\n// Function to get user ID by username (with caching in localStorage)\r\nasync function getUserId(username) {\r\n  const userIdsCache = JSON.parse(localStorage.getItem('userIdsCache') || '{}');\r\n\r\n  // If the user ID is cached, return it\r\n  if (userIdsCache[username]) return userIdsCache[username];\r\n\r\n  try {\r\n    // Fetch the user ID\r\n    const userId = await getExactUserIdByName(username);\r\n    if (userId) {\r\n      userIdsCache[username] = userId;\r\n      localStorage.setItem('userIdsCache', JSON.stringify(userIdsCache));\r\n      return userId;\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fetching user ID for ${username}:`, error);\r\n  }\r\n\r\n  return null; // Return null if no user found\r\n}\r\n\r\n// Initialize the visibility state for media and mention messages\r\nlet visibleMessages = { media: false, mention: false };\r\n\r\n// Function to reset the visibleMessages object\r\nconst resetVisibleMessages = () => { visibleMessages = { media: false, mention: false }; };\r\n\r\n// Function to toggle the visibility of message items based on the given selector\r\nasync function toggleMessagesVisibility(selector) {\r\n  // Determine if the selector is 'media' or 'mention' and update visibility states\r\n  const isMedia = selector === 'media';\r\n  const isMention = selector === 'mention';\r\n\r\n  // Update the visibility state: toggle the selected type and reset the other\r\n  visibleMessages = {\r\n    media: isMedia ? !visibleMessages.media : false, // Toggle media visibility\r\n    mention: isMention ? !visibleMessages.mention : false // Toggle mention visibility\r\n  };\r\n\r\n  // Iterate over all message items and apply the corresponding visibility rules\r\n  document.querySelectorAll('.message-item').forEach(item => {\r\n    // Check if the message item contains media or mention content\r\n    const hasMediaClass = item.querySelector('.media');\r\n    const hasMentionClass = item.querySelector('.mention');\r\n\r\n    // Case: Showing only media elements (when 'media' is toggled)\r\n    if (visibleMessages.media) {\r\n      item.style.contentVisibility = hasMediaClass ? 'visible' : 'hidden'; // Show/hide based on media class\r\n      item.style.fontSize = hasMediaClass ? '' : '0'; // Adjust font size based on visibility\r\n    }\r\n    // Case: Showing only mention elements (when 'mention' is toggled)\r\n    else if (visibleMessages.mention) {\r\n      item.style.contentVisibility = hasMentionClass ? 'visible' : 'hidden'; // Show/hide based on mention class\r\n      item.style.fontSize = hasMentionClass ? '' : '0'; // Adjust font size based on visibility\r\n    }\r\n    // Case: Show all messages when neither 'media' nor 'mention' is toggled\r\n    else {\r\n      item.style.contentVisibility = 'visible'; // Ensure the message is visible\r\n      item.style.fontSize = ''; // Reset font size to default\r\n    }\r\n  });\r\n}\r\n\r\n//   Function to display the chat logs panel\r\n// Load initially with default date or date given by personal messages panel with parameter date\r\nasync function showChatLogsPanel(personalMessagesDate) {\r\n  // Check if the panel already exists\r\n  const existingPanel = document.querySelector('.chat-logs-panel');\r\n  if (existingPanel) {\r\n    existingPanel.remove(); // Remove the settings panel\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n    return; // Return immediately to prevent further execution\r\n  }\r\n\r\n  // Remove any previous panel before creating a new one\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.removePreviousPanel)();\r\n\r\n  // Create a container div with class 'chat-logs-panel'\r\n  const chatLogsPanel = document.createElement('div');\r\n  chatLogsPanel.className = 'chat-logs-panel popup-panel';\r\n\r\n  // Create a container div for the panel header\r\n  const panelHeaderContainer = document.createElement('div');\r\n  panelHeaderContainer.className = 'panel-header';\r\n\r\n  // Create a container div with class 'panel-control-buttons'\r\n  const panelControlButtons = document.createElement('div');\r\n  panelControlButtons.className = 'panel-control-buttons';\r\n\r\n  // Create a container div for the search input\r\n  const chatlogsSearchContainer = document.createElement('div');\r\n  chatlogsSearchContainer.className = 'search-for-chatlogs-messages';\r\n\r\n  // Create the input field for searching users\r\n  const chatlogsSearchInput = document.createElement('input');\r\n  chatlogsSearchInput.className = 'chatlogs-search-input';\r\n  chatlogsSearchInput.type = 'text';\r\n\r\n  // Append search input to the search container\r\n  chatlogsSearchContainer.appendChild(chatlogsSearchInput);\r\n  // Append the search container to the panel header container\r\n  panelHeaderContainer.appendChild(chatlogsSearchContainer);\r\n\r\n  // Add input event listener to filter items as the user types\r\n  chatlogsSearchInput.addEventListener('input', () => filterItems(chatlogsSearchInput.value));\r\n\r\n  // Clears the input when the left mouse button (LMB) is clicked while holding the Ctrl key\r\n  // Also updates the filtered items accordingly\r\n  chatlogsSearchInput.addEventListener('click', (event) => {\r\n    if (event.ctrlKey) {\r\n      chatlogsSearchInput.value = '';\r\n      // Call the function to update the filtered items based on the cleared input\r\n      filterItems(chatlogsSearchInput.value);\r\n    }\r\n  });\r\n\r\n  // Add keydown event listener to handle date format and validity check\r\n  chatlogsSearchInput.addEventListener('keydown', async (event) => {\r\n    const inputValue = chatlogsSearchInput.value;\r\n\r\n    if (event.key === 'Enter') {\r\n      let normalizedDate = inputValue;\r\n\r\n      // Handle 8-digit and 6-digit date formats\r\n      if (/^\\d{8}$/.test(inputValue)) {\r\n        normalizedDate = inputValue.length === 6 ? '20' + inputValue : inputValue;\r\n        normalizedDate = normalizedDate.replace(/(\\d{4})(\\d{2})(\\d{2})/, '$1-$2-$3');\r\n      } else if (/^\\d{6}$/.test(inputValue)) {\r\n        normalizedDate = '20' + inputValue.replace(/(\\d{2})(\\d{2})(\\d{2})/, '$1-$2-$3');\r\n      }\r\n\r\n      // Check if the normalized input matches either 'yyyy:mm:dd' or 'yyyy-mm-dd' format\r\n      const isValidFormat = /^\\d{2,4}[:\\-]\\d{2}[:\\-]\\d{2}$/.test(normalizedDate.replace(/:/g, '-'));\r\n\r\n      // Check if the normalized date is a valid date\r\n      const isValidDate = isValidFormat && !isNaN(new Date(normalizedDate.replace(/:/g, '-')).getTime());\r\n\r\n      if (isValidDate) {\r\n        await loadChatLogs(normalizedDate); // Load chat logs for the determined date\r\n        showDateInput(dateInput);\r\n      } else {\r\n        alert('Please enter a valid date.\\n\\nValid formats include:\\n' +\r\n          '1. yyyy-mm-dd\\n' +\r\n          '2. yyyy:mm:dd\\n' +\r\n          '3. yy-mm-dd\\n' +\r\n          '4. yy:mm:dd\\n' +\r\n          '5. yyyymmdd\\n' +\r\n          '6. yymmdd\\n\\n');\r\n      }\r\n\r\n      // Clear the input value after processing the \"Enter\" key\r\n      chatlogsSearchInput.value = '';\r\n    }\r\n  });\r\n\r\n  // Focus on the search input using requestAnimationFrame\r\n  function focusOnSearchField() { requestAnimationFrame(function () { chatlogsSearchInput.focus(); }); } focusOnSearchField();\r\n\r\n  // Create a date input toggle with similar styles as the close button\r\n  const dateInputToggle = document.createElement('div');\r\n  dateInputToggle.className = \"large-button panel-header-date-button\";\r\n  dateInputToggle.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.calendarSVG;\r\n\r\n  // Function to toggle visibility of an element\r\n  function toggleDateInputVisibility(element) {\r\n    element.style.display = element.style.display === 'none' ? 'flex' : 'none';\r\n  }\r\n\r\n  // Function to show the date input if it is currently hidden\r\n  function showDateInput(element) {\r\n    if (element.style.display === 'none') element.style.display = 'flex';\r\n  }\r\n\r\n  // Toggle the visibility of the date input when the toggle is clicked\r\n  dateInputToggle.addEventListener('click', () => {\r\n    toggleDateInputVisibility(dateInput);\r\n  });\r\n\r\n  // Create the date input field\r\n  const dateInput = document.createElement('input');\r\n  dateInput.type = 'date';\r\n  dateInput.className = 'chatlogs-date-input';\r\n  dateInput.style.display = \"none\";\r\n\r\n  // Append the date button and input field to the control buttons container\r\n  panelControlButtons.appendChild(dateInputToggle);\r\n  panelControlButtons.appendChild(dateInput);\r\n\r\n  // Create a toggle mention messages component\r\n  const toggleMentionMessages = document.createElement('div');\r\n  toggleMentionMessages.className = \"large-button toggle-mention-messages-button\";\r\n  // Set the inner HTML of the toggle component with a suitable SVG or text\r\n  toggleMentionMessages.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.personalMessagesSVG;\r\n  toggleMentionMessages.title = 'Toggle Mention Messages';\r\n\r\n  // Add a click event listener to toggle the visibility of messages without mentions\r\n  toggleMentionMessages.addEventListener('click', async () => {\r\n    await toggleMessagesVisibility('mention');\r\n  });\r\n\r\n  // Create a new div element for the toggle mention messages counter\r\n  const toggleMentionMessagesCounter = document.createElement('div');\r\n  // Assign a class name to the element\r\n  toggleMentionMessagesCounter.className = 'toggle-mention-messages-counter';\r\n  toggleMentionMessagesCounter.textContent = '0'; // Set as default value before assign\r\n\r\n  // Append the counter inside the toggleMentionMessages component\r\n  toggleMentionMessages.appendChild(toggleMentionMessagesCounter);\r\n  // Append the toggle mention messages component to the control panel\r\n  panelControlButtons.appendChild(toggleMentionMessages);\r\n\r\n  // Create a toggle media messages component\r\n  const toggleMediaMessages = document.createElement('div');\r\n  toggleMediaMessages.className = \"large-button panel-header-toggle-media-messages\";\r\n  // Set the inner HTML of the toggle component with a suitable SVG or text\r\n  toggleMediaMessages.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.mediaMessagesSVG;\r\n  toggleMediaMessages.title = 'Toggle Media Messages';\r\n  // Apply common styles to the component\r\n  // applyHeaderButtonStyles(toggleMediaMessages, 'darkslategray');\r\n\r\n  // Add a click event listener to toggle the visibility of media messages\r\n  toggleMediaMessages.addEventListener('click', async () => {\r\n    await toggleMessagesVisibility('media');\r\n  });\r\n\r\n  // Create a new div element for the toggle media messages counter\r\n  const toggleMediaMessagesCounter = document.createElement('div');\r\n  // Assign a class name to the element\r\n  toggleMediaMessagesCounter.className = 'toggle-media-messages-counter';\r\n  toggleMediaMessagesCounter.textContent = '0'; // Set as default value before assign\r\n\r\n  // Append the counter inside the toggleMediaMessages component\r\n  toggleMediaMessages.appendChild(toggleMediaMessagesCounter);\r\n\r\n  // Append the toggle media messages component to the control panel\r\n  panelControlButtons.appendChild(toggleMediaMessages);\r\n\r\n  // Function to update the media and mention counters\r\n  function updateMediaAndMentionCounters() {\r\n    // Update the media counter\r\n    toggleMediaMessagesCounter.textContent = document.querySelectorAll('.chat-logs-container .media').length;\r\n    // Update the mention counter\r\n    toggleMentionMessagesCounter.textContent = document.querySelectorAll('.chat-logs-container .mention').length;\r\n  }\r\n\r\n  // Create a copy chatlogs button element\r\n  const copyChatLogsUrl = document.createElement('div');\r\n  copyChatLogsUrl.className = \"large-button panel-header-copy-button\";\r\n  // Set the inner HTML of the copy chat logs element with the clipboard SVG\r\n  copyChatLogsUrl.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.clipboardSVG;\r\n  copyChatLogsUrl.title = 'Copy Chat Logs Url';\r\n  // Apply common styles to the button element\r\n  // applyHeaderButtonStyles(copyChatLogsUrl, 'steelblue');\r\n\r\n  // Helper function to extract date from the URL\r\n  const extractDateFromUrl = (url) => {\r\n    const chatlogsDateRegex = /(\\d{4}-\\d{2}-\\d{2})/;\r\n    const match = url.match(chatlogsDateRegex);\r\n    return match ? match[1] : null; // Return the date if match is found, else return null\r\n  };\r\n\r\n  // Function to create and populate chat log links\r\n  function createChatLogLinks(savedChatlogs, chatLogsLinksContainer) {\r\n    // Check if the container exists and return if not\r\n    if (!chatLogsLinksContainer) return;\r\n    // Clear the container before repopulating it\r\n    chatLogsLinksContainer.replaceChildren();\r\n\r\n    savedChatlogs.forEach(({ url, title }) => {\r\n      const date = extractDateFromUrl(url); // Extract date from URL\r\n\r\n      // Create the wrapper container for each link\r\n      const logWrapper = document.createElement('div');\r\n      logWrapper.classList.add('saved-chatlog-url-wrapper');\r\n\r\n      // Create the log link element\r\n      const logLink = document.createElement('a');\r\n      logLink.classList.add('saved-chatlog-url');\r\n      logLink.textContent = date; // Display the date\r\n      logLink.href = url; // Store the URL in the href attribute\r\n\r\n      logLink.addEventListener('click', async (event) => {\r\n        event.preventDefault(); // Prevent the default link behavior\r\n\r\n        if (event.ctrlKey) {\r\n          const urlToRemove = event.target.href;\r\n          // Find the exact match in the savedChatlogs array and remove it\r\n          const updatedChatlogs = savedChatlogs.filter(log => log.url !== urlToRemove);\r\n\r\n          // If there was a change, update localStorage and remove the link\r\n          if (updatedChatlogs.length !== savedChatlogs.length) {\r\n            savedChatlogs = updatedChatlogs;\r\n            localStorage.setItem('savedChatlogs', JSON.stringify(savedChatlogs));\r\n            const targetLink = event.target;\r\n            targetLink.closest('.saved-chatlog-url-wrapper').remove(); // Remove the wrapper\r\n          }\r\n        } else {\r\n          // Handle when Ctrl is not pressed\r\n          await loadChatLogs(date);\r\n        }\r\n      });\r\n\r\n      // Create the title element\r\n      const logTitle = document.createElement('span');\r\n      logTitle.classList.add('saved-chatlog-url-title');\r\n      logTitle.textContent = title || '➕'; // Display the title (or an empty string if none provided)\r\n\r\n      // Add click event listener to the title\r\n      logTitle.addEventListener('click', () => {\r\n        const newTitle = prompt('Enter a new title for this chat log:', logTitle.textContent);\r\n\r\n        if (newTitle !== null && newTitle !== logTitle.textContent) {\r\n          // Update the title displayed on the page\r\n          logTitle.textContent = newTitle;\r\n\r\n          // Find the log by URL in the savedChatlogs array and update its title\r\n          const logIndex = savedChatlogs.findIndex(log => log.url === url);\r\n          if (logIndex !== -1) {\r\n            savedChatlogs[logIndex].title = newTitle; // Update the title in the saved object\r\n            localStorage.setItem('savedChatlogs', JSON.stringify(savedChatlogs)); // Save the updated list to localStorage\r\n          }\r\n        }\r\n      });\r\n\r\n      // Append the elements to the wrapper\r\n      logWrapper.appendChild(logLink);\r\n      logWrapper.appendChild(logTitle);\r\n\r\n      // Append the wrapper to the container\r\n      chatLogsLinksContainer.appendChild(logWrapper);\r\n    });\r\n  }\r\n\r\n  // Add a click event listener to copy chatLogsUrlForCopy to the clipboard\r\n  copyChatLogsUrl.addEventListener('click', (event) => {\r\n    let chatLogsLinksContainer = document.querySelector('.saved-chatlog-container');\r\n\r\n    !chatLogsLinksContainer && !event.shiftKey && addJumpEffect(copyChatLogsUrl, 0, 0);\r\n\r\n    if (chatLogsLinksContainer && !event.ctrlKey && !chatLogsLinksContainer.contains(event.target)) {\r\n      chatLogsLinksContainer.remove();\r\n    }\r\n\r\n    let savedChatlogs = JSON.parse(localStorage.getItem('savedChatlogs')) || [];\r\n\r\n    if (event.ctrlKey && !event.target.closest('.saved-chatlog-url')) {\r\n      const currentUrlDate = extractDateFromUrl(chatLogsUrlForCopy);\r\n      if (!currentUrlDate) return;\r\n\r\n      // Ask for title input\r\n      const title = prompt('Enter a title for this chat log:', '➕');\r\n\r\n      // Check if the URL with the same date already exists\r\n      const urlExists = savedChatlogs.some(log => extractDateFromUrl(log.url) === currentUrlDate);\r\n\r\n      if (!urlExists) {\r\n        // Add the new URL and title if no match was found for the date\r\n        savedChatlogs.push({ url: chatLogsUrlForCopy, title: title || '➕' });\r\n\r\n        // Sort the saved URLs based on the date extracted from the URL\r\n        savedChatlogs.sort((a, b) => {\r\n          const dateA = extractDateFromUrl(a.url);\r\n          const dateB = extractDateFromUrl(b.url);\r\n          return new Date(dateA) - new Date(dateB);\r\n        });\r\n\r\n        // Store the updated list back in localStorage\r\n        localStorage.setItem('savedChatlogs', JSON.stringify(savedChatlogs));\r\n      }\r\n      createChatLogLinks(savedChatlogs, chatLogsLinksContainer);\r\n    } else if (event.shiftKey) {\r\n      if (savedChatlogs.length > 0 && !chatLogsLinksContainer) {\r\n        chatLogsLinksContainer = document.createElement('div');\r\n        chatLogsLinksContainer.classList.add('saved-chatlog-container');\r\n        createChatLogLinks(savedChatlogs, chatLogsLinksContainer);\r\n\r\n        copyChatLogsUrl.appendChild(chatLogsLinksContainer);\r\n      }\r\n    } else {\r\n      navigator.clipboard.writeText(chatLogsUrlForCopy)\r\n        .catch(err => console.error('Failed to copy: ', err));\r\n    }\r\n  });\r\n\r\n  panelControlButtons.appendChild(copyChatLogsUrl);\r\n\r\n  // Retrieve `shouldShowActiveUsers` from localStorage or set it to 'shown' if it doesn't exist\r\n  const shouldShowActiveUsers = localStorage.getItem('shouldShowActiveUsers') || (localStorage.setItem('shouldShowActiveUsers', 'shown'), 'shown');\r\n\r\n  // Create a toggle active users button\r\n  const toggleActiveUsers = document.createElement('div');\r\n  toggleActiveUsers.className = \"large-button panel-header-toggle-button\";\r\n  updateActiveUsersToggle(shouldShowActiveUsers); // Set initial SVG based on stored state\r\n\r\n  // Set initial title based on stored state\r\n  toggleActiveUsers.title = shouldShowActiveUsers === 'shown' ? 'Hide User List' : 'Show User List';\r\n\r\n  // Function to update the toggle button's SVG and title based on current state\r\n  function updateActiveUsersToggle(state) {\r\n    toggleActiveUsers.innerHTML = state === 'shown' ? _icons__WEBPACK_IMPORTED_MODULE_2__.toggleLeftSVG : _icons__WEBPACK_IMPORTED_MODULE_2__.toggleRightSVG; // Toggle between SVGs\r\n    toggleActiveUsers.title = state === 'shown' ? 'Hide User List' : 'Show User List'; // Update title based on state\r\n  }\r\n\r\n  // Function to toggle active users and update localStorage, SVG, and title\r\n  function toggleActiveUsersState() {\r\n    const newState = localStorage.getItem('shouldShowActiveUsers') === 'shown' ? 'hidden' : 'shown'; // Determine new state\r\n    localStorage.setItem('shouldShowActiveUsers', newState); // Update localStorage\r\n    updateActiveUsersToggle(newState); // Update the displayed SVG and title\r\n\r\n    if (newState === 'shown') {\r\n      // Call renderActiveUsers to update the display of active users based on their message counts\r\n      renderActiveUsers(usernameMessageCountMap, chatLogsPanel);\r\n    } else {\r\n      // Remove the active users container if the state is hidden\r\n      const activeUsersContainer = chatLogsPanel.querySelector('.active-users');\r\n      if (activeUsersContainer) {\r\n        chatLogsPanel.removeChild(activeUsersContainer);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add click event to toggle active users\r\n  toggleActiveUsers.addEventListener('click', toggleActiveUsersState);\r\n\r\n  // Append the toggle active users to the panel control buttons\r\n  panelControlButtons.appendChild(toggleActiveUsers);\r\n\r\n  // Create and style the chevron left button\r\n  const oneDayBackward = document.createElement('div');\r\n  oneDayBackward.className = \"large-button panel-header-one-day-back-button\";\r\n  oneDayBackward.title = 'Previous Day';\r\n  oneDayBackward.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.chevronLeftSVG; // Assuming you have chevronLeftSVG defined\r\n  // applyHeaderButtonStyles(oneDayBackward, 'darkcyan');\r\n\r\n  // Create and style the chevron right button\r\n  const oneDayForward = document.createElement('div');\r\n  oneDayForward.className = \"large-button panel-header-one-day-forward-button\";\r\n  oneDayForward.title = 'Next Day';\r\n  oneDayForward.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.chevronRightSVG; // Assuming you have chevronRightSVG defined\r\n  // applyHeaderButtonStyles(oneDayForward, 'darkcyan');\r\n\r\n  // Create and style the shuffle button\r\n  const randomDay = document.createElement('div');\r\n  randomDay.className = \"large-button panel-header-shuffle-button\";\r\n  randomDay.title = 'Random Date';\r\n  randomDay.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.shuffleSVG; // Assuming you have shuffleSVG defined\r\n  // applyHeaderButtonStyles(randomDay, 'darkslateblue');\r\n\r\n  // Function to get current date or fallback to today's date\r\n  function getEffectiveDate() {\r\n    return dateInput.value ? new Date(dateInput.value) : new Date(); // Use dateInput value or today's date\r\n  }\r\n\r\n  // Function to update the date input and title\r\n  const updateDateInputAndTitle = (newDate) => {\r\n    dateInput.value = newDate; // Update the date input\r\n    dateInputToggle.title = `Current date: ${newDate}`; // Update title\r\n  };\r\n\r\n  // Event listener for the chevron left button\r\n  oneDayBackward.addEventListener('click', async () => {\r\n    const currentDate = getEffectiveDate(); // Get the effective date\r\n    currentDate.setDate(currentDate.getDate() - 1); // Go one day back\r\n    await loadChatLogs(currentDate); // Load chat logs for the updated date\r\n    showDateInput(dateInput);\r\n    focusOnSearchField();\r\n    resetVisibleMessages();\r\n  });\r\n\r\n  // Event listener for the chevron right button\r\n  oneDayForward.addEventListener('click', async () => {\r\n    const currentDate = getEffectiveDate(); // Get the effective date\r\n    currentDate.setDate(currentDate.getDate() + 1); // Go one day forward\r\n    await loadChatLogs(currentDate); // Load chat logs for the updated date\r\n    showDateInput(dateInput);\r\n    focusOnSearchField();\r\n    resetVisibleMessages();\r\n  });\r\n\r\n  // Event listener for the shuffle button\r\n  randomDay.addEventListener('click', async () => {\r\n    const randomDate = getRandomDateInRange(); // Get a random date\r\n    await loadChatLogs(randomDate); // Load chat logs for the random date\r\n    showDateInput(dateInput);\r\n    focusOnSearchField();\r\n    resetVisibleMessages();\r\n  });\r\n\r\n  // Append buttons to the control buttons container\r\n  panelControlButtons.appendChild(oneDayBackward);\r\n  panelControlButtons.appendChild(oneDayForward);\r\n  panelControlButtons.appendChild(randomDay);\r\n\r\n  // Create a close button with the provided SVG icon\r\n  const closePanelButton = document.createElement('div');\r\n  closePanelButton.className = \"large-button panel-header-close-button\";\r\n  closePanelButton.title = 'Close panel';\r\n  closePanelButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.closeSVG;\r\n\r\n  // Add a click event listener to the close panel button\r\n  closePanelButton.addEventListener('click', () => {\r\n    // Fade out the chat logs panel when the close button is clicked\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(chatLogsPanel, 'hide');\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n  });\r\n\r\n  // Append close button to control buttons, and control buttons to header\r\n  panelControlButtons.appendChild(closePanelButton);\r\n  panelHeaderContainer.appendChild(panelControlButtons);\r\n\r\n  // Create a container for the chat logs\r\n  const chatLogsContainer = document.createElement('div');\r\n  chatLogsContainer.className = 'chat-logs-container';\r\n\r\n  // Append the header and chat logs container to the chat logs panel\r\n  chatLogsPanel.appendChild(panelHeaderContainer);\r\n  chatLogsPanel.appendChild(chatLogsContainer);\r\n\r\n  // Create and append scroll buttons\r\n  const { scrollButtonsContainer } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.createScrollButtons)(chatLogsContainer);\r\n  chatLogsPanel.appendChild(scrollButtonsContainer);\r\n\r\n  // Append the chat logs panel to the body\r\n  document.body.appendChild(chatLogsPanel);\r\n\r\n  // Fade in the chat logs panel and dimming background\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(chatLogsPanel, 'show');\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('show');\r\n\r\n  // Define an object to store the hue for each username\r\n  const usernameHueMap = {};\r\n  const hueStep = 15;\r\n  let lastDisplayedUsername = null; // Variable to track the last displayed username\r\n  // Initialize a map to track message counts for unique usernames\r\n  const usernameMessageCountMap = new Map();\r\n  // Store the current chat logs URL for clipboard copy.\r\n  let chatLogsUrlForCopy = ''; // Store the current chat logs URL for copying\r\n\r\n  // Function to load the total message count into the placeholder without replacing the existing text\r\n  function loadTotalMessageCount() {\r\n    if (chatLogsContainer.childElementCount > 0) {\r\n      chatlogsSearchInput.placeholder += ` | Total messages: ${chatLogsContainer.childElementCount}`;\r\n    }\r\n  }\r\n\r\n  // Function to load and display chat logs into the container\r\n  const loadChatLogs = async (date) => {\r\n    // Normalize date input to 'yyyy-mm-dd' format, supporting 'yyyy:mm:dd' format as well\r\n    const normalizeDate = date => /^\\d{4}:\\d{2}:\\d{2}$/.test(date) ? date.replace(/:/g, '-') : date;\r\n    // Normalize and format the date\r\n    const formattedDate = new Intl.DateTimeFormat('en-CA').format(new Date(normalizeDate(date)));\r\n\r\n    // Check if the provided date is out of bounds (less than minDate or greater than today)\r\n    if (formattedDate < minDate || formattedDate > _definitions_js__WEBPACK_IMPORTED_MODULE_4__.today) {\r\n      alert(formattedDate < minDate ? `The selected date cannot be earlier than ${minDate}.` : \"You cannot load a future date.\");\r\n      return; // Exit the function if the date is invalid\r\n    }\r\n\r\n    // Call the updateDateInputAndTitle function with the formattedDate\r\n    updateDateInputAndTitle(formattedDate);\r\n\r\n    // Fetch chat logs and pass the chatLogsContainer as the parent container\r\n    const { chatlogs, url, size, info, error } = await fetchChatLogs(formattedDate, chatLogsContainer);\r\n\r\n    // Convert size to KB\r\n    const sizeInKB = (size / 1024).toFixed(2);\r\n\r\n    // Set placeholder for size in KB, info, or error\r\n    chatlogsSearchInput.placeholder = error ? `Error: ${error}` : (info ? `Limit reached: ${sizeInKB} KB` : info || `Size: ${sizeInKB} KB`);\r\n\r\n    // Assign the fetched URL to the chatLogsUrlForCopy variable\r\n    chatLogsUrlForCopy = url;\r\n\r\n    // Clear previous counts\r\n    usernameMessageCountMap.clear();\r\n\r\n    chatlogs.forEach(async ({ time, username, message }) => {\r\n      // Update message count for each unique username\r\n      usernameMessageCountMap.set(username, (usernameMessageCountMap.get(username) || 0) + 1);\r\n\r\n      // Create a container for each message\r\n      const messageContainer = document.createElement('div');\r\n      messageContainer.classList.add('message-item');\r\n\r\n      // Attach click event to scroll the chat logs container to the middle of the parent container on LMB click\r\n      messageContainer.addEventListener('click', async (event) => {\r\n        // If the clicked element or one of its parents is an anchor, exit early.\r\n        if (event.target.closest('a')) return;\r\n        // Call toggleMessagesVisibility to show all messages and scroll when a message is clicked on visibleMentionMessages is true\r\n        if (visibleMessages) await toggleMessagesVisibility();\r\n        chatlogsSearchInput.value.length > 0 && (chatlogsSearchInput.value = '');\r\n        // Use helper function to scroll the chat logs container to the middle of the parent container\r\n        await scrollMessagesToMiddle(chatLogsContainer, messageContainer);\r\n      });\r\n\r\n      // Create time element\r\n      const timeElement = document.createElement('span');\r\n      timeElement.className = 'message-time';\r\n      // Update the timeElement's text content with the adjusted time\r\n      timeElement.textContent = time;\r\n\r\n      // Open the chat log URL on click\r\n      timeElement.addEventListener('click', function () {\r\n        const url = `https://klavogonki.ru/chatlogs/${date}.html#${time}`;\r\n        window.open(url, '_blank', 'noopener,noreferrer');\r\n      });\r\n\r\n      // Create username element\r\n      const usernameElement = document.createElement('span');\r\n      usernameElement.className = 'message-username';\r\n      usernameElement.textContent = username; // Use the original username for display\r\n\r\n      // Add click event to navigate to the user's profile or shake the username if userId is not found\r\n      usernameElement.addEventListener('click', async () => {\r\n        const userId = await getUserId(username); // Fetch the user ID on click\r\n\r\n        if (userId) {\r\n          const url = `https://klavogonki.ru/u/#/${userId}/`;\r\n          window.open(url, '_blank', 'noopener,noreferrer');\r\n        } else {\r\n          // Add shake effect if userId doesn't exist\r\n          addShakeEffect(usernameElement); // Define this function for the shake effect\r\n        }\r\n      });\r\n\r\n      // Check if the hue for this username is already stored\r\n      let hueForUsername = usernameHueMap[username]; // Use the original username as the key\r\n\r\n      // If the hue is not stored, generate a new random hue with the specified step\r\n      if (!hueForUsername) {\r\n        hueForUsername = Math.floor(Math.random() * (210 / hueStep)) * hueStep; // Limit hue to a maximum of 210\r\n        // Store the generated hue for this username\r\n        usernameHueMap[username] = hueForUsername; // Store hue using the original username as the key\r\n      }\r\n\r\n      // Apply the hue color to the username element\r\n      usernameElement.style.color = `hsl(${hueForUsername}, 80%, 50%)`;\r\n\r\n      // Create message text element\r\n      const messageTextElement = document.createElement('span');\r\n      messageTextElement.className = 'message-text';\r\n\r\n      // Replace smiley codes with <img> tags, and then wrap links with <a> tags\r\n      messageTextElement.innerHTML = message\r\n        // Replace smiley codes like :word: with <img> tags\r\n        .replace(/:(?=\\w*[a-zA-Z])(\\w+):/g,\r\n          (_, word) => `<img src=\"/img/smilies/${word}.gif\" alt=\":${word}:\" title=\":${word}:\" class=\"smile\">`\r\n        )\r\n        // Wrap http and https links with <a> tags\r\n        .replace(/(https?:\\/\\/[^\\s]+)/gi,\r\n          (url) => `<a href=\"${url}\" target=\"_blank\" rel=\"noopener noreferrer\">${url}</a>`\r\n        );\r\n\r\n      // Apply margin for the first message of a new user\r\n      messageContainer.style.marginTop = lastDisplayedUsername !== username ? '0.6em' : '';\r\n\r\n      // Update the last displayed username\r\n      lastDisplayedUsername = username;\r\n\r\n      // Append elements to the message container\r\n      messageContainer.appendChild(timeElement);\r\n      messageContainer.appendChild(usernameElement);\r\n      messageContainer.appendChild(messageTextElement);\r\n\r\n      // Append the message container to the chat logs container\r\n      chatLogsContainer.appendChild(messageContainer);\r\n    });\r\n\r\n    // Call renderActiveUsers to update the display of active users based on their message counts\r\n    renderActiveUsers(usernameMessageCountMap, chatLogsPanel, chatlogsSearchInput);\r\n\r\n    requestAnimationFrame(() => {\r\n      (0,_image_converter_js__WEBPACK_IMPORTED_MODULE_0__.convertImageLinksToImage)('chatlogsMessages');\r\n      (0,_video_converter_js__WEBPACK_IMPORTED_MODULE_1__.convertVideoLinksToPlayer)('chatlogsMessages');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processEncodedLinks)('chatlogsMessages'); // Decodes links within the chat logs section.\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.highlightMentionWords)('chatlogsMessages');\r\n      chatLogsContainer.scrollTop = chatLogsContainer.scrollHeight; // Scroll to the very bottom\r\n\r\n      // Update the media and mention counters\r\n      updateMediaAndMentionCounters();\r\n      // Call the function to load the total message count once\r\n      loadTotalMessageCount();\r\n      // Call the filter function with the updated input value\r\n      chatlogsSearchInput.value.length > 0 && filterItems(chatlogsSearchInput.value);\r\n    });\r\n\r\n  };\r\n\r\n  // Renders the active users based on their message counts from the provided map\r\n  function renderActiveUsers(usernameMessageCountMap, parentContainer, searchField) {\r\n    // Check if active users should be shown\r\n    if (localStorage.getItem('shouldShowActiveUsers') === 'shown') {\r\n      // Check if the activeUsers container already exists\r\n      let activeUsers = parentContainer.querySelector('.active-users');\r\n\r\n      // If it doesn't exist, create it\r\n      if (!activeUsers) {\r\n        activeUsers = document.createElement('div');\r\n        activeUsers.className = 'active-users';\r\n\r\n        // Append the newly created activeUsers container to the parent container\r\n        parentContainer.appendChild(activeUsers);\r\n      }\r\n\r\n      // Sort usernames by message count in descending order\r\n      const sortedUsernames = Array.from(usernameMessageCountMap.entries())\r\n        .sort(([, countA], [, countB]) => countB - countA); // Sort in descending order\r\n\r\n      // Clear previous user list in the activeUsers container\r\n      activeUsers.innerHTML = ''; // Clear previous user list\r\n\r\n      // Append sorted users to the activeUsers container\r\n      sortedUsernames.forEach(([username, count]) => {\r\n        // Create a user element\r\n        const userElement = document.createElement('div');\r\n        userElement.className = 'active-user-item';\r\n\r\n        // Add click event to populate the search input with the clicked username\r\n        userElement.addEventListener('click', () => {\r\n          const currentValue = chatlogsSearchInput.value.trim();\r\n          const usernameEntry = isCtrlKeyPressed ? `, ${username}` : username;\r\n\r\n          // Toggle input value: clear if same username clicked, otherwise add or replace\r\n          chatlogsSearchInput.value = (currentValue === username)\r\n            ? ''\r\n            : (isCtrlKeyPressed && !currentValue.includes(username))\r\n              ? currentValue + usernameEntry\r\n              : username;\r\n\r\n          // Call the filter function with the updated input value\r\n          filterItems(chatlogsSearchInput.value);\r\n        });\r\n\r\n        // Create nickname element\r\n        const nicknameElement = document.createElement('span');\r\n        nicknameElement.className = 'active-user-name';\r\n        nicknameElement.textContent = username;\r\n\r\n        // Fetch the color for the username from the hue map\r\n        const userHue = usernameHueMap[username] || 0; // Fallback to 0 if hue not found\r\n        nicknameElement.style.color = `hsl(${userHue}, 80%, 50%)`; // Apply the hue color\r\n\r\n        // Create message count element\r\n        const messageCountElement = document.createElement('span');\r\n        messageCountElement.className = 'active-user-messages-count';\r\n        messageCountElement.textContent = count;\r\n        messageCountElement.style.color = `hsl(${userHue}, 80%, 50%)`; // Apply the hue color\r\n        messageCountElement.style.backgroundColor = `hsla(${userHue}, 80%, 50%, 0.2)`;\r\n\r\n        // Append elements to user element\r\n        userElement.appendChild(messageCountElement);\r\n        userElement.appendChild(nicknameElement);\r\n\r\n        // Append user element to activeUsers container\r\n        activeUsers.appendChild(userElement);\r\n      });\r\n    }\r\n  }\r\n\r\n  // Load chat logs based on the provided date or default to today's date\r\n  const dateToLoad = personalMessagesDate || _definitions_js__WEBPACK_IMPORTED_MODULE_4__.today; // Use personalMessagesDate if available\r\n  await loadChatLogs(dateToLoad); // Load chat logs for the determined date\r\n  // Check if personalMessagesDate is given as parameter or null to show the date input field\r\n  if (personalMessagesDate) showDateInput(dateInput); // Show the date input field\r\n\r\n  // Set the max attribute to today's date\r\n  dateInput.max = _definitions_js__WEBPACK_IMPORTED_MODULE_4__.today; // Set the maximum value to today's date\r\n  // Set the min attribute to '2012-02-12'\r\n  dateInput.min = minDate; // Assign the minimum date\r\n  dateInput.value = dateToLoad; // Set the value to the date to load\r\n  dateInputToggle.title = `Current date: ${dateToLoad}`; // Update the title with the selected date\r\n\r\n  // Add an event listener for the date input change\r\n  dateInput.addEventListener('change', async (event) => {\r\n    const selectedDate = event.target.value; // Get the selected date\r\n    await loadChatLogs(selectedDate); // Load chat logs for the selected date\r\n    dateInputToggle.title = `Current date: ${selectedDate}`; // Update the title with the selected date\r\n  });\r\n\r\n  // Retrieves details from message items including usernames and message text.\r\n  function getMessageDetails(messageItems) {\r\n    // Cache message details including text, username, and message content\r\n    return messageItems.map(item => {\r\n      const usernameElement = item.querySelector('.message-username');\r\n      const username = usernameElement ? usernameElement.textContent.toLowerCase().trim() : ''; // Get username text, if available\r\n      const messageTextElement = item.querySelector('.message-text');\r\n      const messageText = messageTextElement ? messageTextElement.textContent.toLowerCase().trim() : ''; // Get message text, if available\r\n      return { username, messageText };\r\n    });\r\n  }\r\n\r\n  // Filters message items based on the provided query and displays matching messages.\r\n  function filterItems(query) {\r\n    // If the query contains only digits, hyphens, or colons, do nothing\r\n    if (/^[\\d-:]+$/.test(query.trim())) return;\r\n\r\n    // Helper function to replace underscores and hyphens with spaces and convert to lowercase\r\n    function normalizeText(text) {\r\n      return text.replace(/[_-]/g, ' ').toLowerCase(); // Replaces _ and - with spaces\r\n    }\r\n\r\n    // Normalize query by removing underscores and hyphens, then trimming spaces\r\n    const queryWithoutSymbols = normalizeText(query).trim();\r\n\r\n    // Retrieve message items within the filterItems function\r\n    const messageItems = Array.from(document.querySelectorAll('.chat-logs-container > .message-item'));\r\n\r\n    const messageDetails = getMessageDetails(messageItems); // Get the message details\r\n    const isEmptyQuery = !queryWithoutSymbols;\r\n\r\n    // Split query by commas and trim parts\r\n    const queryParts = queryWithoutSymbols.split(',').map(part => part.trim()).filter(Boolean);\r\n\r\n    // Count matching usernames\r\n    const matchingUsernamesCount = queryParts.filter(part =>\r\n      messageDetails.some(detail => normalizeText(detail.username) === part)\r\n    ).length;\r\n\r\n    // Determine if User Mode is active (2 or more matching usernames)\r\n    const isUserMode = matchingUsernamesCount >= 2;\r\n\r\n    // Filter message items based on the query\r\n    messageItems.forEach((item, index) => {\r\n      const messageContainer = item.closest('.message-item'); // Get the closest message item container\r\n      const messageDetailsItem = messageDetails[index];\r\n\r\n      let shouldDisplay = false;\r\n\r\n      // Normalize underscores and hyphens in the username and message text\r\n      const normalizedUsername = normalizeText(messageDetailsItem.username);\r\n      const normalizedMessageText = normalizeText(messageDetailsItem.messageText);\r\n\r\n      if (isEmptyQuery) {\r\n        // Display all messages if the query is empty\r\n        shouldDisplay = true;\r\n      } else if (isUserMode) {\r\n        // User Mode: Match only by username\r\n        shouldDisplay = queryParts.some(part => normalizedUsername === part);\r\n      } else {\r\n        // Simple Mode: Treat the entire query (including commas) as part of the text search\r\n        shouldDisplay = normalizedUsername.includes(queryWithoutSymbols) ||\r\n          normalizedMessageText.includes(queryWithoutSymbols);\r\n      }\r\n\r\n      // Toggle visibility based on shouldDisplay using content visibility and font size\r\n      messageContainer.style.contentVisibility = shouldDisplay ? 'visible' : 'hidden';\r\n      // Set font size to 0 for hidden messages to maintain layout or remove the font size property\r\n      messageContainer.style.fontSize = shouldDisplay ? '' : '0';\r\n    });\r\n  }\r\n\r\n  // Define the event handler function for chat logs panel\r\n  panelsEvents.handleChatLogsKeydown = (event) => { // Assign the function to the object\r\n    if (event.key === 'Escape') {\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(chatLogsPanel, 'hide');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n      document.removeEventListener('keydown', panelsEvents.handleChatLogsKeydown); // Remove the event listener\r\n    }\r\n  };\r\n\r\n  // Attach the event listener\r\n  document.addEventListener('keydown', panelsEvents.handleChatLogsKeydown);\r\n}\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/chatlogs.js?");

/***/ }),

/***/ "./src/modules/definitions.js":
/*!************************************!*\
  !*** ./src/modules/definitions.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheRefreshThresholdHours: () => (/* binding */ cacheRefreshThresholdHours),\n/* harmony export */   debounceTimeout: () => (/* binding */ debounceTimeout),\n/* harmony export */   dynamicChatNotificationTimeout: () => (/* binding */ dynamicChatNotificationTimeout),\n/* harmony export */   emojiFaces: () => (/* binding */ emojiFaces),\n/* harmony export */   ignored: () => (/* binding */ ignored),\n/* harmony export */   mentionKeywords: () => (/* binding */ mentionKeywords),\n/* harmony export */   moderator: () => (/* binding */ moderator),\n/* harmony export */   myNickname: () => (/* binding */ myNickname),\n/* harmony export */   myUserId: () => (/* binding */ myUserId),\n/* harmony export */   profileBaseUrl: () => (/* binding */ profileBaseUrl),\n/* harmony export */   state: () => (/* binding */ state),\n/* harmony export */   today: () => (/* binding */ today),\n/* harmony export */   toggle: () => (/* binding */ toggle),\n/* harmony export */   trustedDomains: () => (/* binding */ trustedDomains),\n/* harmony export */   usernameReplacements: () => (/* binding */ usernameReplacements),\n/* harmony export */   usersToTrack: () => (/* binding */ usersToTrack)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/modules/helpers.js\");\n// helpers\r\n\r\n\r\nconst debounceTimeout = 300;\r\n\r\n// Define the base URL for user profiles\r\nconst profileBaseUrl = 'https://klavogonki.ru/u/#/';\r\n// Actual nickname to use it as an exclusion for the message beep and voice notifications\r\nconst myNickname = document.querySelector('.userpanel .user-block .user-dropdown .name span').textContent;\r\n// Extract the user ID from the href attribute of the mail link for chat, direct profile, or messaging navigation\r\nconst myUserId = document.querySelector('a.drop-btn.mail')?.href?.match(/\\/u\\/#\\/(\\d+)\\/messages\\//)?.[1];\r\n// create today's date in the format 'YYYY-MM-DD'\r\nconst today = new Intl.DateTimeFormat('en-CA').format(new Date());\r\n\r\n// Define the users to track and notify with popup and audio\r\nlet usersToTrack = [\r\n  { name: 'Даниэль', gender: 'Male', pronunciation: 'Даниэль', state: 'thawed' }\r\n];\r\n\r\n// Notify if someone addresses me using these aliases (case-insensitive)\r\nlet mentionKeywords = [];\r\n\r\n// Define username replacements for pronunciation\r\nlet usernameReplacements = [];\r\n\r\n// Define a list of moderator whose new user nicknames in the chat list should have a shield icon.\r\nlet moderator = [];\r\n\r\n// Define user list of users whose messages should be hidden\r\nlet ignored = [];\r\n\r\n// Define empty array for the toggle settings\r\nlet toggle = [];\r\n\r\nconst emojiFaces = [\r\n  // People Emojis (Facial expressions)\r\n  '😀', '😁', '😂', '🤣', '😃', '😄', '😅', '😆',\r\n  '😉', '😊', '😋', '😎', '😏', '😐', '😑', '😒',\r\n  '😓', '😔', '😕', '😖', '😗', '😘', '😙', '😚',\r\n  '😜', '😝', '😛', '🤑', '🤗', '🤔', '🤐', '🤨',\r\n  '😣', '😥', '😮', '🤯', '😳', '😱', '😨', '😰',\r\n  '😢', '🤪', '😵', '😲', '🤤', '😷', '🤒', '🤕',\r\n  '🤢', '🤧', '😇', '🥳', '🥺', '😬', '😴', '😌',\r\n  '🤥', '🥴', '🥵', '🥶', '🤧', '🤭', '🤫', '😠',\r\n  '😡', '😳', '😞', '😟', '😕',\r\n\r\n  // Cat Emojis (Expressive faces of cats)\r\n  '🐱', '😺', '😸', '😹', '😻', '😼', '😽', '🙀', '😿', '😾',\r\n\r\n  // Other Animal Emojis (Various animals' faces)\r\n  '🐶', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼',\r\n  '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐵',\r\n  '🙈', '🙉', '🙊', '🐔', '🦄'\r\n];\r\n\r\nconst state = {\r\n  // Variable to store the last selected emoji\r\n  lastEmojiAvatar: null,\r\n  // Tracks the last focused textarea within the iframe to manage input interactions\r\n  lastFocusedIframeTextarea: null,\r\n  // Object to store event handlers for big image\r\n  bigImageEvents: {},\r\n  // Define an object to store event handlers\r\n  panelsEvents: {},\r\n  fetchedUsers: JSON.parse(localStorage.getItem('fetchedUsers')) || {}\r\n}\r\n\r\n// Timeout before the dynamicChatNotification should be removed\r\nconst dynamicChatNotificationTimeout = 5000;\r\n\r\nconst defaultCacheRefreshThresholdHours = 24;\r\nconst cacheRefreshThresholdHours = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.convertToSingleHours)(\r\n  localStorage.getItem('cacheRefreshThresholdHours') ||\r\n  (localStorage.setItem('cacheRefreshThresholdHours', defaultCacheRefreshThresholdHours), defaultCacheRefreshThresholdHours)\r\n);\r\n\r\n// List of trusted domains\r\nconst trustedDomains = [\r\n  'klavogonki.ru',\r\n  'youtube.com', // youtube main\r\n  'youtu.be', // youtube share\r\n  'imgur.com',\r\n  'pikabu.ru',\r\n  'userapi.com', // vk.com\r\n  'ibb.co', // imgbb.com\r\n  'yaplakal.com',\r\n  'freepik.com'\r\n];\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/definitions.js?");

/***/ }),

/***/ "./src/modules/helpers.js":
/*!********************************!*\
  !*** ./src/modules/helpers.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addBigImageEventListeners: () => (/* binding */ addBigImageEventListeners),\n/* harmony export */   addPulseEffect: () => (/* binding */ addPulseEffect),\n/* harmony export */   adjustVisibility: () => (/* binding */ adjustVisibility),\n/* harmony export */   convertToSingleHours: () => (/* binding */ convertToSingleHours),\n/* harmony export */   createScrollButtons: () => (/* binding */ createScrollButtons),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   decodeURL: () => (/* binding */ decodeURL),\n/* harmony export */   fetchJSON: () => (/* binding */ fetchJSON),\n/* harmony export */   getCurrentTimeFormatted: () => (/* binding */ getCurrentTimeFormatted),\n/* harmony export */   getExactUserIdByName: () => (/* binding */ getExactUserIdByName),\n/* harmony export */   getRandomEmojiAvatar: () => (/* binding */ getRandomEmojiAvatar),\n/* harmony export */   getUserChatDuration: () => (/* binding */ getUserChatDuration),\n/* harmony export */   getUserIDsByName: () => (/* binding */ getUserIDsByName),\n/* harmony export */   getUserProfileData: () => (/* binding */ getUserProfileData),\n/* harmony export */   highlightMentionWords: () => (/* binding */ highlightMentionWords),\n/* harmony export */   isAltKeyPressed: () => (/* binding */ isAltKeyPressed),\n/* harmony export */   isCtrlKeyPressed: () => (/* binding */ isCtrlKeyPressed),\n/* harmony export */   isTrustedDomain: () => (/* binding */ isTrustedDomain),\n/* harmony export */   isValidEncodedURL: () => (/* binding */ isValidEncodedURL),\n/* harmony export */   loadProfileIntoIframe: () => (/* binding */ loadProfileIntoIframe),\n/* harmony export */   processEncodedLinks: () => (/* binding */ processEncodedLinks),\n/* harmony export */   refreshFetchedUsers: () => (/* binding */ refreshFetchedUsers),\n/* harmony export */   removeAllPanelEventListeners: () => (/* binding */ removeAllPanelEventListeners),\n/* harmony export */   removeBigImageEventListeners: () => (/* binding */ removeBigImageEventListeners),\n/* harmony export */   removePreviousPanel: () => (/* binding */ removePreviousPanel),\n/* harmony export */   scrollMessagesToBottom: () => (/* binding */ scrollMessagesToBottom),\n/* harmony export */   scrollMessagesToMiddle: () => (/* binding */ scrollMessagesToMiddle),\n/* harmony export */   shouldEnableSetting: () => (/* binding */ shouldEnableSetting),\n/* harmony export */   triggerDimmingElement: () => (/* binding */ triggerDimmingElement),\n/* harmony export */   triggerTargetElement: () => (/* binding */ triggerTargetElement),\n/* harmony export */   updatePersonalMessageCounts: () => (/* binding */ updatePersonalMessageCounts),\n/* harmony export */   updateScrollButtonOpacity: () => (/* binding */ updateScrollButtonOpacity),\n/* harmony export */   updateScrollButtonsVisibility: () => (/* binding */ updateScrollButtonsVisibility)\n/* harmony export */ });\n/* harmony import */ var _icons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icons.js */ \"./src/modules/icons.js\");\n/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definitions.js */ \"./src/modules/definitions.js\");\n// icons\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Define dynamic variables\r\nlet {\r\n  panelsEvents,\r\n  bigImageEvents,\r\n  lastFocusedIframeTextarea,\r\n  lastEmojiAvatar\r\n} = _definitions_js__WEBPACK_IMPORTED_MODULE_1__.state;\r\n\r\n// Initialize global variables to track the state of Ctrl and Alt keys\r\nlet isCtrlKeyPressed = false, isAltKeyPressed = false;\r\n// Helper function to update key states\r\nconst setKeyState = (key, value) => {\r\n  if (key === 'Control') isCtrlKeyPressed = value;\r\n  if (key === 'Alt') isAltKeyPressed = value;\r\n};\r\n\r\n// Listen for keydown and keyup events\r\n['keydown', 'keyup'].forEach(eventType =>\r\n  document.addEventListener(eventType, event => setKeyState(event.key, eventType === 'keydown'))\r\n);\r\n\r\n// Reset key states when focus or blur events occur\r\n['blur', 'focus'].forEach(eventType =>\r\n  document.addEventListener(eventType, () => {\r\n    if (isCtrlKeyPressed || isAltKeyPressed) {\r\n      console.log(`${isCtrlKeyPressed ? 'Ctrl ' : ''}${isAltKeyPressed ? 'Alt ' : ''}key was true`);\r\n      isCtrlKeyPressed = false;\r\n      isAltKeyPressed = false;\r\n    }\r\n  })\r\n);\r\n\r\nfunction addPulseEffect(element) {\r\n  element.classList.add('pulse-effect');\r\n  setTimeout(() => {\r\n    element.classList.remove('pulse-effect');\r\n  }, 500);\r\n}\r\n\r\n// Function to remove all event listeners from the panel\r\nfunction removeAllPanelEventListeners() {\r\n  Object.values(panelsEvents).forEach((handler) => {\r\n    document.removeEventListener('keydown', handler);\r\n  });\r\n\r\n  // Remove all keys without reassigning the object\r\n  Object.keys(panelsEvents).forEach((key) => delete panelsEvents[key]);\r\n}\r\n\r\nfunction addBigImageEventListeners() {\r\n  Object.entries(bigImageEvents).forEach(([event, handler]) => {\r\n    document.addEventListener(event, handler);\r\n  })\r\n}\r\n\r\nfunction removeBigImageEventListeners() {\r\n  Object.entries(bigImageEvents).forEach(([event, handler]) => {\r\n    document.removeEventListener(event, handler);\r\n  })\r\n}\r\n\r\n// Function to remove the previous panel if it exists\r\nfunction removePreviousPanel() {\r\n  removeAllPanelEventListeners();\r\n  const existingPanel = document.querySelector('.popup-panel');\r\n  if (existingPanel) existingPanel.remove();\r\n}\r\n\r\n// Function to update button opacity\r\nfunction updateScrollButtonOpacity({ container, buttons }) {\r\n  const tolerance = 3,\r\n    isAtTop = container.scrollTop === 0,\r\n    isAtBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - tolerance;\r\n\r\n  [buttons.fullScrollUpButton, buttons.partialScrollUpButton].forEach(button => {\r\n    button.style.opacity = isAtTop ? '0.3' : '1';\r\n    button.style.pointerEvents = isAtTop ? 'none' : 'auto';\r\n  });\r\n\r\n  [buttons.fullScrollDownButton, buttons.partialScrollDownButton].forEach(button => {\r\n    button.style.opacity = isAtBottom ? '0.3' : '1';\r\n    button.style.pointerEvents = isAtBottom ? 'none' : 'auto';\r\n  });\r\n}\r\n\r\n// Function to update the visibility of the scroll buttons container\r\nfunction updateScrollButtonsVisibility({ container, scrollButtonsContainer }) {\r\n  if (container.scrollHeight > container.clientHeight) {\r\n    scrollButtonsContainer.style.display = 'flex';\r\n  } else {\r\n    scrollButtonsContainer.style.display = 'none';\r\n  }\r\n}\r\n\r\n// Function to create scroll buttons for a container\r\nfunction createScrollButtons(container) {\r\n  const scrollButtonsContainer = document.createElement('div');\r\n  scrollButtonsContainer.className = 'scroll-buttons-container';\r\n\r\n  const fullScrollUpButton = document.createElement('div');\r\n  fullScrollUpButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.chevronsUpSVG;\r\n  fullScrollUpButton.title = 'Scroll Up (Full)';\r\n\r\n  const partialScrollUpButton = document.createElement('div');\r\n  partialScrollUpButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.chevronUpSVG;\r\n  partialScrollUpButton.title = 'Scroll Up (Partial)';\r\n\r\n  const partialScrollDownButton = document.createElement('div');\r\n  partialScrollDownButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.chevronDownSVG;\r\n  partialScrollDownButton.title = 'Scroll Down (Partial)';\r\n\r\n  const fullScrollDownButton = document.createElement('div');\r\n  fullScrollDownButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.chevronsDownSVG;\r\n  fullScrollDownButton.title = 'Scroll Down (Full)';\r\n\r\n  const buttons = {\r\n    fullScrollUpButton,\r\n    partialScrollUpButton,\r\n    partialScrollDownButton,\r\n    fullScrollDownButton\r\n  };\r\n\r\n  Object.values(buttons).forEach(button => {\r\n    button.classList.add(\"large-button\", \"scroll-button\");\r\n    scrollButtonsContainer.appendChild(button);\r\n  });\r\n\r\n  function scrollContainer(direction, isFullScroll) {\r\n    const scrollAmount = isFullScroll ? container.scrollHeight : container.clientHeight;\r\n    container.scrollBy({\r\n      top: direction === 'up' ? -scrollAmount : scrollAmount,\r\n      behavior: 'smooth'\r\n    });\r\n    updateScrollButtonOpacity({ container, buttons });\r\n  }\r\n\r\n  fullScrollUpButton.addEventListener('click', () => scrollContainer('up', true));\r\n  partialScrollUpButton.addEventListener('click', () => scrollContainer('up', false));\r\n  partialScrollDownButton.addEventListener('click', () => scrollContainer('down', false));\r\n  fullScrollDownButton.addEventListener('click', () => scrollContainer('down', true));\r\n\r\n  updateScrollButtonOpacity({ container, buttons });\r\n  updateScrollButtonsVisibility({ container, scrollButtonsContainer });\r\n\r\n  container.addEventListener('scroll', () => {\r\n    updateScrollButtonOpacity({ container, buttons });\r\n    updateScrollButtonsVisibility({ container, scrollButtonsContainer });\r\n  });\r\n\r\n  return { scrollButtonsContainer };\r\n}\r\n\r\nconst debounce = (func, delay = 300) => {\r\n  let timeoutId;\r\n  return function (...args) {\r\n    clearTimeout(timeoutId);\r\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\r\n  };\r\n};\r\n\r\n// Adjust element visibility with smooth opacity transition\r\nfunction adjustVisibility(element, action, opacity) {\r\n  if (!element) return; // Exit if element doesn't exist\r\n\r\n  // Force reflow to ensure initial state is recognized\r\n  void element.offsetHeight;\r\n\r\n  element.style.transition = 'opacity 0.3s'; // Apply smooth transition for both show and hide\r\n  element.style.opacity = action === 'show' ? opacity : '0'; // Set target opacity\r\n\r\n  // If hiding, wait for transition to finish before removing the element\r\n  if (action === 'hide') {\r\n    element.addEventListener('transitionend', () => {\r\n      if (element.style.opacity === '0') element.remove(); // Remove only when opacity reaches 0\r\n    }, { once: true }); // Ensure the event runs only once\r\n  }\r\n}\r\n\r\n// Function to create and fade the dimming element\r\nfunction triggerDimmingElement(action) {\r\n  // Check if the dimming element already exists\r\n  let dimming = document.querySelector('.dimming-background');\r\n  // Check if the scaled thumbnail already exists\r\n  let scaledThumbnail = document.querySelector('.scaled-thumbnail');\r\n\r\n  // If the action is 'hide' and the dimming element doesn't exist, return\r\n  if (action === 'hide' && !dimming) return;\r\n\r\n  // Create the dimming element only if it doesn't exist\r\n  if (!dimming) {\r\n    dimming = document.createElement('div');\r\n    dimming.classList.add('dimming-background');\r\n\r\n    // Append the dimming element to the body\r\n    document.body.appendChild(dimming);\r\n\r\n    // Add click event listener to remove the dimming element and the upper element\r\n    dimming.addEventListener('click', function () {\r\n      // First, check for .popup-panel, then check for previousElementSibling\r\n      const elementToRemove = document.querySelector('.popup-panel') || dimming.previousElementSibling;\r\n      if (elementToRemove) adjustVisibility(elementToRemove, 'hide', 0); // Fade out and remove element\r\n      triggerDimmingElement('hide');\r\n      if (scaledThumbnail) removeBigImageEventListeners(); // Remove all bigImage event listeners\r\n    });\r\n  }\r\n\r\n  // Adjust the visibility of an element with a dimming effect, setting opacity to 0.5\r\n  adjustVisibility(dimming, action, 0.5);\r\n\r\n  // If the action is 'hide', check for and remove the .scaled-thumbnail using triggerTargetElement\r\n  if (action === 'hide') {\r\n    if (scaledThumbnail) {\r\n      removeBigImageEventListeners(); // Remove all bigImage event listeners\r\n      triggerTargetElement(scaledThumbnail, 'hide'); // Use triggerTargetElement to fade out and remove the scaled-thumbnail\r\n    }\r\n  }\r\n}\r\n\r\n// Function to gradually fade a target element to show or hide it\r\nfunction triggerTargetElement(element, action) {\r\n  if (!element) return; // Return if the element does not exist\r\n\r\n  // Adjust the visibility of a specific element, setting opacity to 1 (fully visible)\r\n  adjustVisibility(element, action, 1);\r\n\r\n  // Add a double click event listener to hide the element\r\n  element.addEventListener('dblclick', (event) => {\r\n    // Check if any panel is open\r\n    const isPanelOpen = document.querySelector('.popup-panel');\r\n    // If any panel is open and the double-clicked target is the scaled image, do not hide the dimming element\r\n    if (!isPanelOpen || !event.target.closest('.scaled-thumbnail')) {\r\n      triggerDimmingElement('hide'); // Hide the dimming element on double click, unless the target is a scaled image and a panel is open\r\n    }\r\n\r\n    triggerTargetElement(element, 'hide'); // Always hide the target element on double click\r\n  });\r\n}\r\n\r\n// Function to check if a URL is valid and contains encoded characters\r\nfunction isValidEncodedURL(url) {\r\n  const urlPattern = /^https?:\\/\\//; // Regex pattern to check if the value is a URL\r\n  const encodedPattern = /%[0-9A-Fa-f]{2}/; // Regex pattern to check if the URL is encoded\r\n  return urlPattern.test(url) && encodedPattern.test(url);\r\n}\r\n\r\n// Function to decode a URL and replace spaces with underscores\r\nfunction decodeURL(url) {\r\n  const [base] = url.split('#'); // Split at the '#' symbol and take the base part\r\n  return decodeURIComponent(base).replace(/ /g, '_'); // Decode and replace spaces with underscores\r\n}\r\n\r\nfunction processEncodedLinks(type) {\r\n  // Select the appropriate container based on the 'type' parameter\r\n  document.querySelector(({\r\n    generalMessages: \".messages-content div\", // General messages container\r\n    chatlogsMessages: \".chat-logs-container\", // Chat logs container\r\n    personalMessages: \".messages-container-wrapper\" // Personal messages container\r\n  })[type])?.querySelectorAll('a:not(.media):not(.decoded)').forEach(link => { // Select all <a> links that haven't been decoded yet\r\n    try {\r\n      // Ensure the link is a valid encoded URL before decoding\r\n      if (isValidEncodedURL(link.href)) {\r\n        let decoded = decodeURL(link.href); // Decode the URL\r\n        link.href = link.textContent = decoded; // Set the decoded URL as both the link href and text content\r\n        link.classList.add('decoded'); // Mark the link as decoded by adding the 'decoded' class\r\n      }\r\n    } catch (error) {\r\n      // If an error occurs during the decoding process, log the error and the link's href\r\n      console.error('Error decoding link:', error, link.href); // Log error and link.href for debugging\r\n    }\r\n  });\r\n}\r\n\r\n// Creates and manages an iframe modal for profile content\r\nconst loadProfileIntoIframe = (url) => {\r\n  // Create iframe element and configure basic attributes\r\n  const profileIframe = document.createElement('iframe');\r\n  profileIframe.classList.add('profile-iframe-container');\r\n  profileIframe.src = url;\r\n\r\n  document.body.appendChild(profileIframe);\r\n  adjustVisibility(profileIframe, 'show', 1);\r\n\r\n  // Cleanup function for removing the iframe and event listeners\r\n  const removeIframe = () => {\r\n    adjustVisibility(profileIframe, 'hide', 0);\r\n    document.removeEventListener('keydown', handleEvents);\r\n    document.removeEventListener('mousedown', handleEvents);\r\n  };\r\n\r\n  // Unified event handler for closure interactions\r\n  const handleEvents = (event) => {\r\n    // Spacebar handling: prevent default closure when textarea is focused\r\n    if (event.type === 'keydown' && event.code === 'Space') {\r\n      if (lastFocusedIframeTextarea) {\r\n        event.stopPropagation();\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n      removeIframe();\r\n    }\r\n    // Close iframe when clicking outside\r\n    if (event.type === 'mousedown' && !profileIframe.contains(event.target)) {\r\n      removeIframe();\r\n    }\r\n  };\r\n\r\n  // Attach global event listeners for closure triggers\r\n  document.addEventListener('keydown', handleEvents);\r\n  document.addEventListener('mousedown', handleEvents);\r\n\r\n  // Configure iframe content interactions after load\r\n  profileIframe.onload = () => {\r\n    try {\r\n      const iframeWindow = profileIframe.contentWindow;\r\n      const iframeDoc = iframeWindow.document;\r\n\r\n      // Track focused textareas within iframe\r\n      iframeDoc.addEventListener('focusin', (e) => {\r\n        if (e.target.tagName === 'TEXTAREA') {\r\n          lastFocusedIframeTextarea = e.target;\r\n        }\r\n      });\r\n\r\n      // Clear textarea focus tracking when leaving input\r\n      iframeDoc.addEventListener('focusout', () => {\r\n        setTimeout(() => {  // Delay to check new active element\r\n          if (!iframeDoc.activeElement || iframeDoc.activeElement.tagName !== 'TEXTAREA') {\r\n            lastFocusedIframeTextarea = null;\r\n          }\r\n        }, 0);\r\n      });\r\n\r\n      // Attach internal iframe closure triggers\r\n      iframeWindow.addEventListener('keydown', handleEvents);\r\n      iframeWindow.addEventListener('dblclick', removeIframe);\r\n\r\n      // Monitor DOM changes for automatic closure conditions\r\n      new MutationObserver((mutations, observer) => {\r\n        // Close iframe when specific UI elements are removed\r\n        if (mutations.some(m => [...m.removedNodes].some(n =>\r\n          n.nodeType === 1 && (n.classList.contains('dimming-background') || n.classList.contains('cached-users-panel'))\r\n        ))) {\r\n          removeIframe();\r\n          observer.disconnect();\r\n        }\r\n      }).observe(document.body, { childList: true, subtree: true });\r\n\r\n    } catch (error) {\r\n      // Handle cross-origin policy restrictions\r\n      console.warn(\"Unable to access iframe contents:\", error);\r\n    }\r\n  };\r\n};\r\n\r\n// Helper function to get a random emoji avatar\r\nfunction getRandomEmojiAvatar() {\r\n  let newEmoji;\r\n  do {\r\n    newEmoji = _definitions_js__WEBPACK_IMPORTED_MODULE_1__.emojiFaces[Math.floor(Math.random() * _definitions_js__WEBPACK_IMPORTED_MODULE_1__.emojiFaces.length)];\r\n  } while (newEmoji === lastEmojiAvatar);\r\n\r\n  lastEmojiAvatar = newEmoji;\r\n  return newEmoji;\r\n}\r\n\r\n// Helper to fetch JSON and validate response\r\nasync function fetchJSON(url) {\r\n  const response = await fetch(url);\r\n  if (!response.ok) throw new Error(`Failed to fetch ${url}`);\r\n  return response.json();\r\n}\r\n\r\n// Helper function to get Exact user ID by username via the search API\r\nasync function getExactUserIdByName(userName) {\r\n  // Define the search API URL\r\n  const searchApiUrl = `https://klavogonki.ru/api/profile/search-users?query=${userName}`;\r\n\r\n  // Get search results from the API\r\n  const searchResults = await fetchJSON(searchApiUrl);\r\n\r\n  // Ensure search results exist and contain data\r\n  if (!searchResults.all?.length) throw new Error(`User ${userName} not found.`);\r\n\r\n  // Return the ID of the user with the exact matching login\r\n  const user = searchResults.all.find(user => user.login === userName);\r\n  if (!user) throw new Error(`Exact match for user ${userName} not found.`);\r\n\r\n  return user.id;\r\n}\r\n\r\n// Helper function to get all user IDs by username via the search API\r\nasync function getUserIDsByName(userName) {\r\n  const searchApiUrl = `https://klavogonki.ru/api/profile/search-users?query=${userName}`;\r\n  const searchResults = await fetchJSON(searchApiUrl);\r\n\r\n  const foundUsers = searchResults.all; // Get all search results\r\n  if (!foundUsers || foundUsers.length === 0) throw new Error(`User ${userName} not found.`);\r\n\r\n  // Return an array of user IDs\r\n  return foundUsers.map(user => user.id);\r\n}\r\n\r\n// Function to validate required user data\r\nfunction validateUserData(user) {\r\n  const requiredFields = ['rank', 'login', 'registered', 'bestSpeed', 'ratingLevel', 'friends', 'cars', 'avatarTimestamp'];\r\n  return user && typeof user === 'object' && requiredFields.every(field => user?.[field] !== undefined);\r\n}\r\n\r\n// Function to convert seconds to a human-readable date format\r\nfunction convertSecondsToDate(seconds) {\r\n  const date = new Date(seconds * 1000);\r\n  return date.toISOString().slice(0, 19).replace('T', ' '); // Converts to 'YYYY-MM-DD HH:mm:ss' format\r\n}\r\n\r\n// Function to convert sec and usec to the 'updated' timestamp\r\nfunction convertToUpdatedTimestamp(sec, usec) {\r\n  // Create the full timestamp by combining sec and usec (in microseconds)\r\n  return sec.toString() + Math.floor(usec / 1000).toString();\r\n}\r\n\r\n// Function to get profile summary and registration data\r\nasync function getUserProfileData(userId, useLocalStorage = true) {\r\n  return new Promise(async (resolve, reject) => {\r\n    let cachedUserInfo = useLocalStorage ? JSON.parse(localStorage.getItem('fetchedUsers')) || {} : {};\r\n    const user = cachedUserInfo[userId];\r\n\r\n    // Validate if user data exists and has the required properties\r\n    if (useLocalStorage && validateUserData(user)) {\r\n      // If all data is cached, resolve with the cached data\r\n      resolve({\r\n        rank: user.rank,\r\n        login: user.login,\r\n        registeredDate: user.registered,\r\n        bestSpeed: user.bestSpeed,\r\n        ratingLevel: user.ratingLevel,\r\n        friends: user.friends, // Use cached friends count\r\n        cars: user.cars, // Use cached cars count\r\n        avatar: user.avatar, // Get avatar availability state\r\n        avatarTimestamp: user.avatarTimestamp // Cached avatar timestamp\r\n      });\r\n    } else {\r\n      try {\r\n        // Fetch profile summary and registered date\r\n        const summaryApiUrl = `https://klavogonki.ru/api/profile/get-summary?id=${userId}`;\r\n        const profileApiUrl = `https://klavogonki.ru/api/profile/get-index-data?userId=${userId}`;\r\n\r\n        // Fetch both profile summary and registration data in parallel\r\n        const [summaryResponse, profileResponse] = await Promise.all([\r\n          fetch(summaryApiUrl),\r\n          fetch(profileApiUrl),\r\n        ]);\r\n\r\n        // Check if both responses are successful\r\n        if (!summaryResponse.ok || !profileResponse.ok) {\r\n          throw new Error('Failed to fetch data from one of the APIs.');\r\n        }\r\n\r\n        const summaryData = await summaryResponse.json();\r\n        const profileData = await profileResponse.json();\r\n\r\n        if (\r\n          summaryData?.user?.login &&\r\n          summaryData.title &&\r\n          profileData?.stats?.registered\r\n        ) {\r\n          // Extract the relevant data\r\n          const rank = summaryData.title;\r\n          const login = summaryData.user.login;\r\n          const registered = profileData.stats.registered.sec\r\n            ? convertSecondsToDate(profileData.stats.registered.sec)\r\n            : 'Invalid Date';\r\n\r\n          // Extract new fields\r\n          const bestSpeed = profileData.stats.best_speed || 0; // Default to 0 if undefined\r\n          const ratingLevel = profileData.stats.rating_level || 0; // Default to 0 if undefined\r\n          const friends = profileData.stats.friends_cnt || 0; // Extract friends count\r\n          const cars = profileData.stats.cars_cnt || 0; // Extract cars count\r\n\r\n          // Extract sec and usec from user.avatar, with null check\r\n          const avatar = summaryData.user?.avatar || null; // Default to null if undefined or not present\r\n          const sec = summaryData.user.avatar?.sec || 0; // Default to 0 if undefined or null\r\n          const usec = summaryData.user.avatar?.usec || 0; // Default to 0 if undefined or null\r\n          const avatarTimestamp = convertToUpdatedTimestamp(sec, usec); // Combine sec and usec to get avatar timestamp\r\n\r\n          // Cache the fetched data if useLocalStorage is true, excluding the avatar\r\n          if (useLocalStorage) {\r\n            cachedUserInfo[userId] = {\r\n              rank: rank,\r\n              login: login,\r\n              registered: registered,\r\n              bestSpeed: bestSpeed,\r\n              ratingLevel: ratingLevel,\r\n              friends: friends, // Cache friends count\r\n              cars: cars, // Cache cars count\r\n              avatar: avatar,\r\n              avatarTimestamp: avatarTimestamp // Cache avatar timestamp\r\n            };\r\n\r\n            // Update localStorage with the new cached data\r\n            localStorage.setItem('fetchedUsers', JSON.stringify(cachedUserInfo));\r\n          }\r\n\r\n          // Resolve with the combined data\r\n          resolve({\r\n            rank: rank,\r\n            login: login,\r\n            registeredDate: registered,\r\n            bestSpeed: bestSpeed,\r\n            ratingLevel: ratingLevel,\r\n            friends: friends,\r\n            cars: cars,\r\n            avatar: avatar, // Return avatar for current session\r\n            avatarTimestamp: avatarTimestamp // Include avatar timestamp in the result\r\n          });\r\n        } else {\r\n          throw new Error('Invalid data format received from the API.');\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error fetching user profile data for ${userId}:`, error);\r\n        reject(error);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n// Helper function to convert time string to single hours\r\nfunction convertToSingleHours(timeString) {\r\n  const [hours, minutes = 0, seconds = 0] = timeString.split(':').map(Number);\r\n  return hours + minutes / 60 + seconds / 3600;\r\n}\r\n\r\n// Function to refresh or manually clear fetched users and reset the timer\r\n// @param {boolean} isManual - If true, clears cache unconditionally; if false, clears based on threshold (default is false)\r\n// @param {number} thresholdHours - Time threshold in hours for automatic cache clearing (default is 24 hours)\r\nfunction refreshFetchedUsers(isManual = false, thresholdHours = 24) {\r\n  // Retrieve the last clear time from localStorage\r\n  const lastClearTime = localStorage.getItem('lastClearTime');\r\n  const timeElapsed = lastClearTime ? (new Date().getTime() - lastClearTime) / (1000 * 60 * 60) : Infinity;\r\n\r\n  // If clearing manually or the time threshold has been reached, clear the cache\r\n  if (isManual || timeElapsed >= thresholdHours) {\r\n    // Clear the fetchedUsers from localStorage\r\n    localStorage.removeItem('fetchedUsers');\r\n\r\n    // Reset the in-memory fetchedUsers object\r\n    _definitions_js__WEBPACK_IMPORTED_MODULE_1__.state.fetchedUsers = {};\r\n\r\n    // Reset the timer by updating 'lastClearTime' and 'nextClearTime'\r\n    const nextClearTime = new Date().getTime() + thresholdHours * 60 * 60 * 1000;\r\n    localStorage.setItem('lastClearTime', new Date().getTime().toString());\r\n    localStorage.setItem('nextClearTime', nextClearTime.toString());\r\n  }\r\n}\r\n\r\nfunction getUserChatDuration(username, actionTime) {\r\n  // Retrieve stored user data and find the target user by login\r\n  const user = Object.values(JSON.parse(localStorage.getItem('fetchedUsers') || '[]'))\r\n    .find(u => u?.login === username);\r\n  if (!user) return `❌ User \"${username}\" not found`;\r\n\r\n  const actionLog = user.actionLog || [];\r\n  const current = actionLog.find(entry => entry.timestamp === actionTime);\r\n  if (!current) return `Action not found at ${actionTime}`;\r\n\r\n  const actionIndex = actionLog.indexOf(current);\r\n  if (actionIndex === 0) return `🙌 ${username}'s first action`;\r\n\r\n  // Find the most recent action before the current one that has a different type\r\n  const prev = actionLog.slice(0, actionIndex).reverse().find(a => a.type !== current.type);\r\n  if (!prev) return `❌ No valid previous action found for ${actionTime}`;\r\n\r\n  // Calculate the duration between the two timestamps\r\n  const duration = calculateDuration(prev.timestamp, current.timestamp);\r\n  return current.type === 'leave'\r\n    ? `🛑 ${username} stayed in chat for ${duration}`\r\n    : `✅ ${username} was absent for ${duration}`;\r\n}\r\n\r\nfunction calculateDuration(start, end) {\r\n  const toSeconds = t => t.split(':').reduce((acc, val, i) =>\r\n    acc + val * [3600, 60, 1][i], 0); // Convert HH:MM:SS to total seconds\r\n\r\n  const diff = Math.abs(toSeconds(end) - toSeconds(start)); // Get absolute difference in seconds\r\n\r\n  return [\r\n    Math.floor(diff / 3600), // Hours\r\n    Math.floor((diff % 3600) / 60), // Minutes\r\n    diff % 60 // Seconds\r\n  ].map(n => n.toString().padStart(2, '0')).join(':'); // Format as HH:MM:SS\r\n}\r\n\r\n// Function to check if a specific setting should be enabled based on localStorage settings\r\nfunction shouldEnableSetting(settingType, specificType) {\r\n  const toggleData = JSON.parse(localStorage.getItem('toggle')) || []; // Retrieve toggle settings or default to empty array\r\n\r\n  // Define toggle names for different setting types\r\n  const toggleNames = {\r\n    notifications: {\r\n      static: 'showChatStaticNotifications',\r\n      dynamic: 'showGlobalDynamicNotifications'\r\n    },\r\n    sound: {\r\n      presence: 'enableBeepOnChatJoinLeave',\r\n      gTTS: 'switchToGoogleTTSEngine'\r\n    }\r\n  };\r\n\r\n  const settingName = toggleNames[settingType];\r\n\r\n  if (!settingName || !settingName[specificType]) return false;\r\n\r\n  // Check if the specified setting toggle is set to 'yes'\r\n  return toggleData.some(toggle =>\r\n    toggle.name === settingName[specificType] && toggle.option === 'yes'\r\n  );\r\n}\r\n\r\n// Track if the user has loaded messages for the first time\r\nlet firstTime = true;\r\n// The distance from the bottom at which we should trigger auto-scrolling\r\nconst scrollThreshold = 600;\r\n\r\n// Scrolls the specified container to the bottom if the user has scrolled close enough\r\nfunction scrollMessagesToBottom(containerType = 'generalMessages') {\r\n  // Define a mapping for container types to their respective selectors\r\n  const containerSelectors = {\r\n    generalMessages: '.messages-content', // For general chat\r\n    chatlogsMessages: '.chat-logs-container', // For chat logs\r\n    personalMessages: '.messages-container-wrapper' // For personal messages panel\r\n  };\r\n\r\n  // Get the container based on the passed containerType\r\n  const containerSelector = containerSelectors[containerType];\r\n\r\n  // If the container selector is not defined, return\r\n  if (!containerSelector) return;\r\n\r\n  // Get the container element\r\n  const container = document.querySelector(containerSelector);\r\n  if (!container) return; // Return if the container doesn't exist\r\n\r\n  // If it's the user's first time loading messages, auto-scroll to the bottom\r\n  if (firstTime) {\r\n    container.scrollTop = container.scrollHeight;\r\n    firstTime = false;\r\n  } else {\r\n    // Calculate how far the user is from the bottom\r\n    const distanceFromBottom = container.scrollHeight - container.scrollTop - container.clientHeight;\r\n    // If the user is close enough to the bottom, auto-scroll to the bottom\r\n    if (distanceFromBottom <= scrollThreshold) {\r\n      container.scrollTop = container.scrollHeight;\r\n    }\r\n  }\r\n}\r\n\r\n// Function to scroll messages to the middle of the parent container\r\nasync function scrollMessagesToMiddle(parent, element) {\r\n  const { top, height } = element.getBoundingClientRect(); // Get the position and height of the found element\r\n  const { top: parentTop, height: parentHeight } = parent.getBoundingClientRect(); // Get the position and height of the parent\r\n\r\n  // Calculate the middle position of the parent container\r\n  const parentMiddle = parentTop + parentHeight / 2;\r\n\r\n  // Determine how far to scroll to center the found element\r\n  const scrollOffset = top - parentMiddle + height / 2;\r\n\r\n  // Scroll to the found element to center it within the parent\r\n  parent.scrollBy({\r\n    top: scrollOffset,\r\n    behavior: 'smooth'\r\n  });\r\n\r\n  await new Promise(resolve => setTimeout(resolve, 500)); // Wait for the scroll to complete\r\n  parent.style.scrollBehavior = 'auto'; // Reset scroll behavior\r\n  addShakeEffect(element); // Add a shake effect to the found element\r\n}\r\n\r\n// Helper function to get current time formatted as [HH:MM:SS]\r\nfunction getCurrentTimeFormatted() {\r\n  return new Date().toLocaleTimeString('en-US', {\r\n    hour12: false,\r\n    hour: '2-digit',\r\n    minute: '2-digit',\r\n    second: '2-digit'\r\n  });\r\n}\r\n\r\n/**\r\n * Checks if a given URL belongs to a trusted domain.\r\n * @param {string} url - The URL to check.\r\n * @returns {{isTrusted: boolean, domain: string}} - Whether the domain is trusted and the extracted domain.\r\n */\r\nfunction isTrustedDomain(url) {\r\n  try {\r\n    const parsedURL = new URL(url);\r\n    const hostnameParts = parsedURL.hostname.toLowerCase().split('.');\r\n    const domain = hostnameParts.length > 2 ? hostnameParts.slice(-2).join('.') : parsedURL.hostname;\r\n    return { isTrusted: _definitions_js__WEBPACK_IMPORTED_MODULE_1__.trustedDomains.includes(domain), domain };\r\n  } catch (error) {\r\n    console.error(\"Error in isTrustedDomain:\", error.message);\r\n    return { isTrusted: false, domain: url }; // Return original URL as domain in case of error\r\n  }\r\n}\r\n\r\nfunction highlightMentionWords(containerType = 'generalMessages') {\r\n  const containerSelectors = {\r\n    generalMessages: {\r\n      container: '.messages-content div',\r\n      messageElement: 'p',\r\n      exclude: ['.time', '.username'] // Add exclusion list\r\n    },\r\n    chatlogsMessages: {\r\n      container: '.chat-logs-container',\r\n      messageElement: '.message-text'\r\n    },\r\n    personalMessages: {\r\n      container: '.messages-container',\r\n      messageElement: '.message-text'\r\n    }\r\n  };\r\n\r\n  const config = containerSelectors[containerType];\r\n  if (!config) {\r\n    console.error('Invalid container type');\r\n    return;\r\n  }\r\n\r\n  const containers = document.querySelectorAll(config.container);\r\n  const globalProcessed = new WeakSet();\r\n\r\n  containers.forEach((container) => {\r\n    const messages = container.querySelectorAll(config.messageElement);\r\n\r\n    messages.forEach((message) => {\r\n      const processingQueue = [\r\n        ...message.querySelectorAll('.private'),\r\n        ...message.querySelectorAll('.system-message'),\r\n        message\r\n      ];\r\n\r\n      processingQueue.forEach((element) => {\r\n        const walker = document.createTreeWalker(\r\n          element,\r\n          NodeFilter.SHOW_TEXT,\r\n          {\r\n            acceptNode: (node) => {\r\n              // Skip processed nodes and protected elements\r\n              if (globalProcessed.has(node)) return NodeFilter.FILTER_SKIP;\r\n\r\n              // Check if node is inside excluded elements\r\n              const parent = node.parentElement;\r\n              if (parent.closest('.mention, .time, .username')) {\r\n                return NodeFilter.FILTER_SKIP;\r\n              }\r\n\r\n              // Additional exclusion for generalMessages\r\n              if (containerType === 'generalMessages' && parent.closest(config.exclude.join(','))) {\r\n                return NodeFilter.FILTER_SKIP;\r\n              }\r\n\r\n              return NodeFilter.FILTER_ACCEPT;\r\n            }\r\n          },\r\n          false\r\n        );\r\n\r\n        const nodes = [];\r\n        let currentNode;\r\n        while ((currentNode = walker.nextNode())) {\r\n          nodes.push(currentNode);\r\n        }\r\n\r\n        nodes.forEach((node) => {\r\n          if (!globalProcessed.has(node)) {\r\n            processNode(node);\r\n            globalProcessed.add(node);\r\n          }\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  function processNode(node) {\r\n    const regex = /[\\s]+|[^\\s\\wа-яА-ЯёЁ]+|[\\wа-яА-ЯёЁ]+/g;\r\n    const words = node.textContent.match(regex);\r\n    if (!words) return;\r\n\r\n    const fragment = document.createDocumentFragment();\r\n\r\n    words.forEach((word) => {\r\n      if (_definitions_js__WEBPACK_IMPORTED_MODULE_1__.mentionKeywords.map(alias => alias.toLowerCase()).includes(word.toLowerCase())) {\r\n        const mentionSpan = document.createElement('span');\r\n        mentionSpan.className = 'mention';\r\n        mentionSpan.textContent = word;\r\n        fragment.appendChild(mentionSpan);\r\n      } else {\r\n        fragment.appendChild(document.createTextNode(word));\r\n      }\r\n    });\r\n\r\n    node.parentNode.replaceChild(fragment, node);\r\n  }\r\n}\r\n\r\n// Initialize previousTotalCount with the current personal messages count from localStorage\r\nlet previousTotalCount =\r\n  (localStorage.personalMessages && Object.keys(JSON.parse(localStorage.personalMessages)).length) || 0;\r\n/**\r\n * Updates total and new personal message counts near the personal messages button.\r\n * - Increments new message count only when total message count increases.\r\n * - Manages visibility and pulse effects for the new message indicator.\r\n */\r\nfunction updatePersonalMessageCounts() {\r\n  const totalCountElement = document.querySelector('.personal-messages-button .total-message-count');\r\n  const newCountElement = document.querySelector('.personal-messages-button .new-message-count');\r\n  if (!totalCountElement || !newCountElement) return; // Exit if elements are missing\r\n\r\n  const personalMessages = JSON.parse(localStorage.getItem('personalMessages')) || {};\r\n  const totalCount = Object.keys(personalMessages).length;\r\n\r\n  let newCount = Number(localStorage.getItem('newMessagesCount')) || 0;\r\n  if (totalCount > previousTotalCount) {\r\n    newCount++;\r\n    localStorage.setItem('newMessagesCount', newCount);\r\n    addPulseEffect(newCountElement); // Apply pulse effect for new messages\r\n    addJumpEffect(newCountElement, 50, 50); // Apply jump effect for new messages\r\n  }\r\n\r\n  // Update counts in the UI\r\n  totalCountElement.textContent = totalCount;\r\n  newCountElement.textContent = newCount;\r\n\r\n  // Manage visibility of the new message indicator\r\n  newCountElement.style.visibility = newCount > 0 ? 'visible' : 'hidden';\r\n\r\n  // Apply pulse effect if total count changes\r\n  if (totalCount !== previousTotalCount) addPulseEffect(totalCountElement);\r\n\r\n  previousTotalCount = totalCount; // Update previous count\r\n}\r\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/helpers.js?");

/***/ }),

/***/ "./src/modules/icons.js":
/*!******************************!*\
  !*** ./src/modules/icons.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   actionSVG: () => (/* binding */ actionSVG),\n/* harmony export */   addSVG: () => (/* binding */ addSVG),\n/* harmony export */   beepSVG: () => (/* binding */ beepSVG),\n/* harmony export */   calendarSVG: () => (/* binding */ calendarSVG),\n/* harmony export */   chatLogsSVG: () => (/* binding */ chatLogsSVG),\n/* harmony export */   chevronDownSVG: () => (/* binding */ chevronDownSVG),\n/* harmony export */   chevronLeftSVG: () => (/* binding */ chevronLeftSVG),\n/* harmony export */   chevronRightSVG: () => (/* binding */ chevronRightSVG),\n/* harmony export */   chevronUpSVG: () => (/* binding */ chevronUpSVG),\n/* harmony export */   chevronsDownSVG: () => (/* binding */ chevronsDownSVG),\n/* harmony export */   chevronsUpSVG: () => (/* binding */ chevronsUpSVG),\n/* harmony export */   clipboardSVG: () => (/* binding */ clipboardSVG),\n/* harmony export */   clockSVG: () => (/* binding */ clockSVG),\n/* harmony export */   closeSVG: () => (/* binding */ closeSVG),\n/* harmony export */   deniedSVG: () => (/* binding */ deniedSVG),\n/* harmony export */   enterSVG: () => (/* binding */ enterSVG),\n/* harmony export */   exportSVG: () => (/* binding */ exportSVG),\n/* harmony export */   ignoredSVG: () => (/* binding */ ignoredSVG),\n/* harmony export */   importSVG: () => (/* binding */ importSVG),\n/* harmony export */   leaveSVG: () => (/* binding */ leaveSVG),\n/* harmony export */   mediaMessagesSVG: () => (/* binding */ mediaMessagesSVG),\n/* harmony export */   modeEverySVG: () => (/* binding */ modeEverySVG),\n/* harmony export */   modeMentionSVG: () => (/* binding */ modeMentionSVG),\n/* harmony export */   moderatorSVG: () => (/* binding */ moderatorSVG),\n/* harmony export */   personalMessagesSVG: () => (/* binding */ personalMessagesSVG),\n/* harmony export */   rangeIsOutSVG: () => (/* binding */ rangeIsOutSVG),\n/* harmony export */   removeSVG: () => (/* binding */ removeSVG),\n/* harmony export */   saveSVG: () => (/* binding */ saveSVG),\n/* harmony export */   settingsSVG: () => (/* binding */ settingsSVG),\n/* harmony export */   shuffleSVG: () => (/* binding */ shuffleSVG),\n/* harmony export */   silenceSVG: () => (/* binding */ silenceSVG),\n/* harmony export */   snowflakeSVG: () => (/* binding */ snowflakeSVG),\n/* harmony export */   toggleLeftSVG: () => (/* binding */ toggleLeftSVG),\n/* harmony export */   toggleRightSVG: () => (/* binding */ toggleRightSVG),\n/* harmony export */   trackedSVG: () => (/* binding */ trackedSVG),\n/* harmony export */   trashSVG: () => (/* binding */ trashSVG),\n/* harmony export */   userSVG: () => (/* binding */ userSVG),\n/* harmony export */   userlistCacheSVG: () => (/* binding */ userlistCacheSVG),\n/* harmony export */   usersSVG: () => (/* binding */ usersSVG),\n/* harmony export */   voiceSVG: () => (/* binding */ voiceSVG)\n/* harmony export */ });\nconst svgUrl = \"http://www.w3.org/2000/svg\";\r\nconst iconStrokeWidth = 2;\r\nconst iconSize = 28;\r\n\r\n// SVG icon for entering\r\nconst enterSVGStrokeColor = \"currentColor\";\r\nconst enterSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${enterSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"icon-enter icon-feather icon-log-in\">\r\n    <path d=\"M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4\"></path>\r\n    <polyline points=\"10 17 15 12 10 7\"></polyline>\r\n    <line x1=\"15\" y1=\"12\" x2=\"3\" y2=\"12\"></line>\r\n  </svg>`;\r\n\r\n// SVG icon for leaving\r\nconst leaveSVGStrokeColor = \"currentColor\";\r\nconst leaveSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${leaveSVGStrokeColor}\" stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"icon-leave icon-feather icon-log-out\">\r\n    <path d=\"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4\"></path>\r\n    <polyline points=\"16 17 21 12 16 7\"></polyline>\r\n    <line x1=\"21\" y1=\"12\" x2=\"9\" y2=\"12\"></line>\r\n  </svg>`;\r\n\r\n// SVG icon for the moderator with gradient\r\nconst moderatorSVGStopColorStart = \"rgb(255, 215, 0)\";\r\nconst moderatorSVGStopColorEnd = \"rgb(255, 140, 0)\";\r\nconst moderatorSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 10}\"\r\n      height=\"${iconSize - 10}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"url(#moderatorGradient)\"  <!-- Use a gradient fill -->\r\n      stroke=\"none\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-shield\">\r\n    <!-- Define the gradient -->\r\n    <defs>\r\n        <linearGradient id=\"moderatorGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n            <stop offset=\"0%\" style=\"stop-color: ${moderatorSVGStopColorStart}; stop-opacity: 1\" />\r\n            <stop offset=\"100%\" style=\"stop-color: ${moderatorSVGStopColorEnd}; stop-opacity: 1\" />\r\n        </linearGradient>\r\n    </defs>\r\n    <path d=\"M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z\"></path>\r\n  </svg>`;\r\n\r\n// SVG icon for the tracked with gradient stroke\r\nconst trackedSVGStopColorStart = \"rgb(135, 206, 250)\";\r\nconst trackedSVGStopColorEnd = \"rgb(0, 191, 255)\";\r\nconst trackedSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n       width=\"${iconSize - 12}\"\r\n       height=\"${iconSize - 12}\"\r\n       viewBox=\"0 0 24 24\"\r\n       fill=\"url(#trackedGradient)\"  <!-- Use a gradient fill -->\r\n       class=\"feather feather-star\">\r\n      <!-- Define the gradient for the fill -->\r\n    <defs>\r\n      <linearGradient id=\"trackedGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" style=\"stop-color: ${trackedSVGStopColorStart}; stop-opacity: 1\" />\r\n        <stop offset=\"100%\" style=\"stop-color: ${trackedSVGStopColorEnd}; stop-opacity: 1\" />\r\n      </linearGradient>\r\n    </defs>\r\n    <!-- Use the gradient for the fill -->\r\n    <polygon points=\"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2\"\r\n      stroke=\"url(#trackedGradient)\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    </polygon>\r\n  </svg>`;\r\n\r\n// SVG icon for ignored users\r\nconst ignoredSVGStrokeColor = \"rgb(255, 160, 122)\";\r\nconst ignoredSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${ignoredSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-slash\">\r\n    <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\r\n    <line x1=\"4.93\" y1=\"4.93\" x2=\"19.07\" y2=\"19.07\"></line>\r\n  </svg>`;\r\n\r\n// SVG markup for a clock icon\r\nconst clockSVGStrokeColor = \"currentColor\";\r\nconst clockSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n       width=\"${iconSize - 12}\"\r\n       height=\"${iconSize - 12}\"\r\n       viewBox=\"0 0 24 24\"\r\n       fill=\"none\"\r\n       stroke=\"${clockSVGStrokeColor}\"\r\n       stroke-width=\"${iconStrokeWidth}\"\r\n       stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-clock\">\r\n    <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\r\n    <polyline points=\"12 6 12 12 16 14\"></polyline>\r\n  </svg>`;\r\n\r\n// SVG for the \"chevron right\" icon, used in a popup chat messages\r\nconst actionSVGStrokeColor = \"currentColor\";\r\nconst actionSVG = `\r\n    <svg xmlns=\"${svgUrl}\"\r\n        width=\"${iconSize - 12}\"\r\n        height=\"${iconSize - 12}\"\r\n        viewBox=\"0 0 24 24\"\r\n        fill=\"none\"\r\n        stroke=\"${actionSVGStrokeColor}\"\r\n        stroke-width=\"${iconStrokeWidth}\"\r\n        stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-right\">\r\n      <polyline points=\"9 18 15 12 9 6\"></polyline>\r\n    </svg>`;\r\n\r\n// SVG markup for a user icon\r\nconst userSVGStrokeColor = \"currentColor\";\r\nconst userSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${userSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-user\">\r\n    <path d=\"M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2\"></path>\r\n    <circle cx=\"12\" cy=\"7\" r=\"4\"></circle>\r\n  </svg>`;\r\n\r\n// Button SVG icons \"silence\", \"beep\", \"voice\" representation\r\nconst silenceSVGStrokeColor = \"hsl(355, 80%, 65%)\";\r\nconst beepSVGStrokeColor = \"hsl(55, 80%, 65%)\";\r\nconst voiceSVGStrokeColor = \"hsl(80, 80%, 40%)\";\r\nconst silenceSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${silenceSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\r\n    <line x1=\"23\" y1=\"9\" x2=\"17\" y2=\"15\"></line>\r\n    <line x1=\"17\" y1=\"9\" x2=\"23\" y2=\"15\"></line>\r\n  </svg>`;\r\n\r\nconst beepSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${beepSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\r\n    <path d=\"M19.07 4.93a10 10 0 0 1 0 14.14\" opacity=\"0.3\"></path>\r\n    <path d=\"M15.54 8.46a5 5 0 0 1 0 7.07\"></path>\r\n  </svg>`;\r\n\r\nconst voiceSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${voiceSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\r\n    <path d=\"M19.07 4.93a10 10 0 0 1 0 14.14\"></path>\r\n    <path d=\"M15.54 8.46a5 5 0 0 1 0 7.07\"></path>\r\n  </svg>`;\r\n\r\n// Icons for message mode button\r\n// Button SVG icons \"every\", \"mention\" representation\r\nconst modeEverySVGStrokeColor = \"hsl(100, 50%, 50%)\";\r\nconst modeEverySVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${modeEverySVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path>\r\n    <circle cx=\"9\" cy=\"7\" r=\"4\"></circle>\r\n    <path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"></path>\r\n    <path d=\"M16 3.13a4 4 0 0 1 0 7.75\"></path>\r\n  </svg>`;\r\n\r\nconst modeMentionSVGStrokeColor = \"hsl(180, 60%, 50%)\";\r\nconst modeMentionSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${modeMentionSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2\"></path>\r\n    <circle cx=\"12\" cy=\"7\" r=\"4\"></circle>\r\n  </svg>`;\r\n\r\n// Icon for the out of range value\r\nconst rangeIsOutSVGStrokeColor = \"currentColor\";\r\nconst rangeIsOutSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${rangeIsOutSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-slash\">\r\n    <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\r\n    <line x1=\"4.93\" y1=\"4.93\" x2=\"19.07\" y2=\"19.07\"></line>\r\n  </svg>`;\r\n\r\n// Icon for userlistCache\r\nconst userlistCacheSVGStrokeColor = \"rgb(180, 213, 131)\";\r\nconst userlistCacheSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${userlistCacheSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-database\">\r\n    <ellipse cx=\"12\" cy=\"5\" rx=\"9\" ry=\"3\"></ellipse>\r\n    <path d=\"M21 12c0 1.66-4 3-9 3s-9-1.34-9-3\"></path>\r\n    <path d=\"M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5\"></path>\r\n  </svg>`;\r\n\r\n// Icon for personal messages\r\nconst personalMessagesSVGStrokeColor = \"rgb(255, 160, 122)\";\r\nconst personalMessagesSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${personalMessagesSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-mail\">\r\n    <path d=\"M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z\"></path>\r\n    <polyline points=\"22,6 12,13 2,6\"></polyline>\r\n  </svg>`;\r\n\r\n// Icon for chat logs\r\nconst chatLogsSVGStrokeColor = \"rgb(100, 149, 237)\";\r\nconst chatLogsSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize}\"\r\n      height=\"${iconSize}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chatLogsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-message-circle\">\r\n      <path \r\n          d=\"M21 11.5 a8.38 8.38 0 0 1 -.9 3.8 a8.5 8.5 0 0 1 -7.6 4.7 a8.38 8.38 0 0 1 -3.8 -.9\r\n          L3 21 l1.9 -5.7 a8.38 8.38 0 0 1 -.9 -3.8 a8.5 8.5 0 0 1 4.7 -7.6\r\n          a8.38 8.38 0 0 1 3.8 -.9 h.5 a8.48 8.48 0 0 1 8 8 v.5 z\">\r\n      </path>\r\n  </svg>`;\r\n\r\n// Icon for media messages\r\nconst mediaMessagesSVGStrokeColor = \"rgb(113, 196, 196)\";\r\nconst mediaMessagesSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${mediaMessagesSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-film\">\r\n    <rect x=\"2\" y=\"2\" width=\"20\" height=\"20\" rx=\"2.18\" ry=\"2.18\"></rect>\r\n    <line x1=\"7\" y1=\"2\" x2=\"7\" y2=\"22\"></line>\r\n    <line x1=\"17\" y1=\"2\" x2=\"17\" y2=\"22\"></line>\r\n    <line x1=\"2\" y1=\"12\" x2=\"22\" y2=\"12\"></line>\r\n    <line x1=\"2\" y1=\"7\" x2=\"7\" y2=\"7\"></line>\r\n    <line x1=\"2\" y1=\"17\" x2=\"7\" y2=\"17\"></line>\r\n    <line x1=\"17\" y1=\"17\" x2=\"22\" y2=\"17\"></line>\r\n    <line x1=\"17\" y1=\"7\" x2=\"22\" y2=\"7\"></line>\r\n  </svg>`;\r\n\r\n// Icon for the disabled chat button\r\nconst deniedSVGStrokeColor = \"rgb(255, 100, 100)\";\r\nconst deniedSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${deniedSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-slash\">\r\n    <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\r\n    <line x1=\"4.93\" y1=\"4.93\" x2=\"19.07\" y2=\"19.07\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the settings icon\r\nconst settingsSVGStrokeColor = \"rgb(255, 228, 196)\";\r\nconst settingsSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${settingsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-sliders\">\r\n    <line x1=\"4\" y1=\"21\" x2=\"4\" y2=\"14\"></line>\r\n    <line x1=\"4\" y1=\"10\" x2=\"4\" y2=\"3\"></line>\r\n    <line x1=\"12\" y1=\"21\" x2=\"12\" y2=\"12\"></line>\r\n    <line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"3\"></line>\r\n    <line x1=\"20\" y1=\"21\" x2=\"20\" y2=\"16\"></line>\r\n    <line x1=\"20\" y1=\"12\" x2=\"20\" y2=\"3\"></line>\r\n    <line x1=\"1\" y1=\"14\" x2=\"7\" y2=\"14\"></line>\r\n    <line x1=\"9\" y1=\"8\" x2=\"15\" y2=\"8\"></line>\r\n    <line x1=\"17\" y1=\"16\" x2=\"23\" y2=\"16\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"x\" icon (close button)\r\nconst closeSVGStrokeColor = \"rgb(144, 238, 144)\";\r\nconst closeSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${closeSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-x\">\r\n    <line x1=\"18\" y1=\"6\" x2=\"6\" y2=\"18\"></line>\r\n    <line x1=\"6\" y1=\"6\" x2=\"18\" y2=\"18\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"chevrons up\" icon\r\nconst chevronsSVGStrokeColor = \"rgb(211, 211, 211)\";\r\nconst chevronsUpSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevrons-up\">\r\n    <polyline points=\"17 11 12 6 7 11\"></polyline>\r\n    <polyline points=\"17 18 12 13 7 18\"></polyline>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"chevron up\" icon\r\nconst chevronUpSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-up\">\r\n    <polyline points=\"18 15 12 9 6 15\"></polyline>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"chevron down\" icon\r\nconst chevronDownSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-down\">\r\n    <polyline points=\"6 9 12 15 18 9\"></polyline>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"chevrons down\" icon\r\nconst chevronsDownSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronsSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevrons-down\">\r\n    <polyline points=\"7 13 12 18 17 13\"></polyline>\r\n    <polyline points=\"7 6 12 11 17 6\"></polyline>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"toggle-right\" icon\r\nconst toggleRightSVGStrokeColor = \"rgb(137, 187, 255)\";\r\nconst toggleRightSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 25 25\"\r\n      fill=\"none\"\r\n      stroke=\"${toggleRightSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-toggle-right\">\r\n    <rect x=\"1\" y=\"5\" width=\"22\" height=\"14\" rx=\"7\" ry=\"7\"></rect>\r\n    <circle cx=\"16\" cy=\"12\" r=\"3\"></circle>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"toggle-left\" icon\r\nconst toggleLeftSVGStrokeColor = \"rgb(137, 187, 255)\";\r\nconst toggleLeftSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 25 25\"\r\n      fill=\"none\"\r\n      stroke=\"${toggleLeftSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-toggle-left\">\r\n    <rect x=\"1\" y=\"5\" width=\"22\" height=\"14\" rx=\"7\" ry=\"7\"></rect>\r\n    <circle cx=\"8\" cy=\"12\" r=\"3\"></circle>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"calendar\" icon\r\nconst calendarSVGStrokeColor = \"rgb(176, 196, 222)\";\r\nconst calendarSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${calendarSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-calendar\">\r\n    <rect x=\"3\" y=\"4\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect>\r\n    <line x1=\"16\" y1=\"2\" x2=\"16\" y2=\"6\"></line>\r\n    <line x1=\"8\" y1=\"2\" x2=\"8\" y2=\"6\"></line>\r\n    <line x1=\"3\" y1=\"10\" x2=\"21\" y2=\"10\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"clipboard\" icon\r\nconst clipboardSVGStrokeColor = \"rgb(176, 196, 222)\";\r\nconst clipboardSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${clipboardSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-clipboard\">\r\n    <path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path>\r\n    <rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect>\r\n  </svg>`;\r\n\r\n// SVG for the \"chevron left\" icon, used to change chat logs one day backward\r\nconst chevronLeftSVGStrokeColor = \"rgb(28, 229, 229)\";\r\nconst chevronLeftSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronLeftSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-left\">\r\n    <polyline points=\"15 18 9 12 15 6\"></polyline>\r\n  </svg>`;\r\n\r\n// SVG for the \"chevron right\" icon, used to change chat logs one day forward\r\nconst chevronRightSVGStrokeColor = \"rgb(28, 229, 229)\";\r\nconst chevronRightSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${chevronRightSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-right\">\r\n      <polyline points=\"9 18 15 12 9 6\"></polyline>\r\n  </svg>`;\r\n\r\n// SVG for the \"shuffle\" icon, used to select a random year, month, and day\r\nconst shuffleSVGStrokeColor = \"rgb(169, 155, 255)\";\r\nconst shuffleSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${shuffleSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-shuffle\">\r\n    <polyline points=\"16 3 21 3 21 8\"></polyline>\r\n    <line x1=\"4\" y1=\"20\" x2=\"21\" y2=\"3\"></line>\r\n    <polyline points=\"21 16 21 21 16 21\"></polyline>\r\n    <line x1=\"15\" y1=\"15\" x2=\"21\" y2=\"21\"></line>\r\n    <line x1=\"4\" y1=\"4\" x2=\"9\" y2=\"9\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the trash icon\r\nconst trashSVGStrokeColor = \"rgb(255, 140, 0)\";\r\nconst trashSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${trashSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-trash-2\">\r\n    <polyline points=\"3 6 5 6 21 6\"></polyline>\r\n    <path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path>\r\n    <line x1=\"10\" y1=\"11\" x2=\"10\" y2=\"17\"></line>\r\n    <line x1=\"14\" y1=\"11\" x2=\"14\" y2=\"17\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the users icon\r\nconst usersSVGStrokeColor = \"currentColor\";\r\nconst usersSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${usersSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-users\">\r\n    <path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path>\r\n    <circle cx=\"9\" cy=\"7\" r=\"4\"></circle>\r\n    <path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"></path>\r\n    <path d=\"M16 3.13a4 4 0 0 1 0 7.75\"></path>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"import\" icon (export button)\r\nconst importSVGStrokeColor = \"rgb(209, 144, 238)\";\r\nconst importSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${importSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-download\">\r\n    <path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"></path>\r\n    <polyline points=\"7 10 12 15 17 10\"></polyline>\r\n    <line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"export\" icon (import button)\r\nconst exportSVGStrokeColor = \"rgb(144, 185, 238)\";\r\nconst exportSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${exportSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\" stroke-linecap=\"round\"\r\n      stroke-linejoin=\"round\" class=\"feather feather-upload\">\r\n    <path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"></path>\r\n    <polyline points=\"17 8 12 3 7 8\"></polyline>\r\n    <line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"></line>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"save\" icon (save button)\r\nconst saveSVGStrokeColor = \"rgb(144, 238, 220)\";\r\nconst saveSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 4}\"\r\n      height=\"${iconSize - 4}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${saveSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-save\">\r\n    <path d=\"M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z\"></path>\r\n    <polyline points=\"17 21 17 13 7 13 7 21\"></polyline>\r\n    <polyline points=\"7 3 7 8 15 8\"></polyline>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"remove\" icon (remove button)\r\nconst removeSVGStrokeColor = \"rgb(238, 144, 144)\";\r\nconst removeSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${removeSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-trash\">\r\n    <polyline points=\"3 6 5 6 21 6\"></polyline>\r\n    <path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"snowflake\" icon\r\nconst snowflakeSVGStrokeColor = \"rgb(176, 196, 222)\";\r\nconst snowflakeSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 8}\"\r\n      height=\"${iconSize - 8}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${snowflakeSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-snowflake\">\r\n    <g id=\"snowflake\">\r\n      <line x1=\"12.06\" y1=\"2.74\" x2=\"12.06\" y2=\"12.06\" />\r\n      <line x1=\"20.12\" y1=\"7.4\" x2=\"12.06\" y2=\"12.06\" />\r\n      <line x1=\"20.12\" y1=\"16.71\" x2=\"12.06\" y2=\"12.06\" />\r\n      <line x1=\"12.06\" y1=\"21.37\" x2=\"12.06\" y2=\"12.06\" />\r\n      <line x1=\"3.99\" y1=\"16.71\" x2=\"12.06\" y2=\"12.06\" />\r\n      <line x1=\"3.99\" y1=\"7.4\" x2=\"12.06\" y2=\"12.06\" />\r\n      <polyline points=\"8.96,4.67 12.06,7.77 15.16,4.67\"/>\r\n      <polyline points=\"16.9,5.68 15.76,9.92 20,11.05\"/>\r\n      <polyline points=\"20,13.06 15.76,14.2 16.9,18.43\"/>\r\n      <polyline points=\"15.16,19.44 12.06,16.34 8.96,19.44\"/>\r\n      <polyline points=\"7.21,18.43 8.35,14.2 4.11,13.06\"/>\r\n      <polyline points=\"4.11,11.05 8.35,9.92 7.21,5.68\"/>\r\n    </g>\r\n  </svg>`;\r\n\r\n// Inline SVG source for the \"add\" icon (add button)\r\nconst addSVGStrokeColor = \"rgb(209, 144, 238)\";\r\nconst addSVG = `\r\n  <svg xmlns=\"${svgUrl}\"\r\n      width=\"${iconSize - 12}\"\r\n      height=\"${iconSize - 12}\"\r\n      viewBox=\"0 0 24 24\"\r\n      fill=\"none\"\r\n      stroke=\"${addSVGStrokeColor}\"\r\n      stroke-width=\"${iconStrokeWidth}\"\r\n      stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-plus\">\r\n    <line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"></line>\r\n    <line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"></line>\r\n  </svg>`;\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/icons.js?");

/***/ }),

/***/ "./src/modules/image-converter.js":
/*!****************************************!*\
  !*** ./src/modules/image-converter.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertImageLinksToImage: () => (/* binding */ convertImageLinksToImage)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/modules/helpers.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definitions */ \"./src/modules/definitions.js\");\n// helpers\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Define dynamic variables\r\nlet {\r\n  bigImageEvents,\r\n} = _definitions__WEBPACK_IMPORTED_MODULE_1__.state;\r\n\r\n/*\r\n   * Converts links to images in chat messages by creating a thumbnail and a big image on click.\r\n   * Looks for links that contain \".jpg\" or \".jpeg\" or \".png\" or \".gif\" or \"webp\" extension and creates a thumbnail with the image.\r\n   * If a thumbnail already exists, it skips the link and looks for the next one.\r\n   * When a thumbnail is clicked, it creates a dimming layer and a big image that can be closed by clicking on the dimming layer or the big image itself.\r\n   * Allows navigation through images using the left (<) and right (>) arrow keys.\r\n   */\r\n\r\n// Define global variables for the current big image\r\nlet bigImage = null;\r\n\r\n// Define an array to store all the thumbnail links and their corresponding image URLs\r\nconst thumbnailLinks = [];\r\nlet currentImageIndex = 0;\r\nconst imageChangeDelay = 50; // Prevent double slide by single press adding slight delay\r\nlet isChangingImage = false; // Flag to track if an image change is in progress\r\n\r\nconst imageExtensionEmoji = '📸';\r\nconst webDomainEmoji = '🖥️';\r\nconst untrustedEoji = '💀️️';\r\n\r\n// List of allowed image extensions\r\nconst allowedImageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];\r\n\r\n/**\r\n * Checks if a given URL has an allowed image extension.\r\n * @param {string} url - The URL to check.\r\n * @returns {{allowed: boolean, extension: string}} - If the extension is allowed and its type.\r\n */\r\nfunction isAllowedImageExtension(url) {\r\n  // Shared extension extraction logic\r\n  const getExtension = (str) =>\r\n    (str.match(/\\.([^?#.]+)(?:[?#]|$)/i)?.[1]?.toLowerCase() || '');\r\n\r\n  try {\r\n    const extension = getExtension(url);\r\n    return {\r\n      allowed: allowedImageExtensions.includes(extension),\r\n      extension\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Error in isAllowedImageExtension:\", error.message);\r\n    return {\r\n      allowed: false,\r\n      extension: getExtension(String(url)) // Handle non-string URLs\r\n    };\r\n  }\r\n}\r\n\r\nfunction convertImageLinksToImage(containerType) {\r\n  const containerSelectors = {\r\n    generalMessages: \".messages-content div\",\r\n    chatlogsMessages: \".chat-logs-container\",\r\n    personalMessages: \".messages-container-wrapper\"\r\n  }\r\n\r\n  const container = document.querySelector(containerSelectors[containerType]);\r\n  if (!container) return;\r\n\r\n  const links = container.querySelectorAll(\"a:not(.skipped):not(.processed-image)\");\r\n  if (!links.length) return;\r\n\r\n  links.forEach(link => {\r\n    if (!link.href || !link.href.startsWith(\"http\")) return;\r\n\r\n    const { allowed, extension } = isAllowedImageExtension(link.href);\r\n    if (!allowed) return;\r\n\r\n    // Add class media if allowed image extenstion\r\n    link.classList.add(\"media\");\r\n\r\n    const { isTrusted, domain } = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isTrustedDomain)(link.href);\r\n    link.title = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isValidEncodedURL)(link.href) ? (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.decodeURL)(link.href) : link.href;\r\n\r\n    // Handle untrusted domains\r\n    if (!isTrusted) {\r\n      link.classList.add(\"skipped\");\r\n      link.textContent = `${imageExtensionEmoji} Image (${extension.toUpperCase()}) ${webDomainEmoji} Hostname (${domain}) ${untrustedEoji} Untrusted`;\r\n\r\n      // Directly handle the image loading on link click\r\n      link.addEventListener(\"click\", e => {\r\n        if (!link.classList.contains(\"processed-image\")) {\r\n          e.preventDefault(); // Prevent default behavior only if not processed yet\r\n          link.classList.remove(\"skipped\");\r\n          link.classList.add(\"processed-image\");\r\n          createThumbnail(link, true); // Force thumbnail creation\r\n        }\r\n      })\r\n    } else {\r\n      link.textContent = `${imageExtensionEmoji} Image (${extension.toUpperCase()}) ${webDomainEmoji} Hostname (${domain})`;\r\n      link.classList.add(\"processed-image\");\r\n      // Create thumbnail for trusted links directly\r\n      createThumbnail(link, false);\r\n    }\r\n  })\r\n\r\n  function createThumbnail(link, isUntrusted) {\r\n    const thumbnail = document.createElement(\"div\");\r\n    thumbnail.classList.add(\"clickable-thumbnail\");\r\n\r\n    const img = document.createElement(\"img\");\r\n    img.src = link.href;\r\n\r\n    img.onload = () => {\r\n      thumbnail.appendChild(img);\r\n      link.parentNode.insertBefore(thumbnail, link.nextSibling);\r\n      thumbnailLinks.push({ link, imgSrc: link.href });\r\n      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.scrollMessagesToBottom)(containerType);\r\n    }\r\n\r\n    img.onerror = () => {\r\n      console.error(\"Failed to load image:\", link.href);\r\n      link.classList.add(\"skipped\");\r\n    }\r\n\r\n    // Only show thumbnail on click for untrusted domains\r\n    if (isUntrusted) {\r\n      // Check if thumbnail already created, avoid creating again\r\n      if (!link.querySelector(\".clickable-thumbnail\")) {\r\n        link.addEventListener(\"click\", e => {\r\n          // Only create thumbnail once\r\n          if (!link.querySelector(\".clickable-thumbnail\")) {\r\n            thumbnail.appendChild(img); // Add image to thumbnail on user confirmation\r\n            link.parentNode.insertBefore(thumbnail, link.nextSibling);\r\n          }\r\n        })\r\n      }\r\n    } else {\r\n      // Show the thumbnail directly for trusted domains\r\n      thumbnail.appendChild(img);\r\n      link.parentNode.insertBefore(thumbnail, link.nextSibling);\r\n    }\r\n\r\n    thumbnail.addEventListener(\"click\", e => {\r\n      e.stopPropagation();\r\n      bigImage = createBigImage(img.src);\r\n      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.triggerTargetElement)(bigImage, \"show\");\r\n      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)(\"show\");\r\n    })\r\n  }\r\n}\r\n\r\n// Function to create a big image with a dimming layer\r\nfunction createBigImage(src) {\r\n  const bigImage = document.createElement('img');\r\n  bigImage.src = src;\r\n  bigImage.classList.add('scaled-thumbnail');\r\n  document.body.appendChild(bigImage);\r\n\r\n  const removeBigImage = (bigImage) => {\r\n    // Hide the big image and check if there are any popup panels open before hiding the dimming element\r\n    (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.triggerTargetElement)(bigImage, 'hide');\r\n\r\n    if (!document.querySelector('.popup-panel')) {\r\n      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.triggerDimmingElement)('hide');\r\n    }\r\n    // Remove all event listeners\r\n    (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.removeBigImageEventListeners)();\r\n  }\r\n\r\n  // Close when clicking outside the big image\r\n  bigImageEvents.unfocusedClick = function (event) {\r\n    if (!bigImage.contains(event.target)) { // If clicked outside the image\r\n      bigImage.remove(); // Directly remove the image from the DOM\r\n      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.removeBigImageEventListeners)(); // Clean up event listeners\r\n    }\r\n  }\r\n\r\n  document.addEventListener('click', bigImageEvents.unfocusedClick);\r\n\r\n  // Attach a keydown event listener for big image to close by ESC or Space and navigate with Arrow keys\r\n  bigImageEvents.keydown = function (event) {\r\n    if (event.code === 'Escape' || event.code === 'Space') { // Hide on ESC or Space\r\n      event.preventDefault(); // Prevent default scrolling behavior for Space\r\n      removeBigImage(bigImage);\r\n    } else if (event.code === 'ArrowLeft') {\r\n      navigateImages(-1);\r\n    } else if (event.code === 'ArrowRight') {\r\n      navigateImages(1);\r\n    }\r\n  }\r\n\r\n  document.addEventListener('keydown', bigImageEvents.keydown);\r\n\r\n  // ZOOM AND MOVE-- START\r\n\r\n  // Set the initial zoom scale and scaling factor\r\n  let zoomScale = 1;\r\n  let scalingFactor = 0.1;\r\n\r\n  // Set up variables for dragging\r\n  let isDragging = false;\r\n  let startX = 0;\r\n  let startY = 0;\r\n  let translateX = -50; // Initial translation in percentage\r\n  let translateY = -50; // Initial translation in percentage\r\n\r\n  // Define the movement speed\r\n  const movementSpeed = 5;\r\n\r\n  // Function to handle zooming\r\n  bigImageEvents.wheel = function (event) {\r\n    // Determine the direction of the mouse wheel movement\r\n    const deltaY = event.deltaY;\r\n    const direction = deltaY < 0 ? 1 : -1;\r\n\r\n    // Update the zoom scale based on the direction and scaling factor\r\n    zoomScale += direction * scalingFactor * zoomScale;\r\n\r\n    // Clamp the zoom scale to a minimum of 1\r\n    zoomScale = Math.max(zoomScale, 1);\r\n\r\n    // Apply the new zoom scale and transform origin\r\n    bigImage.style.transform = `translate(${translateX}%, ${translateY}%) scale(${zoomScale})`;\r\n\r\n    // Prevent the default scrolling behavior\r\n    event.preventDefault();\r\n  };\r\n\r\n  // Function to update the image position smoothly\r\n  bigImageEvents.mousemove = function (event) {\r\n    if (isDragging) {\r\n      // Calculate the distance moved since the last mousemove event\r\n      const deltaX = (event.clientX - startX) / zoomScale * movementSpeed;\r\n      const deltaY = (event.clientY - startY) / zoomScale * movementSpeed;\r\n\r\n      // Update the translate values in percentages\r\n      translateX += (deltaX / bigImage.clientWidth) * 100;\r\n      translateY += (deltaY / bigImage.clientHeight) * 100;\r\n\r\n      // Apply the new translate values in percentages\r\n      bigImage.style.transform = `translate(${translateX}%, ${translateY}%) scale(${zoomScale})`;\r\n\r\n      // Update the start position\r\n      startX = event.clientX;\r\n      startY = event.clientY;\r\n    }\r\n  };\r\n\r\n  bigImageEvents.mousedown = function (event) {\r\n    const { button, clientX, clientY, target, ctrlKey } = event;\r\n    // Restrict LMB and RMB to image clicks only\r\n    if ((button === 0 || button === 2) && target !== bigImage) return;\r\n    let src = target.src; // Get the src from the clicked element\r\n\r\n    if (button === 0) { // Left Mouse Button (LMB)\r\n      ctrlKey ? window.open(src, \"_blank\") : navigateImages(-1);\r\n    } else if (button === 2) { // Right Mouse Button (RMB)\r\n      event.preventDefault();\r\n      if (ctrlKey) {\r\n        // Copy to clipboard and hide the big image\r\n        navigator.clipboard.writeText(src).catch(console.error);\r\n        removeBigImage(bigImage); // Close the big image after copying\r\n      } else {\r\n        navigateImages(1);\r\n      }\r\n    } else if (button === 1) { // Middle Mouse Button (MMB)\r\n      isDragging = true;\r\n      [startX, startY] = [clientX, clientY];\r\n    }\r\n  };\r\n\r\n  bigImageEvents.mouseup = function () {\r\n    isDragging = false; // Reset the dragging flag\r\n  };\r\n\r\n  // Add contextmenu listener to prevent right-click context menu\r\n  bigImageEvents.contextmenu = function (event) {\r\n    event.preventDefault(); // Prevent context menu from appearing\r\n  };\r\n\r\n  // Attach all event listeners\r\n  (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.addBigImageEventListeners)();\r\n\r\n  return bigImage;\r\n}\r\n\r\n// ZOOM AND MOVE-- END\r\n\r\n\r\n// Function to navigate between images within bounds\r\nfunction navigateImages(direction) {\r\n  const newIndex = currentImageIndex + direction;\r\n\r\n  // Ensure the new index stays within bounds\r\n  if (newIndex >= 0 && newIndex < thumbnailLinks.length) {\r\n    if (isChangingImage) {\r\n      return; // If an image change is already in progress, do nothing\r\n    }\r\n\r\n    isChangingImage = true; // Set the flag to indicate image change is in progress\r\n\r\n    // Update the bigImage with the new image URL\r\n    if (bigImage) {\r\n      bigImage.src = thumbnailLinks[newIndex].imgSrc;\r\n    }\r\n\r\n    // Set a timeout to reset the flag after a short delay\r\n    setTimeout(() => {\r\n      isChangingImage = false;\r\n    }, imageChangeDelay); // Adjust the delay duration as needed (e.g., 50 milliseconds)\r\n\r\n    // Update the current index\r\n    currentImageIndex = newIndex;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/image-converter.js?");

/***/ }),

/***/ "./src/modules/messages.js":
/*!*********************************!*\
  !*** ./src/modules/messages.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPersonalMessagesButton: () => (/* binding */ createPersonalMessagesButton)\n/* harmony export */ });\n/* harmony import */ var _image_converter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-converter.js */ \"./src/modules/image-converter.js\");\n/* harmony import */ var _video_converter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./video-converter.js */ \"./src/modules/video-converter.js\");\n/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons */ \"./src/modules/icons.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.js */ \"./src/modules/helpers.js\");\n/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./definitions.js */ \"./src/modules/definitions.js\");\n // image converter\r\n // video converter\r\n\r\n// icons\r\n\r\n\r\n// helpers && helpers definitions\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Define dynamic variables\r\nlet {\r\n  panelsEvents\r\n} = _definitions_js__WEBPACK_IMPORTED_MODULE_4__.state;\r\n\r\n// Function to create the button for opening personal messages\r\nfunction createPersonalMessagesButton(panel) {\r\n  // Create a new element with class 'personal-messages-button'\r\n  const showPersonalMessagesButton = document.createElement('div');\r\n  showPersonalMessagesButton.classList.add(\"empowerment-button\", \"personal-messages-button\");\r\n  showPersonalMessagesButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.personalMessagesSVG; // Add icon\r\n\r\n  // Create the small indicator for all message count\r\n  const allMessageIndicator = document.createElement('div');\r\n  allMessageIndicator.classList.add(\"message-count\", \"total-message-count\");\r\n  const personalMessages = JSON.parse(localStorage.getItem('personalMessages')) || {};\r\n  allMessageIndicator.textContent = Object.keys(personalMessages).length;\r\n  showPersonalMessagesButton.appendChild(allMessageIndicator);\r\n\r\n  // Create the small indicator for new message count\r\n  const newMessageIndicator = document.createElement('div');\r\n  newMessageIndicator.classList.add(\"message-count\", \"new-message-count\");\r\n\r\n  // Get the new messages count from localStorage or set to 0 if not present\r\n  let newMessagesCount = Number(localStorage.getItem('newMessagesCount')) || (localStorage.setItem('newMessagesCount', '0'), 0);\r\n\r\n  newMessageIndicator.textContent = newMessagesCount;\r\n\r\n  // Check the newMessagesCount value and set visibility\r\n  newMessageIndicator.style.visibility = newMessagesCount > 0 ? 'visible' : 'hidden'; // Set visibility based on count\r\n\r\n  showPersonalMessagesButton.appendChild(newMessageIndicator);\r\n\r\n  // Assign a title to the button\r\n  showPersonalMessagesButton.title = 'Show Personal Messages';\r\n\r\n  // Add a click event listener to the button\r\n  showPersonalMessagesButton.addEventListener('click', function () {\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.addPulseEffect)(showPersonalMessagesButton); // Add pulse effect\r\n    showPersonalMessagesPanel(); // Show the personal messages panel\r\n    const personalMessagesCount = Object.keys(JSON.parse(localStorage.getItem('personalMessages')) || {}).length;\r\n    // Open the personal messages panel only when there are messages present.\r\n    if (personalMessagesCount > 0) {\r\n      // Reset newMessagesCount in localStorage to 0 when opening the panel\r\n      localStorage.setItem('newMessagesCount', '0');\r\n      newMessagesCount = 0; // Reset the local variable\r\n      newMessageIndicator.textContent = newMessagesCount; // Update the displayed count\r\n    }\r\n  });\r\n\r\n  // Append the button to the existing panel\r\n  panel.appendChild(showPersonalMessagesButton);\r\n}\r\n\r\n// Find chat message by time in range and matching username\r\nasync function findGeneralChatMessage(targetTime, targetUsername, allowScroll) {\r\n  const parent = document.querySelector('.messages-content'); // Chat container\r\n  if (!parent) return null; // Return null if the container isn't found\r\n\r\n  // Convert time string \"[HH:MM:SS]\" to total seconds\r\n  const timeStringToSeconds = (str) =>\r\n    str.replace(/[\\[\\]]/g, '').split(':').reduce((acc, time, i) =>\r\n      acc + Number(time) * (60 ** (2 - i)), 0\r\n    );\r\n\r\n  const initialTimeValue = timeStringToSeconds(targetTime); // Target time in seconds\r\n\r\n  // Helper to find <p> elements by matching time and username\r\n  const findMatchingElement = (condition) =>\r\n    Array.from(parent.querySelectorAll('p')).find((p) => {\r\n      const timeElement = p.querySelector('.time'); // Get the child element with class 'time'\r\n      const usernameElement = p.querySelector('.username span[data-user]'); // Get the username element\r\n\r\n      if (timeElement && usernameElement) {\r\n        const currentTimeValue = timeStringToSeconds(timeElement.textContent.trim());\r\n        const usernameText = usernameElement.textContent.trim(); // Extract the text content of the username\r\n\r\n        // Check if the time and username match the conditions\r\n        return condition(currentTimeValue) && usernameText === targetUsername;\r\n      }\r\n      return false;\r\n    });\r\n\r\n  // 1. Try to find an exact match first\r\n  let foundElement = findMatchingElement(\r\n    (currentTimeValue) => currentTimeValue === initialTimeValue\r\n  );\r\n\r\n  // 2. If no exact match, search within ±10 seconds\r\n  if (!foundElement) {\r\n    foundElement = findMatchingElement(\r\n      (currentTimeValue) => Math.abs(currentTimeValue - initialTimeValue) <= 2\r\n    );\r\n  }\r\n\r\n  if (foundElement && allowScroll) {\r\n    await scrollMessagesToMiddle(parent, foundElement); // Call the extracted scrolling function\r\n  }\r\n\r\n  return foundElement || false; // Return found element or false if not found\r\n}\r\n\r\n// Find chat logs message by time in range and matching username\r\nasync function findChatLogsMessage(targetTime, targetUsername, allowScroll) {\r\n  const parent = document.querySelector('.chat-logs-container'); // Logs container\r\n  if (!parent) return null; // Return null if the container isn't found\r\n\r\n  // Convert time string \"[HH:MM:SS]\" to total seconds\r\n  const timeStringToSeconds = (str) =>\r\n    str.replace(/[\\[\\]]/g, '').split(':').reduce((acc, time, i) =>\r\n      acc + Number(time) * (60 ** (2 - i)), 0\r\n    );\r\n\r\n  const initialTimeValue = timeStringToSeconds(targetTime); // Target time in seconds\r\n\r\n  // Helper to find .message-item elements by matching time and username\r\n  const findMatchingElement = (condition) =>\r\n    Array.from(parent.querySelectorAll('.message-item')).find((messageItem) => {\r\n      const timeElement = messageItem.querySelector('.message-time'); // Get the child element with class 'message-time'\r\n      const usernameElement = messageItem.querySelector('.message-username'); // Get the username element\r\n\r\n      if (timeElement && usernameElement) {\r\n        const currentTimeValue = timeStringToSeconds(timeElement.textContent.trim());\r\n        const usernameText = usernameElement.textContent.trim(); // Extract the text content of the username\r\n\r\n        // Check if the time and username match the conditions\r\n        return condition(currentTimeValue) && usernameText === targetUsername;\r\n      }\r\n      return false;\r\n    });\r\n\r\n  // 1. Try to find an exact match first\r\n  let foundElement = findMatchingElement(\r\n    (currentTimeValue) => currentTimeValue === initialTimeValue\r\n  );\r\n\r\n  // 2. If no exact match, search within ±10 seconds\r\n  if (!foundElement) {\r\n    foundElement = findMatchingElement(\r\n      (currentTimeValue) => Math.abs(currentTimeValue - initialTimeValue) <= 2\r\n    );\r\n  }\r\n\r\n  if (foundElement && allowScroll) {\r\n    await scrollMessagesToMiddle(parent, foundElement); // Call the extracted scrolling function\r\n  }\r\n\r\n  return foundElement || false; // Return found element or false if not found\r\n}\r\n\r\n/**\r\n * Converts a given local time to Moscow time (UTC+3) based on the system's timezone.\r\n *\r\n * How it works:\r\n * 1. Gets the system's local timezone offset in minutes (positive if behind UTC).\r\n * 2. Converts the local offset to total minutes from UTC.\r\n * 3. Defines Moscow's fixed offset as UTC+3 (180 minutes).\r\n * 4. Calculates the difference between Moscow's offset and the local offset.\r\n * 5. Parses the input time and converts it into total minutes since midnight.\r\n * 6. Adjusts the time by the calculated difference.\r\n * 7. Ensures the result stays within the 24-hour format (wrap-around handling).\r\n * 8. Converts the result back to HH:MM:SS format and returns it.\r\n *\r\n * @param {string} time - The local time in \"HH:MM:SS\" format.\r\n * @returns {string} - The converted time in Moscow time (HH:MM:SS).\r\n */\r\nfunction calibrateToMoscowTime(time) {\r\n  // Get local timezone offset in minutes (positive if local is behind UTC)\r\n  const localOffsetMinutes = new Date().getTimezoneOffset();\r\n\r\n  // Convert local offset to total minutes from UTC (local time = UTC + localTotalOffset)\r\n  const localTotalOffset = -localOffsetMinutes;\r\n\r\n  // Moscow is UTC+3 (180 minutes)\r\n  const moscowOffset = 3 * 60; // 180 minutes\r\n\r\n  // Calculate the adjustment needed: Moscow offset - local offset\r\n  const diffMinutes = moscowOffset - localTotalOffset;\r\n\r\n  // Parse input time\r\n  const [hours, minutes, seconds] = time.split(':').map(Number);\r\n\r\n  // Convert input time to total minutes since 00:00\r\n  const totalInputMinutes = hours * 60 + minutes;\r\n\r\n  // Adjust by diff and wrap within a single day (1440 minutes)\r\n  let adjustedMinutes = totalInputMinutes + diffMinutes;\r\n  adjustedMinutes = ((adjustedMinutes % 1440) + 1440) % 1440; // Ensure positive\r\n\r\n  // Convert back to hours and minutes\r\n  const adjustedHours = Math.floor(adjustedMinutes / 60);\r\n  const adjustedMins = adjustedMinutes % 60;\r\n\r\n  // Format the result with original seconds\r\n  return `${adjustedHours.toString().padStart(2, '0')}:` +\r\n    `${adjustedMins.toString().padStart(2, '0')}:` +\r\n    `${seconds.toString().padStart(2, '0')}`;\r\n}\r\n\r\n/**\r\n * Removes messages from the DOM and updates localStorage based on the removal type.\r\n * @param {HTMLElement} messageElement - The message element to remove.\r\n * @param {string} removalType - The type of removal: 'single', 'all', or 'from'.\r\n */\r\nfunction removeMessage(messageElement, removalType = 'single') {\r\n  // Extract time and username from the message element\r\n  const time = messageElement.querySelector('.message-time').textContent;\r\n  const username = messageElement.querySelector('.message-username').textContent;\r\n\r\n  // Retrieve localStorage personalMessagesBackup data\r\n  let backupData = JSON.parse(localStorage.getItem('personalMessagesBackup')) || {};\r\n\r\n  // If backup data does not exist, create it by copying original data from personalMessages\r\n  if (Object.keys(backupData).length === 0) {\r\n    const originalData = JSON.parse(localStorage.getItem('personalMessages')) || {};\r\n    backupData = { ...originalData }; // Make a copy of the original data\r\n    localStorage.setItem('personalMessagesBackup', JSON.stringify(backupData)); // Save backupData to localStorage\r\n  }\r\n\r\n  // Work with backupData (make a copy to modify)\r\n  let modifiedBackupData = { ...backupData };\r\n\r\n  if (removalType === 'all') {\r\n    // Remove all messages from the same user\r\n    document.querySelectorAll('.message-item').forEach((element) => {\r\n      const elementUsername = element.querySelector('.message-username').textContent;\r\n      if (elementUsername === username) {\r\n        element.remove(); // Remove the DOM element\r\n\r\n        // Remove the corresponding entry from backupData\r\n        const elementTime = element.querySelector('.message-time').textContent;\r\n        const messageKey = `[${elementTime}]_${elementUsername}`;\r\n        delete modifiedBackupData[messageKey];\r\n      }\r\n    });\r\n  } else if (removalType === 'from') {\r\n    // Get all message elements\r\n    const messageElements = Array.from(document.querySelectorAll('.message-item'));\r\n\r\n    // Find the index of the current message element\r\n    const currentIndex = messageElements.indexOf(messageElement);\r\n\r\n    // Iterate through messages starting from the current message till the end\r\n    for (let i = currentIndex; i < messageElements.length; i++) {\r\n      const element = messageElements[i];\r\n      const elementUsername = element.querySelector('.message-username').textContent;\r\n\r\n      if (elementUsername === username) {\r\n        // Remove the DOM element\r\n        element.remove();\r\n\r\n        // Remove the corresponding entry from backupData\r\n        const elementTime = element.querySelector('.message-time').textContent;\r\n        const messageKey = `[${elementTime}]_${elementUsername}`;\r\n        delete modifiedBackupData[messageKey];\r\n      }\r\n    }\r\n  } else {\r\n    // Default: Remove only the specific message (single)\r\n    const messageKey = `[${time}]_${username}`;\r\n    if (modifiedBackupData[messageKey]) {\r\n      delete modifiedBackupData[messageKey]; // Remove from backupData\r\n      messageElement.remove(); // Remove the DOM element\r\n    }\r\n  }\r\n\r\n  // Update localStorage with the modified backupData\r\n  localStorage.setItem('personalMessagesBackup', JSON.stringify(modifiedBackupData));\r\n\r\n  // Update the total message count displayed in the personal messages button\r\n  const messagesCountElement = document.querySelector('.personal-messages-button .total-message-count');\r\n  if (messagesCountElement) {\r\n    messagesCountElement.textContent = Object.keys(modifiedBackupData).length;\r\n  }\r\n}\r\n\r\n// Update the message count displayed in the personal messages button\r\nfunction updateMessageCount() {\r\n  const personalMessagesCount = Object.keys(JSON.parse(localStorage.getItem('personalMessages') || '{}')).length;\r\n  const messagesCountElement = document.querySelector('.personal-messages-button .total-message-count');\r\n  messagesCountElement.textContent = personalMessagesCount;\r\n}\r\n\r\n// Function to display the personal messages panel\r\nasync function showPersonalMessagesPanel() {\r\n  // Check if the panel already exists\r\n  const existingPanel = document.querySelector('.cached-messages-panel');\r\n  if (existingPanel) {\r\n    existingPanel.remove(); // Remove the settings panel\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n    return; // Return immediately to prevent further execution\r\n  }\r\n\r\n  // Flag to track if this is the first time the panel is being run\r\n  let isFirstPanelRun = true;\r\n  // Flag to track if messages are being imported\r\n  let isMessagesImport = false;\r\n  // Update the message count after panel load to reset the value if messages were not saved\r\n  updateMessageCount();\r\n  // Remove 'personalMessagesBackup' from localStorage if it exists\r\n  if (localStorage.getItem('personalMessagesBackup')) localStorage.removeItem('personalMessagesBackup');\r\n  // Remove any previous panel before creating a new one\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.removePreviousPanel)();\r\n\r\n  // Reset the new messages indicator to 0\r\n  const newMessagesCountElement = document.querySelector('.personal-messages-button .new-message-count');\r\n  if (newMessagesCountElement) newMessagesCountElement.textContent = '0';\r\n  newMessagesCountElement.style.visibility = 'hidden';\r\n  // Remove the localStorage key for new personal messages after opening the messages panel (always)\r\n  localStorage.removeItem('newMessagesCount');\r\n\r\n  // Function to get messages from localStorage\r\n  function getMessages() {\r\n    const cachedMessagesData = localStorage.getItem('personalMessages');\r\n    // Initialize messages by parsing fetched data or setting as empty object\r\n    return JSON.parse(cachedMessagesData) || {};\r\n  }\r\n\r\n  let messages = getMessages();\r\n\r\n  // Create a container div with class 'cached-messages-panel'\r\n  const cachedMessagesPanel = document.createElement('div');\r\n  cachedMessagesPanel.className = 'cached-messages-panel popup-panel';\r\n\r\n  // Create a container div for the panel header\r\n  const panelHeaderContainer = document.createElement('div');\r\n  panelHeaderContainer.className = 'panel-header';\r\n\r\n  // Create the search input container and append it to the panel header\r\n  const messagesSearchContainer = document.createElement('div');\r\n  messagesSearchContainer.className = 'search-for-personal-messages';\r\n\r\n  // Create the input field for searching personal messages\r\n  const messagesSearchInput = document.createElement('input');\r\n  messagesSearchInput.className = 'personal-messages-search-input';\r\n  messagesSearchInput.type = 'search';\r\n\r\n  // Append the search input to the search container\r\n  messagesSearchContainer.appendChild(messagesSearchInput);\r\n\r\n  // Create a container div with class 'panel-control-buttons'\r\n  const panelControlButtons = document.createElement('div');\r\n  panelControlButtons.className = 'panel-control-buttons';\r\n\r\n  // Create a save button with the provided SVG icon\r\n  const saveMessagesButton = document.createElement('div');\r\n  saveMessagesButton.className = 'large-button panel-header-save-button';\r\n  saveMessagesButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.saveSVG;\r\n  saveMessagesButton.title = 'Save messages';\r\n  saveMessagesButton.style.opacity = \"0\";\r\n\r\n  // Handle the save button click to restore the backup\r\n  saveMessagesButton.addEventListener('click', () => {\r\n    // Retrieve the backup and original data from localStorage\r\n    const backupData = localStorage.getItem('personalMessagesBackup');\r\n    const originalData = localStorage.getItem('personalMessages');\r\n\r\n    // Check if both backup and original data exist and if they are different\r\n    const bothDataExist = backupData && originalData;\r\n    const hasDataChanged = bothDataExist && originalData !== backupData;\r\n\r\n    // If no backup or original data exists, do nothing\r\n    if (!bothDataExist) return;\r\n\r\n    // Ask user for confirmation if data has changed and it's not the first run\r\n    if (hasDataChanged && !isFirstPanelRun) {\r\n      const userConfirmed = window.confirm(\"Do you want to apply changes?\");\r\n\r\n      // If user confirms, restore the backup data\r\n      if (userConfirmed) {\r\n        localStorage.setItem('personalMessages', backupData);\r\n        localStorage.removeItem('personalMessagesBackup');\r\n        saveMessagesButton.style.setProperty('display', 'none', 'important');\r\n        saveMessagesButton.style.opacity = '0'; // Hide the save button after saving\r\n        // Wait for the opacity transition to finish before hiding the element\r\n        saveMessagesButton.addEventListener('transitionend', function () {\r\n          // After the transition, hide the button by setting display to 'none'\r\n          saveMessagesButton.style.display = 'none'; // Now you can safely hide the element\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  // Create an import button for messages with the provided SVG icon\r\n  const importMessagesButton = document.createElement('div');\r\n  importMessagesButton.className = \"large-button panel-header-import-button\";\r\n  importMessagesButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.importSVG;\r\n  importMessagesButton.title = 'Import messages';\r\n\r\n  importMessagesButton.addEventListener('click', () => {\r\n    isMessagesImport = true;\r\n    const input = document.createElement('input');\r\n    input.type = 'file';\r\n    input.accept = '.json';\r\n\r\n    input.addEventListener('change', (event) => {\r\n      const file = event.target.files[0];\r\n      if (file) {\r\n        const reader = new FileReader();\r\n        reader.onload = async () => {\r\n          try {\r\n            const importedMessages = JSON.parse(reader.result);\r\n            const existingMessages = JSON.parse(localStorage.getItem('personalMessages') || '{}');\r\n\r\n            // Merge existing and imported messages, ensuring no duplicates by date key\r\n            const mergedMessages = {\r\n              ...existingMessages,\r\n              ...importedMessages\r\n            };\r\n\r\n            // Sort the merged messages with cleaned time for sorting but without modifying the original time\r\n            const cleanedMergedMessages = Object.fromEntries(\r\n              Object.entries(mergedMessages)\r\n                .sort(([, valueA], [, valueB]) => {\r\n                  // Temporarily clean the time for sorting purposes (no change to original time)\r\n                  const cleanedTimeA = valueA.time.replace(/[[\\]]/g, '');\r\n                  const cleanedTimeB = valueB.time.replace(/[[\\]]/g, '');\r\n\r\n                  // Combine date and cleaned time for comparison\r\n                  const dateTimeA = `${valueA.date} ${cleanedTimeA}`;\r\n                  const dateTimeB = `${valueB.date} ${cleanedTimeB}`;\r\n\r\n                  // Convert to Date objects for sorting\r\n                  return new Date(dateTimeA) - new Date(dateTimeB);\r\n                })\r\n            );\r\n\r\n            // Store the merged messages back in localStorage (time remains unchanged with square brackets)\r\n            localStorage.setItem('personalMessages', JSON.stringify(cleanedMergedMessages));\r\n\r\n            updateMessageCount(); // Update the message count after import\r\n\r\n            // Load imported messages\r\n            const messages = getMessages();\r\n            await loadMessages(messages);\r\n          } catch (error) {\r\n            alert('Failed to import messages. The file may be corrupted.');\r\n          }\r\n        };\r\n        reader.readAsText(file);\r\n      }\r\n    });\r\n\r\n    input.click();\r\n  });\r\n\r\n  // Create an export button for messages with the provided SVG icon\r\n  const exportMessagesButton = document.createElement('div');\r\n  exportMessagesButton.className = \"large-button panel-header-export-button\";\r\n  exportMessagesButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.exportSVG;\r\n  exportMessagesButton.title = 'Export messages';\r\n\r\n  // Add event listener for exporting messages\r\n  exportMessagesButton.addEventListener('click', () => {\r\n    const messages = localStorage.getItem('personalMessages');\r\n    if (messages && messages !== '{}') {\r\n      const currentDate = new Intl.DateTimeFormat('en-CA').format(new Date()); // Get the current date in YYYY-MM-DD format\r\n\r\n      // Parse the JSON string to an object for formatting\r\n      const messagesObject = JSON.parse(messages);\r\n\r\n      // Convert the object back to a formatted JSON string with indentation\r\n      const formattedMessages = JSON.stringify(messagesObject, null, 2); // Indented JSON\r\n\r\n      const blob = new Blob([formattedMessages], { type: 'application/json' });\r\n      const link = document.createElement('a');\r\n      link.href = URL.createObjectURL(blob);\r\n      link.download = `Personal_Messages_${currentDate}.json`; // Use currentDate for file name\r\n      link.click();\r\n    } else {\r\n      alert('No messages to export.');\r\n    }\r\n  });\r\n\r\n  // Create a copy personal messages button element\r\n  const copyPersonalMessagesButton = document.createElement('div');\r\n  copyPersonalMessagesButton.className = \"large-button panel-header-copy-button\";\r\n  // Set the inner HTML of the copy personal messages button element with the clipboard SVG\r\n  copyPersonalMessagesButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.clipboardSVG;\r\n  copyPersonalMessagesButton.title = 'Copy Personal Messages';\r\n\r\n  // Event listener to copy the text content of the messages container\r\n  copyPersonalMessagesButton.addEventListener('click', () => {\r\n    addJumpEffect(copyPersonalMessagesButton, 0, 0);\r\n    const textContent = Array.from(document.querySelector('.messages-container').children)\r\n      .filter(node => {\r\n        const style = window.getComputedStyle(node);\r\n        // Ignore hidden messages with contentVisibility 'hidden' or display 'none'\r\n        return style.contentVisibility !== 'hidden' && style.display !== 'none';\r\n      })\r\n      .map(node => node.classList.contains('date-item') ? node.textContent.trim() :\r\n        [node.querySelector('.message-time'), node.querySelector('.message-username'), node.querySelector('.message-text')]\r\n          .map(el => el?.textContent.trim()).filter(Boolean).join(' '))\r\n      .filter(Boolean).join(' \\n');\r\n\r\n    // Check if there's content to copy\r\n    if (textContent.trim()) {\r\n      navigator.clipboard.writeText(textContent)\r\n        .then(() => addJumpEffect(copyPersonalMessagesButton, 0, 0))\r\n        .catch(console.error);\r\n    } else {\r\n      alert('No messages to copy.');\r\n    }\r\n  });\r\n\r\n  // Create a clear cache button with the provided SVG icon\r\n  const clearCacheButton = document.createElement('div');\r\n  clearCacheButton.className = \"large-button panel-header-clear-button\";\r\n  clearCacheButton.title = 'Clear personal messages';\r\n  clearCacheButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.trashSVG;\r\n\r\n  // Add a click event listener to the clear cache button\r\n  clearCacheButton.addEventListener('click', () => {\r\n    // Set the flag to true when clear messages is initiated\r\n    isMessagesImport = true;\r\n    // Check if there are any messages before attempting to clear\r\n    const messages = JSON.parse(localStorage.getItem('personalMessages') || '{}');\r\n    if (Object.keys(messages).length === 0) {\r\n      alert('No messages to delete.');\r\n      return; // Exit the function if no messages exist\r\n    }\r\n    // Clear the messages container\r\n    messagesContainer.innerHTML = null;\r\n\r\n    // Set the 'personalMessages' key in localStorage to an empty object\r\n    localStorage.setItem('personalMessages', JSON.stringify({}));\r\n\r\n    // Fade out the cached messages panel when the clear cache button is clicked\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(cachedMessagesPanel, 'hide');\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n\r\n    // Update the message count displayed in the personal messages button\r\n    const messagesCountElement = document.querySelector('.personal-messages-button .total-message-count');\r\n    if (messagesCountElement) messagesCountElement.textContent = '0';\r\n  });\r\n\r\n  // Create a close button with the provided SVG icon\r\n  const closePanelButton = document.createElement('div');\r\n  closePanelButton.className = \"large-button panel-header-close-button\";\r\n  closePanelButton.title = 'Close panel';\r\n  closePanelButton.innerHTML = _icons__WEBPACK_IMPORTED_MODULE_2__.closeSVG;\r\n\r\n  // Add a click event listener to the close panel button\r\n  closePanelButton.addEventListener('click', () => {\r\n    // Fade out the cached messages panel when the close button is clicked\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(cachedMessagesPanel, 'hide');\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n  });\r\n\r\n  // Append the search container to the panel header container\r\n  panelHeaderContainer.appendChild(messagesSearchContainer);\r\n\r\n  // Append buttons to the panel header container\r\n  panelControlButtons.appendChild(saveMessagesButton);\r\n  panelControlButtons.appendChild(importMessagesButton);\r\n  panelControlButtons.appendChild(exportMessagesButton);\r\n  panelControlButtons.appendChild(copyPersonalMessagesButton);\r\n  panelControlButtons.appendChild(clearCacheButton);\r\n  panelControlButtons.appendChild(closePanelButton);\r\n\r\n  // Append the panel control buttons element inside the panel header container\r\n  panelHeaderContainer.appendChild(panelControlButtons);\r\n\r\n  // Append the header to the cached messages panel\r\n  cachedMessagesPanel.appendChild(panelHeaderContainer);\r\n\r\n  // Create a container for the messages\r\n  const messagesContainer = document.createElement('div');\r\n  messagesContainer.className = 'messages-container';\r\n\r\n  function attachMutationObserver() {\r\n    // Set up MutationObserver to monitor removal of child elements\r\n    const observer = new MutationObserver(mutationsList => {\r\n      // Skip the observer actions if messages are being imported\r\n      if (isMessagesImport) return;\r\n\r\n      // Check if any node was removed from the messages container\r\n      const removedNode = mutationsList.find(mutation => mutation.type === 'childList' && mutation.removedNodes.length > 0);\r\n\r\n      if (removedNode && saveMessagesButton.style.opacity === '0') {\r\n        isFirstPanelRun = false;\r\n\r\n        // Ensure button is visible and part of the layout before applying opacity\r\n        saveMessagesButton.style.visibility = 'visible'; // Make the button interactable\r\n        saveMessagesButton.style.display = 'flex'; // Set display to flex to reveal it\r\n        saveMessagesButton.offsetHeight; // Ensure styles are applied before transition starts\r\n\r\n        // Apply opacity to fade the button in\r\n        saveMessagesButton.style.opacity = '1';\r\n        saveMessagesButton.style.transition = 'opacity 0.5s ease'; // Apply smooth fade-in transition\r\n      }\r\n    });\r\n\r\n    // Configure the observer to watch for child node removals\r\n    observer.observe(messagesContainer, {\r\n      childList: true, // Watch for changes to the children\r\n      subtree: true // Also monitor all descendants of the messagesContainer\r\n    });\r\n  }\r\n\r\n  let lastUsername = null; // Store the last username processed\r\n  let pingCheckCounter = 0; // Initialize a counter\r\n  let maxPingChecks = 100; // Set the limit to 100\r\n  let pingMessages = false; // Initialize pingMessages as false\r\n  let lastDate = null; // Store the last processed date\r\n\r\n  // Create an array to store message elements for later appending\r\n  const messageElements = [];\r\n\r\n  // Define messageColors and timeColors inside the loop\r\n  const timeColors = {\r\n    private: 'coral',\r\n    mention: 'darkseagreen'\r\n  };\r\n\r\n  const messageColors = {\r\n    private: 'coral',\r\n    mention: 'lightsteelblue',\r\n    default: 'slategray' // Default color if type is not private or mention\r\n  };\r\n\r\n  // Load messages on initial panel open\r\n  async function loadMessages(messages) {\r\n    messagesContainer.children.length && messagesContainer.replaceChildren();\r\n    // Loop through the messages and create elements\r\n    Object.entries(messages).forEach(([, { time, date, username, usernameColor, message, type, userId }]) => {\r\n      // If the current date is different from the last processed one, create a new date-item\r\n      if (lastDate !== date) {\r\n        const dateItem = document.createElement('div');\r\n        dateItem.className = 'date-item';\r\n        // show \"Today\" if date matches\r\n        dateItem.textContent = date === _definitions_js__WEBPACK_IMPORTED_MODULE_4__.today ? 'Today ⏳' : `${date} 📅`;\r\n        dateItem.dataset.date = date; // Store the date in a data attribute\r\n        messagesContainer.appendChild(dateItem); // Append the date-item to the container\r\n        lastDate = date; // Update the last processed date\r\n      }\r\n\r\n      // Create a message-item for the current message\r\n      const messageElement = document.createElement('div');\r\n      messageElement.className = 'message-item';\r\n\r\n      // Add margin-top if this is the first message of a new username group\r\n      if (username !== lastUsername) {\r\n        messageElement.style.marginTop = '0.6em';\r\n        lastUsername = username; // Update the lastUsername\r\n      }\r\n\r\n      // Remove square brackets from the time string\r\n      const formattedTime = time.replace(/[\\[\\]]/g, '').trim();\r\n\r\n      // Create time, username, and message elements\r\n      const timeElement = document.createElement('span');\r\n      timeElement.className = 'message-time';\r\n      timeElement.textContent = formattedTime;\r\n      timeElement.title = `Moscow Time: ${calibrateToMoscowTime(formattedTime)}`;\r\n      timeElement.style.color = timeColors[type] || 'slategray';\r\n\r\n      // Add click event listener for \"mention\" and \"private\" types\r\n      if (type === 'mention' || type === 'private') {\r\n        const hoverColor = type === 'mention' ? 'lightgreen' : 'peachpuff';\r\n        timeElement.addEventListener('mouseover', () => { timeElement.style.color = hoverColor; });\r\n        timeElement.addEventListener('mouseout', () => { timeElement.style.color = timeColors[type]; });\r\n        timeElement.addEventListener('click', (event) => {\r\n          if (event.ctrlKey) {\r\n            removeMessage(messageElement, 'from');\r\n            return; // Exit the function to prevent opening the chatlog\r\n          }\r\n          if (type === 'mention') {\r\n            const url = `https://klavogonki.ru/chatlogs/${date}.html#${calibrateToMoscowTime(formattedTime)}`;\r\n            window.open(url, '_blank', 'noopener,noreferrer');\r\n          }\r\n        });\r\n      }\r\n\r\n      const usernameElement = document.createElement('span');\r\n      usernameElement.className = 'message-username';\r\n      usernameElement.textContent = username;\r\n      usernameElement.style.color = usernameColor;\r\n\r\n      // Add click event only if userId is defined\r\n      usernameElement.addEventListener('click', (event) => {\r\n        // Remove all messages on Ctrl + LMB click for the same username\r\n        if (event.ctrlKey) {\r\n          removeMessage(messageElement, 'all');\r\n          return;\r\n        }\r\n        if (userId) { // Check if userId is defined\r\n          const url = `https://klavogonki.ru/u/#/${userId}/`; // Construct the user profile URL\r\n          window.open(url, '_blank', 'noopener,noreferrer'); // Open in a new tab\r\n        } else {\r\n          addShakeEffect(usernameElement); // Call the shake effect if userId is not defined\r\n        }\r\n      });\r\n\r\n      const messageTextElement = document.createElement('span');\r\n      messageTextElement.className = 'message-text';\r\n\r\n      // Replace smiley codes with <img> tags, and then wrap links with <a> tags\r\n      messageTextElement.innerHTML = message\r\n        // Replace smiley codes like :word: with <img> tags\r\n        .replace(/:(?=\\w*[a-zA-Z])(\\w+):/g,\r\n          (_, word) => `<img src=\"/img/smilies/${word}.gif\" alt=\":${word}:\" title=\":${word}:\" class=\"smile\">`\r\n        )\r\n        // Wrap http and https links with <a> tags\r\n        .replace(/(https?:\\/\\/[^\\s]+)/gi,\r\n          (url) => `<a href=\"${url}\" target=\"_blank\" rel=\"noopener noreferrer\">${url}</a>`\r\n        );\r\n\r\n      // Add click event listener for the messageTextElement\r\n      messageTextElement.addEventListener('click', async function (event) {\r\n        // Remove single message on Ctrl + LMB click for the same username\r\n        if (event.ctrlKey) {\r\n          removeMessage(messageElement, 'single');\r\n          return;\r\n        }\r\n\r\n        // Call the findGeneralChatMessage function to search for the general chat message by time in range and username\r\n        const foundGeneralChatMessage = await findGeneralChatMessage(time, username, true);\r\n        if (foundGeneralChatMessage) {\r\n          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(cachedMessagesPanel, 'hide');\r\n          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n        } else {\r\n          let previousElement = messageTextElement.parentElement.previousElementSibling;\r\n          while (previousElement && !previousElement.classList.contains('date-item')) {\r\n            previousElement = previousElement.previousElementSibling;\r\n          }\r\n          if (previousElement) {\r\n            await showChatLogsPanel(previousElement.dataset.date);\r\n            const calibratedMoscowTime = calibrateToMoscowTime(formattedTime);\r\n            // Call the findChatLogsMessage function to search for the chat logs message by time in range and username\r\n            requestAnimationFrame(async () => {\r\n              setTimeout(async () => {\r\n                // find chat messge if not found close the panel\r\n                const foundChatLogsMessage = await findChatLogsMessage(calibratedMoscowTime, username, true);\r\n                if (!foundChatLogsMessage) {\r\n                  const chatLogsPanel = document.querySelector('.chat-logs-panel'); // Get the chat logs panel\r\n                  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(chatLogsPanel, 'hide'); // Hide the chat logs panel\r\n                  showPersonalMessagesPanel(); // Show the personal messages panel again\r\n                }\r\n              }, 500); // Adjust the delay as needed\r\n            });\r\n          }\r\n        }\r\n      });\r\n\r\n      // Store elements for (pingable messages) colorization after all processing\r\n      const messageData = {\r\n        messageTextElement,\r\n        time,\r\n        username,\r\n        type\r\n      };\r\n\r\n      // Add messageData to the array for later processing\r\n      messageElements.push(messageData);\r\n\r\n      // Append time, username, and message to the message element\r\n      messageElement.appendChild(timeElement);\r\n      messageElement.appendChild(usernameElement);\r\n      messageElement.appendChild(messageTextElement);\r\n\r\n      // Append the message element to the messages container\r\n      messagesContainer.appendChild(messageElement);\r\n    });\r\n\r\n    requestAnimationFrame(() => {\r\n      (0,_image_converter_js__WEBPACK_IMPORTED_MODULE_0__.convertImageLinksToImage)('personalMessages');\r\n      (0,_video_converter_js__WEBPACK_IMPORTED_MODULE_1__.convertVideoLinksToPlayer)('personalMessages');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processEncodedLinks)('personalMessages'); // Decodes links within the personal messages section.\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.highlightMentionWords)('personalMessages');\r\n      messagesContainer.scrollTop = messagesContainer.scrollHeight; // Scroll after next repaint\r\n      attachMutationObserver();\r\n      setTimeout(() => { isMessagesImport = false; }, 500);\r\n    });\r\n\r\n    // Process the colorization logic in reverse order\r\n    messageElements.reverse().forEach(async ({ messageTextElement, time, username, type }) => {\r\n      if (pingCheckCounter < maxPingChecks) {\r\n        pingMessages = await findGeneralChatMessage(time, username, false);\r\n        pingCheckCounter++; // Increment the counter\r\n\r\n        if (pingCheckCounter >= maxPingChecks) {\r\n          pingMessages = false;\r\n          console.log(\"Reached maximum ping checks, resetting pingMessages.\");\r\n        }\r\n      }\r\n\r\n      // Colorize the messageTextElement accordingly (Pingable messages)\r\n      messageTextElement.style.color =\r\n        pingMessages && type === 'mention' ? 'lightgreen' :\r\n          pingMessages && type === 'private' ? 'lemonchiffon' :\r\n            messageColors[type] || 'slategray';\r\n    });\r\n  }\r\n\r\n  // Assuming this code is within an async function\r\n  await loadMessages(messages);\r\n\r\n  // Append the messages container to the cached messages panel\r\n  cachedMessagesPanel.appendChild(messagesContainer);\r\n\r\n  // Append the cached messages panel to the body\r\n  document.body.appendChild(cachedMessagesPanel);\r\n\r\n  // Create and append scroll buttons\r\n  const { scrollButtonsContainer } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.createScrollButtons)(messagesContainer);\r\n  cachedMessagesPanel.appendChild(scrollButtonsContainer);\r\n\r\n  // Fade in the cached messages panel\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(cachedMessagesPanel, 'show');\r\n  // Show the dimming background\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('show');\r\n\r\n  // Add click event listener to clear the search input by LMB click with Ctrl key pressed\r\n  messagesSearchInput.addEventListener('click', () => _helpers_js__WEBPACK_IMPORTED_MODULE_3__.isCtrlKeyPressed && (messagesSearchInput.value = ''));\r\n\r\n  // Event listener to handle input search for matching personal messages\r\n  // It searches through messages grouped by date and displays the corresponding date\r\n  // Only if there are matching messages in that group.\r\n  messagesSearchInput.addEventListener('input', () => {\r\n    const query = messagesSearchInput.value.toLowerCase().replace(/_/g, ' ');\r\n\r\n    messagesContainer.querySelectorAll('.date-item').forEach(dateEl => {\r\n      let showDateForGroup = false;\r\n      let nextEl = dateEl.nextElementSibling;\r\n\r\n      // Iterate through messages in the current group (until the next date item)\r\n      while (nextEl && !nextEl.classList.contains('date-item')) {\r\n        const match = (nextEl.querySelector('.message-time')?.textContent.toLowerCase().replace(/_/g, ' ') + ' ' +\r\n          nextEl.querySelector('.message-username')?.textContent.toLowerCase().replace(/_/g, ' ') + ' ' +\r\n          nextEl.querySelector('.message-text')?.textContent.toLowerCase().replace(/_/g, ' ')).includes(query);\r\n\r\n        // Toggle visibility based on match using content visibility and font size\r\n        nextEl.style.contentVisibility = match ? 'visible' : 'hidden';\r\n        // Set font size to 0 for hidden messages to maintain layout or remove the font size property\r\n        nextEl.style.fontSize = match ? '' : '0';\r\n\r\n        showDateForGroup = showDateForGroup || match; // Show date if any match found in the group\r\n\r\n        nextEl = nextEl.nextElementSibling;\r\n      }\r\n\r\n      dateEl.style.display = showDateForGroup ? '' : 'none'; // Show or hide the date based on the match results in the group\r\n    });\r\n  });\r\n\r\n  // Focus on the search input using requestAnimationFrame\r\n  function focusOnSearchField() { requestAnimationFrame(function () { messagesSearchInput.focus(); }); } focusOnSearchField();\r\n\r\n  // Define the event handler function for personal messages panel\r\n  panelsEvents.handlePersonalMessagesKeydown = (event) => { // Assign the function to the object\r\n    if (event.key === 'Escape') {\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerTargetElement)(cachedMessagesPanel, 'hide');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.triggerDimmingElement)('hide');\r\n      document.removeEventListener('keydown', panelsEvents.handlePersonalMessagesKeydown); // Remove the event listener\r\n    }\r\n  };\r\n\r\n  // Attach the event listener\r\n  document.addEventListener('keydown', panelsEvents.handlePersonalMessagesKeydown);\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/messages.js?");

/***/ }),

/***/ "./src/modules/notifications.js":
/*!**************************************!*\
  !*** ./src/modules/notifications.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStaticNotification: () => (/* binding */ createStaticNotification),\n/* harmony export */   showUserAction: () => (/* binding */ showUserAction)\n/* harmony export */ });\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./definitions */ \"./src/modules/definitions.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"./src/modules/helpers.js\");\n/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tooltip */ \"./src/modules/tooltip.js\");\n// definitions\r\n\r\n\r\n// helpers\r\n\r\n\r\n// tooltip\r\n\r\n\r\n// Creates the action icon element\r\nfunction createActionIcon(iconType) {\r\n  const actionIcon = document.createElement('div');\r\n  actionIcon.classList.add('action-icon');\r\n  actionIcon.style.margin = '0 4px';\r\n  actionIcon.style.setProperty('border', 'none', 'important');\r\n  actionIcon.innerHTML = iconType;\r\n  return actionIcon;\r\n}\r\n\r\n// Function to create and display a static notification\r\nfunction createStaticNotification(user, iconType, time, presence, containerType) {\r\n  // Define a mapping for container types to their respective selectors\r\n  const containerSelectors = {\r\n    generalChat: '.messages-content div', // For general chat notifications\r\n    cachePanel: '.fetched-users .action-log' // For cache notifications\r\n  };\r\n\r\n  // Get the container based on the passed containerType\r\n  const containerSelector = containerSelectors[containerType];\r\n\r\n  // If the container selector is not defined, return\r\n  if (!containerSelector) {\r\n    console.error(\"Invalid or missing container. Please provide 'generalChat' or 'cachePanel'.\");\r\n    return;\r\n  }\r\n\r\n  const staticNotificationsContainer = document.querySelector(containerSelector);\r\n  if (!staticNotificationsContainer) {\r\n    console.error(\"Container not found in DOM.\");\r\n    return;\r\n  }\r\n\r\n  // Add a class to the container based on the container type\r\n  staticNotificationsContainer.classList.add(\r\n    containerType === 'generalChat'\r\n      ? 'static-chat-notifications-container'\r\n      : 'static-cache-notifications-container'\r\n  );\r\n\r\n  // Create the action icon based on the iconType provided\r\n  const staticChatNotification = document.createElement('div');\r\n  staticChatNotification.classList.add('static-chat-notification');\r\n\r\n  // Add double-click listener to purge notifications only if using the generalChat container\r\n  if (containerType === 'generalChat') {\r\n    staticChatNotification.addEventListener('dblclick', () => {\r\n      purgeStaticChatNotifications();\r\n    });\r\n  }\r\n\r\n  // Create the user element\r\n  const userElement = document.createElement('span');\r\n  userElement.classList.add(\"action-user\");\r\n  userElement.textContent = user;\r\n\r\n  // Create the action icon based on the iconType provided\r\n  const actionIcon = createActionIcon(iconType);\r\n\r\n  // Create the time element\r\n  const timeElement = document.createElement('span');\r\n  timeElement.classList.add(\"action-time\");\r\n  timeElement.textContent = time;\r\n\r\n  // Append elements in order: user span, action icon, time span\r\n  staticChatNotification.appendChild(userElement);\r\n  staticChatNotification.appendChild(actionIcon);\r\n  staticChatNotification.appendChild(timeElement);\r\n\r\n  // Store username and time as data attributes for easy access later\r\n  staticChatNotification.dataset.username = user;\r\n  staticChatNotification.dataset.time = time;\r\n\r\n  // Style based on presence\r\n  if (presence) {\r\n    staticChatNotification.classList.add('user-enter');\r\n  } else {\r\n    staticChatNotification.classList.add('user-left');\r\n  }\r\n\r\n  // Append the notification to the selected container\r\n  staticNotificationsContainer.appendChild(staticChatNotification);\r\n\r\n  // Use the custom tooltip when the user enters the static notification\r\n  staticChatNotification.addEventListener('mouseover', () => {\r\n    // Use dataset to get the username and time from the static notification\r\n    const usernameData = staticChatNotification.dataset.username;\r\n    const timeData = staticChatNotification.dataset.time;\r\n    // Get the user chat duration and pass it to the custom tooltip\r\n    const title = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getUserChatDuration)(usernameData, timeData);\r\n    // Create and display the custom tooltip\r\n    (0,_tooltip__WEBPACK_IMPORTED_MODULE_2__.createCustomTooltip)(staticChatNotification, title);\r\n  });\r\n}\r\n\r\n// Function to create and animate a dynamic notification\r\nfunction createDynamicNotification(user, iconType, time, presence) {\r\n  let dynamicChatNotificationsContainer = document.querySelector('.dynamic-chat-notifications-container');\r\n  // Create container if it doesn't exist\r\n  if (!dynamicChatNotificationsContainer) {\r\n    dynamicChatNotificationsContainer = document.createElement('div');\r\n    dynamicChatNotificationsContainer.classList.add('dynamic-chat-notifications-container');\r\n    document.body.appendChild(dynamicChatNotificationsContainer);\r\n  }\r\n\r\n  // Create the notification element\r\n  const dynamicChatNotification = document.createElement('div');\r\n  dynamicChatNotification.classList.add('dynamic-chat-notification');\r\n\r\n  // Create user element\r\n  const userElement = document.createElement('span');\r\n  userElement.classList.add(\"action-user\");\r\n  userElement.textContent = user;\r\n\r\n  // Create the action icon based on the iconType provided\r\n  const actionIcon = createActionIcon(iconType);\r\n\r\n  // Create time element\r\n  const timeElement = document.createElement('span');\r\n  timeElement.classList.add(\"action-time\");\r\n  timeElement.textContent = time;\r\n\r\n  // Append elements in order: user span, action icon, time span\r\n  dynamicChatNotification.appendChild(userElement);\r\n  dynamicChatNotification.appendChild(actionIcon);\r\n  dynamicChatNotification.appendChild(timeElement);\r\n\r\n  // Store username and time as data attributes for easy access later\r\n  dynamicChatNotification.dataset.username = user;\r\n  dynamicChatNotification.dataset.time = time;\r\n\r\n  // Set colorization based on presence\r\n  if (presence) {\r\n    dynamicChatNotification.classList.add('user-enter');\r\n  } else {\r\n    dynamicChatNotification.classList.add('user-left');\r\n  }\r\n\r\n  // Append to the container\r\n  dynamicChatNotificationsContainer.appendChild(dynamicChatNotification);\r\n\r\n  // Use the custom tooltip when the user enters the static notification\r\n  dynamicChatNotification.addEventListener('mouseover', () => {\r\n    // Use dataset to get the username and time from the static notification\r\n    const usernameData = dynamicChatNotification.dataset.username;\r\n    const timeData = dynamicChatNotification.dataset.time;\r\n    // Get the user chat duration and pass it to the custom tooltip\r\n    const title = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getUserChatDuration)(usernameData, timeData);\r\n    // Create and display the custom tooltip\r\n    (0,_tooltip__WEBPACK_IMPORTED_MODULE_2__.createCustomTooltip)(dynamicChatNotification, title);\r\n  });\r\n\r\n  // Animate: slide in, then slide out and remove\r\n  setTimeout(() => {\r\n    dynamicChatNotification.style.transform = 'translateX(0)';\r\n    setTimeout(() => {\r\n      dynamicChatNotification.style.transform = 'translateX(-100%)';\r\n      setTimeout(() => {\r\n        dynamicChatNotificationsContainer.removeChild(dynamicChatNotification);\r\n      }, 300); // after slide-out animation\r\n    }, _definitions__WEBPACK_IMPORTED_MODULE_0__.dynamicChatNotificationTimeout);\r\n  }, 300);\r\n}\r\n\r\n// Main function which now calls the appropriate notification function(s)\r\nfunction showUserAction(user, iconType, presence) {\r\n  // Check if the user is tracked and in the correct state\r\n  const isTrackedUser = _definitions__WEBPACK_IMPORTED_MODULE_0__.usersToTrack.some(\r\n    (trackedUser) => trackedUser.name === user && trackedUser.state === 'thawed'\r\n  );\r\n\r\n  const shouldShowStatic = isTrackedUser && (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.shouldEnableSetting)('notifications', 'static');\r\n  const shouldShowDynamic = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.shouldEnableSetting)('notifications', 'dynamic');\r\n\r\n  // If neither notification is enabled, exit early.\r\n  if (!shouldShowStatic && !shouldShowDynamic) return;\r\n\r\n  // Get current time formatted as [HH:MM:SS]\r\n  const time = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getCurrentTimeFormatted)();\r\n\r\n  if (shouldShowStatic && isTrackedUser) {\r\n    createStaticNotification(user, iconType, time, presence, 'generalChat');\r\n    (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.scrollMessagesToBottom)();\r\n  }\r\n\r\n  if (shouldShowDynamic) {\r\n    createDynamicNotification(user, iconType, time, presence);\r\n  }\r\n}\r\n\r\n// NOTIFICATIONS TERMINATOR \r\n\r\n// Helper for pausing execution\r\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\nasync function purgeStaticChatNotifications(\r\n  removalDelay = 40,\r\n  scrollDuration = 600,\r\n  animationDuration = 140\r\n) {\r\n  const chat = document.querySelector(\".messages-content\");\r\n  if (!chat) return;\r\n\r\n  // Save original scroll behavior and set to smooth once\r\n  const originalScrollBehavior = chat.style.scrollBehavior;\r\n  chat.style.scrollBehavior = 'smooth';\r\n\r\n  const elements = [...document.querySelectorAll('.static-chat-notification')].reverse();\r\n\r\n  for (const el of elements) {\r\n    const needsScroll = !isVisibleInContainer(el, chat);\r\n\r\n    if (needsScroll) {\r\n      // Smooth scroll to element\r\n      chat.scrollTop = el.offsetTop - chat.offsetTop - chat.clientHeight / 2;\r\n      await sleep(scrollDuration);\r\n    }\r\n\r\n    Object.assign(el.style, {\r\n      transition: [\r\n        `opacity ${animationDuration / 1000}s cubic-bezier(.3,.1,1,.1)`,\r\n        `transform ${animationDuration / 1000}s cubic-bezier(0,.7,.3,0.95)`\r\n      ].join(','),\r\n      opacity: 0,\r\n      transformOrigin: 'left',\r\n      transform: 'translateX(8em) skewX(-20deg)'\r\n    });\r\n\r\n    // Wait for animation to complete before removal\r\n    await sleep(animationDuration);\r\n    el.remove();\r\n\r\n    // Standard delay between elements\r\n    await sleep(removalDelay);\r\n  }\r\n\r\n  // Final scroll to bottom only if needed\r\n  const isAtBottom = chat.scrollHeight - chat.scrollTop <= chat.clientHeight;\r\n  if (!isAtBottom) {\r\n    chat.scrollTop = chat.scrollHeight;\r\n    await sleep(scrollDuration);\r\n  }\r\n\r\n  // Restore original scroll behavior\r\n  chat.style.scrollBehavior = originalScrollBehavior;\r\n}\r\n\r\nfunction isVisibleInContainer(el, container) {\r\n  const containerRect = container.getBoundingClientRect();\r\n  const elRect = el.getBoundingClientRect();\r\n  return (\r\n    elRect.top >= containerRect.top &&\r\n    elRect.bottom <= containerRect.bottom\r\n  );\r\n}\r\n\r\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/notifications.js?");

/***/ }),

/***/ "./src/modules/settings.js":
/*!*********************************!*\
  !*** ./src/modules/settings.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSettingsButton: () => (/* binding */ createSettingsButton)\n/* harmony export */ });\n/* harmony import */ var _icons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icons.js */ \"./src/modules/icons.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"./src/modules/helpers.js\");\n/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definitions.js */ \"./src/modules/definitions.js\");\n// icons\r\n\r\n\r\n// helpers && helpers definitions\r\n\r\n\r\n// definitions\r\n\r\n\r\n// Define dynamic variables\r\nlet {\r\n  panelsEvents\r\n} = _definitions_js__WEBPACK_IMPORTED_MODULE_2__.state;\r\n\r\n// Array of setting keys and their corresponding exported arrays\r\nconst settingsMap = [\r\n  ['usersToTrack', _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usersToTrack],\r\n  ['mentionKeywords', _definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords],\r\n  ['usernameReplacements', _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usernameReplacements],\r\n  ['moderator', _definitions_js__WEBPACK_IMPORTED_MODULE_2__.moderator],\r\n  ['ignored', _definitions_js__WEBPACK_IMPORTED_MODULE_2__.ignored]\r\n];\r\n\r\nsettingsMap.forEach(([key, arr]) => {\r\n  const stored = JSON.parse(localStorage.getItem(key)) || [];\r\n  if (stored.length) arr.splice(0, arr.length, ...stored);\r\n});\r\n\r\n// Assuming myNickname is defined somewhere in your code:\r\n_definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords.push(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.myNickname);\r\n\r\n// Global function to handle file input and process uploaded settings\r\nasync function handleUploadSettings(event) {\r\n  const file = event.target.files[0];\r\n  if (file) {\r\n    const reader = new FileReader();\r\n\r\n    // Return a Promise to handle the asynchronous reading\r\n    return new Promise((resolve, reject) => {\r\n      reader.onload = function (e) {\r\n        const jsonData = e.target.result; // Get the raw JSON string\r\n        try {\r\n          const settingsData = JSON.parse(jsonData); // Attempt to parse the JSON data\r\n          // Call a function to process the uploaded settings data\r\n          processUploadedSettings(settingsData);\r\n          resolve(); // Resolve the promise if successful\r\n        } catch (error) {\r\n          console.error('Error parsing JSON data:', error.message); // Log the error message\r\n          console.error('Invalid JSON:', jsonData); // Log the raw JSON string for debugging\r\n          // Optional: Notify the user about the error\r\n          alert('Failed to parse JSON data. Please check the format and try again.');\r\n          reject(error); // Reject the promise on error\r\n        }\r\n      };\r\n\r\n      reader.onerror = function (e) {\r\n        console.error('Error reading file:', e.target.error); // Handle file reading errors\r\n        reject(e.target.error); // Reject the promise on error\r\n      };\r\n\r\n      reader.readAsText(file); // Read the file as text\r\n    });\r\n  }\r\n}\r\n\r\nfunction handleDownloadSettings(settingsData) {\r\n  if (!settingsData || typeof settingsData !== 'object') {\r\n    console.error('Invalid settings data for download.');\r\n    alert('Cannot export settings. Please try again.');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const tabSize2 = '  ';\r\n    const tabSize4 = '    ';\r\n\r\n    // Format usersToTrack\r\n    const usersToTrackFormatted = settingsData.usersToTrack\r\n      .map((user) => `${tabSize4}${JSON.stringify(user)}`)\r\n      .join(',\\n');\r\n\r\n    // Format username replacements\r\n    const replacementsFormatted = settingsData.usernameReplacements\r\n      ?.map(replacement => `${tabSize4}${JSON.stringify(replacement)}`)\r\n      .join(',\\n') || '';\r\n\r\n    // Format toggle settings\r\n    const toggleFormatted = settingsData.toggle\r\n      .map(toggle => `${tabSize4}${JSON.stringify(toggle)}`)\r\n      .join(',\\n');\r\n\r\n    // Build JSON structure\r\n    const jsonData = '{\\n' +\r\n      `${tabSize2}\"usersToTrack\": [\\n` +\r\n      `${usersToTrackFormatted}\\n` +\r\n      `${tabSize2}],\\n` +\r\n      `${tabSize2}\"mentionKeywords\": [\\n` +\r\n      `${settingsData.mentionKeywords.map(keyword => `${tabSize4}\"${keyword}\"`).join(',\\n')}\\n` +\r\n      `${tabSize2}],\\n` +\r\n      `${tabSize2}\"usernameReplacements\": [\\n` + // Added replacements section\r\n      `${replacementsFormatted}\\n` +\r\n      `${tabSize2}],\\n` +\r\n      `${tabSize2}\"moderator\": [\\n` +\r\n      `${settingsData.moderator.map(moderator => `${tabSize4}\"${moderator}\"`).join(',\\n')}\\n` +\r\n      `${tabSize2}],\\n` +\r\n      `${tabSize2}\"ignored\": [\\n` +\r\n      `${settingsData.ignored.map(user => `${tabSize4}\"${user}\"`).join(',\\n')}\\n` +\r\n      `${tabSize2}],\\n` +\r\n      `${tabSize2}\"toggle\": [\\n` +\r\n      `${toggleFormatted}\\n` +\r\n      `${tabSize2}]\\n` +\r\n      '}';\r\n\r\n    // Generate filename\r\n    const currentDate = new Intl.DateTimeFormat('en-CA').format(new Date());\r\n    const filename = `KG_Chat_Empowerment_Settings_${currentDate}.json`;\r\n\r\n    // Create and trigger download\r\n    const blob = new Blob([jsonData], { type: 'application/json' });\r\n    const url = URL.createObjectURL(blob);\r\n    const tempLink = document.createElement('a');\r\n    tempLink.href = url;\r\n    tempLink.download = filename;\r\n    document.body.appendChild(tempLink);\r\n    tempLink.click();\r\n    document.body.removeChild(tempLink);\r\n    URL.revokeObjectURL(url);\r\n  } catch (error) {\r\n    console.error('Error exporting settings:', error);\r\n    alert('Failed to export settings. Please try again.');\r\n  }\r\n}\r\n\r\n// Function to retrieve settings from localStorage and combine them into a single object\r\nfunction getSettingsData() {\r\n  // Retrieve data from localStorage using the appropriate keys\r\n  const usersToTrack = JSON.parse(localStorage.getItem('usersToTrack')) || [];\r\n  const mentionKeywords = JSON.parse(localStorage.getItem('mentionKeywords')) || [];\r\n  const usernameReplacements = JSON.parse(localStorage.getItem('usernameReplacements')) || [];\r\n  const moderator = JSON.parse(localStorage.getItem('moderator')) || [];\r\n  const ignored = JSON.parse(localStorage.getItem('ignored')) || [];\r\n  const toggle = JSON.parse(localStorage.getItem('toggle')) || [];\r\n\r\n  // Combine the retrieved data into a single object\r\n  const settingsData = {\r\n    usersToTrack: usersToTrack,\r\n    mentionKeywords: mentionKeywords,\r\n    usernameReplacements: usernameReplacements,\r\n    moderator: moderator,\r\n    ignored: ignored,\r\n    toggle: toggle\r\n  };\r\n\r\n  return settingsData;\r\n}\r\n\r\n// Create a button to upload and apply new settings,\r\n// receiving the parent panel as a parameter.\r\nfunction createSettingsButton(panel) {\r\n  const showSettingsButton = document.createElement('div');\r\n  showSettingsButton.classList.add(\"empowerment-button\", \"settings-button\");\r\n\r\n  showSettingsButton.title = 'Show Settings Panel';\r\n  showSettingsButton.style.position = 'relative';\r\n\r\n  // Use the settings SVG from icons.js\r\n  showSettingsButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.settingsSVG;\r\n\r\n  const importFileInput = document.createElement('input');\r\n  importFileInput.type = 'file';\r\n  importFileInput.accept = '.json';\r\n  importFileInput.style.display = 'none';\r\n\r\n  importFileInput.addEventListener('change', handleUploadSettings);\r\n\r\n  showSettingsButton.addEventListener('click', event => {\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addPulseEffect)(showSettingsButton);\r\n    if (_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isAltKeyPressed) handleDownloadSettings(getSettingsData());\r\n    if (_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isCtrlKeyPressed) importFileInput.click();\r\n    if (_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isAltKeyPressed || _helpers_js__WEBPACK_IMPORTED_MODULE_1__.isCtrlKeyPressed) return;\r\n    showSettingsPanel();\r\n  });\r\n\r\n  showSettingsButton.appendChild(importFileInput);\r\n\r\n  // Append the settings button to the passed panel\r\n  panel.appendChild(showSettingsButton);\r\n}\r\n\r\n// Save the current settings to localStorage\r\nfunction saveSettingsToLocalStorage() {\r\n  localStorage.setItem('usersToTrack', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.usersToTrack));\r\n  localStorage.setItem('mentionKeywords', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords));\r\n  localStorage.setItem('usernameReplacements', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.usernameReplacements));\r\n  localStorage.setItem('moderator', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.moderator));\r\n  localStorage.setItem('ignored', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.ignored));\r\n  localStorage.setItem('toggle', JSON.stringify(_definitions_js__WEBPACK_IMPORTED_MODULE_2__.toggle));\r\n}\r\n\r\n// Process and apply uploaded settings\r\nfunction processUploadedSettings({\r\n  usersToTrack: u = [],\r\n  mentionKeywords: mk = [],\r\n  usernameReplacements: ur = [],\r\n  moderator: md = [],\r\n  ignored: i = [],\r\n  toggle: t = []\r\n}) {\r\n  // Ensure the uploaded values are valid arrays\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usersToTrack = Array.isArray(u) ? u : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usersToTrack;\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords = Array.isArray(mk) ? mk : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords;\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usernameReplacements = Array.isArray(ur) ? ur : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usernameReplacements;\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.moderator = Array.isArray(md) ? md : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.moderator;\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.ignored = Array.isArray(i) ? i : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.ignored;\r\n  _definitions_js__WEBPACK_IMPORTED_MODULE_2__.toggle = Array.isArray(t) ? t : _definitions_js__WEBPACK_IMPORTED_MODULE_2__.toggle;\r\n\r\n  // Save to localStorage after applying the settings\r\n  saveSettingsToLocalStorage();\r\n  console.log('Uploaded settings applied:', {\r\n    usersToTrack: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usersToTrack,\r\n    mentionKeywords: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.mentionKeywords,\r\n    usernameReplacements: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.usernameReplacements, // Added to log\r\n    moderator: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.moderator,\r\n    ignored: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.ignored,\r\n    toggle: _definitions_js__WEBPACK_IMPORTED_MODULE_2__.toggle\r\n  });\r\n}\r\n\r\n// Function to display the settings panel\r\nfunction showSettingsPanel() {\r\n  // Check if the panel already exists\r\n  const existingPanel = document.querySelector('.settings-panel');\r\n  if (existingPanel) {\r\n    existingPanel.remove(); // Remove the settings panel\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerDimmingElement)('hide');\r\n    return; // Return immediately to prevent further execution\r\n  }\r\n\r\n  // Remove any previous panel before creating a new one\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removePreviousPanel)();\r\n\r\n  // Create the settings panel container\r\n  const settingsPanel = document.createElement('div');\r\n  settingsPanel.className = 'settings-panel popup-panel';\r\n\r\n  // Define the event handler function for settings panel\r\n  panelsEvents.handleSettingsKeydown = (event) => { // Assign the function to the object\r\n    if (event.key === 'Escape') {\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerTargetElement)(settingsPanel, 'hide');\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerDimmingElement)('hide');\r\n      document.removeEventListener('keydown', panelsEvents.handleSettingsKeydown); // Remove the event listener\r\n    }\r\n  };\r\n\r\n  // Attach the event listener\r\n  document.addEventListener('keydown', panelsEvents.handleSettingsKeydown);\r\n\r\n  // Create a container div for the panel header\r\n  const panelHeaderContainer = document.createElement('div');\r\n  panelHeaderContainer.className = 'panel-header';\r\n\r\n  const panelControlButtons = document.createElement('div');\r\n  panelControlButtons.classList.add(\"panel-control-buttons\");\r\n\r\n  // Create a close button with the provided SVG icon\r\n  const closePanelButton = document.createElement('div');\r\n  closePanelButton.className = 'large-button panel-header-close-button';\r\n  closePanelButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.closeSVG;\r\n  closePanelButton.title = 'Close panel';\r\n\r\n  // Add a click event listener to the close panel button\r\n  closePanelButton.addEventListener('click', () => {\r\n    // Fade out the settings panel when the close button is clicked\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerTargetElement)(settingsPanel, 'hide');\r\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerDimmingElement)('hide');\r\n  });\r\n\r\n  // Create a clear cache button with the provided SVG icon\r\n  const clearCacheButton = document.createElement('div');\r\n  clearCacheButton.className = \"large-button panel-header-clear-button\";\r\n  clearCacheButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.trashSVG;\r\n  clearCacheButton.title = 'Clear settings';\r\n\r\n  // Add a click event listener to the clear cache button\r\n  clearCacheButton.addEventListener('click', () => {\r\n    clearSettingsContainers();\r\n  })\r\n\r\n  // Create an import button with the provided SVG icon\r\n  const importSettingsButton = document.createElement('div');\r\n  importSettingsButton.className = \"large-button panel-header-import-button\";\r\n  importSettingsButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.importSVG;\r\n  importSettingsButton.title = 'Import settings';\r\n\r\n  // Create a save button with the provided SVG icon\r\n  const saveSettingsButton = document.createElement('div');\r\n  saveSettingsButton.className = \"large-button panel-header-save-button\";\r\n  saveSettingsButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.saveSVG;\r\n  saveSettingsButton.title = 'Save settings';\r\n\r\n  function initializeSaveButtonLogic(saveButton) {\r\n    const container = document.querySelector('.settings-content-container');\r\n    if (!container) return console.error(\"Container not found.\");\r\n\r\n    const showButton = () => {\r\n      saveButton.style.visibility = 'visible'; // Make the element interactable\r\n      saveButton.style.display = 'flex'; // Set display to flex to reveal it\r\n      setTimeout(() => {\r\n        saveButton.style.opacity = '1'; // Gradually change opacity\r\n      }, 10); // Small delay to trigger the transition\r\n    };\r\n\r\n    const hideButton = () => {\r\n      saveButton.style.opacity = '0'; // Fade out\r\n      setTimeout(() => {\r\n        saveButton.style.visibility = 'hidden'; // Hide the element after fading out\r\n        saveButton.style.display = 'none'; // Hide the element from layout\r\n      }, 300); // Match the transition duration for smooth disappearance\r\n    };\r\n\r\n    // Get previous values from localStorage\r\n    const previousValues = getSettingsData();\r\n\r\n    const handleInputChange = () => {\r\n      const currentValues = {\r\n        usersToTrack: [],\r\n        mentionKeywords: [],\r\n        usernameReplacements: [],\r\n        moderator: [],\r\n        ignored: [],\r\n        toggle: []\r\n      };\r\n\r\n      // Process tracked items\r\n      container.querySelectorAll('.settings-tracked-container .tracked-item').forEach(item => {\r\n        const usernameField = item.querySelector('.tracked-username-field');\r\n        const genderField = item.querySelector('.tracked-gender-select');\r\n        const pronunciationField = item.querySelector('.tracked-pronunciation-field');\r\n        const snowflakeButton = item.querySelector('.assigned-thawed-config, .assigned-frozen-config');\r\n\r\n        const usernameValue = usernameField ? usernameField.value.trim() : '';\r\n        const genderValue = genderField ? genderField.value.trim() : '';\r\n        const pronunciationValue = pronunciationField ? pronunciationField.value.trim() : '';\r\n        // Determine the state based on the button's class\r\n        const state = snowflakeButton.classList.contains('assigned-frozen-config') ? 'frozen' : 'thawed';\r\n\r\n        // Push current values to usersToTrack\r\n        currentValues.usersToTrack.push({\r\n          name: usernameValue,\r\n          gender: genderValue,\r\n          pronunciation: pronunciationValue,\r\n          state\r\n        });\r\n      });\r\n\r\n      // Create a set of tracked usernames (case-insensitive)\r\n      const trackedNames = new Set(\r\n        currentValues.usersToTrack.map(user => user.name.toLowerCase())\r\n      );\r\n\r\n      // Process mention items\r\n      container.querySelectorAll('.settings-mention-container .mention-item').forEach(item => {\r\n        const mentionField = item.querySelector('.mention-field');\r\n        const mentionValue = mentionField ? mentionField.value.trim() : '';\r\n        currentValues.mentionKeywords.push(mentionValue);\r\n      });\r\n\r\n      // Process replacement items\r\n      container.querySelectorAll('.settings-replacement-container .replacement-item').forEach(item => {\r\n        const originalField = item.querySelector('.replacement-original-field');\r\n        const replacementField = item.querySelector('.replacement-field');\r\n        const originalValue = originalField ? originalField.value.trim() : '';\r\n        const replacementValue = replacementField ? replacementField.value.trim() : '';\r\n\r\n        // If the original value exists in tracked users, prevent creating a new replacement item.\r\n        if (trackedNames.has(originalValue.toLowerCase())) {\r\n          // Optionally, mark the field as invalid to notify the user.\r\n          originalField.classList.add('input-error');\r\n          addShakeEffect(originalField);\r\n          return; // Skip pushing this replacement item.\r\n        } else {\r\n          originalField.classList.remove('input-error');\r\n        }\r\n\r\n        currentValues.usernameReplacements.push({\r\n          original: originalValue,\r\n          replacement: replacementValue\r\n        });\r\n      });\r\n\r\n      // Process moderator\r\n      container.querySelectorAll('.settings-moderator-container .moderator-item').forEach(item => {\r\n        const moderatorField = item.querySelector('.moderator-field');\r\n        const moderatorValue = moderatorField ? moderatorField.value.trim() : '';\r\n        currentValues.moderator.push(moderatorValue);\r\n      });\r\n\r\n      // Process ignored items\r\n      container.querySelectorAll('.settings-ignored-container .ignored-item').forEach(item => {\r\n        const ignoredField = item.querySelector('.ignored-field');\r\n        const ignoredValue = ignoredField ? ignoredField.value.trim() : '';\r\n        currentValues.ignored.push(ignoredValue);\r\n      });\r\n\r\n      // Process toggle (yes/no) settings based on select elements within each toggle-setting item\r\n      container.querySelectorAll('.settings-toggle-container .toggle-item').forEach(item => {\r\n        const descriptionElement = item.querySelector('.toggle-description'); // Get the description element\r\n        const selectElement = item.querySelector('.toggle-select'); // Select the toggle (select) element within the current toggle-item\r\n        const selectedValue = selectElement ? selectElement.value.trim() : 'no'; // Default to 'no' if not selected\r\n\r\n        // Get the data-toggle-name attribute value from the descriptionElement\r\n        const toggleName = descriptionElement.getAttribute('data-toggle-name');\r\n\r\n        // Push the current toggle setting as an object into the toggle array\r\n        if (toggleName) {\r\n          currentValues.toggle.push({\r\n            name: toggleName, // Store the toggle name\r\n            option: selectedValue // Store the selected value directly\r\n          });\r\n        }\r\n      });\r\n\r\n      // Check if any values have changed compared to previous state\r\n      const valuesChanged = JSON.stringify(previousValues) !== JSON.stringify(currentValues);\r\n\r\n      // Show or hide the save button based on whether values have changed\r\n      valuesChanged ? showButton() : hideButton();\r\n\r\n      return currentValues; // Return current values for saving later\r\n    };\r\n\r\n    // Attach click event to save settings when there are changes\r\n    saveButton.addEventListener('click', () => {\r\n      const currentValues = handleInputChange(); // Get current values before saving\r\n      processUploadedSettings(currentValues); // Process and save the current settings\r\n      // Update previousValues to the current state after saving\r\n      Object.assign(previousValues, currentValues);\r\n      hideButton(); // Optionally hide the button after saving\r\n    });\r\n\r\n    // Add input listeners to existing fields\r\n    container.querySelectorAll('input, select').forEach(field => {\r\n      field.addEventListener('input', handleInputChange);\r\n    });\r\n\r\n    // Function to attach event listeners to dynamically added input and select elements\r\n    const attachEventListeners = (element) => {\r\n      if (element.tagName === 'INPUT' || element.tagName === 'SELECT') {\r\n        element.addEventListener('input', handleInputChange);\r\n        // console.log('Listener attached to:', element);\r\n      } else {\r\n        // Check its children for input or select elements\r\n        element.querySelectorAll('input, select').forEach((child) => {\r\n          child.addEventListener('input', handleInputChange);\r\n          // console.log('Listener attached to child:', child);\r\n        });\r\n      }\r\n    };\r\n\r\n    // Create a mutation observer to monitor changes in the target container\r\n    const observer = new MutationObserver((0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.debounce)((mutationsList) => {\r\n      mutationsList.forEach((mutation) => {\r\n        if (mutation.type === 'childList') {\r\n          mutation.addedNodes.forEach((node) => {\r\n            if (node.nodeType === Node.ELEMENT_NODE) {\r\n              // console.log('Added:', node);\r\n              attachEventListeners(node); // Attach event listeners to new elements\r\n            }\r\n          });\r\n\r\n          mutation.removedNodes.forEach((node) => {\r\n            if (node.nodeType === Node.ELEMENT_NODE) {\r\n              // console.log('Removed:', node);\r\n              handleInputChange(); // Call handleInputChange to check the state after any changes\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }, _definitions_js__WEBPACK_IMPORTED_MODULE_2__.debounceTimeout));\r\n\r\n    // Start observing the target container for child list changes\r\n    observer.observe(container, {\r\n      childList: true,\r\n      subtree: true, // Observe all descendants as well\r\n    });\r\n  }\r\n\r\n  // Create a hidden file input for importing settings\r\n  const importFileInput = document.createElement('input');\r\n  importFileInput.type = 'file';\r\n  importFileInput.accept = '.json'; // Specify the file type\r\n  importFileInput.style.display = 'none'; // Hide the file input\r\n\r\n  // Add an event listener for the import file input\r\n  importFileInput.addEventListener('change', async (event) => {\r\n    await handleUploadSettings(event); // Wait for processing uploaded settings\r\n    // Clear the containers before populating new data\r\n    clearSettingsContainers();\r\n    // Populate the UI with updated settings\r\n    populateSettings();\r\n  });\r\n\r\n  // Function to clear the content of settings containers\r\n  function clearSettingsContainers() {\r\n    const containers = [\r\n      '.settings-tracked-container',\r\n      '.settings-mention-container',\r\n      '.settings-replacement-container',\r\n      '.settings-moderator-container',\r\n      '.settings-ignored-container',\r\n      '.settings-toggle-container'\r\n    ];\r\n\r\n    containers.forEach(selector => {\r\n      const container = document.querySelector(selector);\r\n      if (container) container.replaceChildren(); // Clear the container\r\n\r\n      const addButton = container.querySelector('.add-settings-button');\r\n      // Re-add the .add-settings-button if it was found\r\n      addButton && container.appendChild(addButton);\r\n    });\r\n  }\r\n\r\n  // Add a click event listener to the import button\r\n  importSettingsButton.addEventListener('click', () => {\r\n    importFileInput.click(); // Trigger file input click\r\n  });\r\n\r\n  // Append the file input to the import button\r\n  importSettingsButton.appendChild(importFileInput);\r\n\r\n  // Create an export button with the provided SVG icon\r\n  const exportSettingsButton = document.createElement('div');\r\n  exportSettingsButton.className = \"large-button panel-header-export-button\";\r\n  exportSettingsButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.exportSVG;\r\n  exportSettingsButton.title = 'Export settings';\r\n\r\n  // Example of how to use the getSettingsData function in the export event\r\n  exportSettingsButton.addEventListener('click', function () {\r\n    const settingsData = getSettingsData(); // Retrieve the settings data\r\n    handleDownloadSettings(settingsData); // Pass the retrieved settings data to the download function\r\n  });\r\n\r\n  // Append the buttons to the panel header container\r\n  panelControlButtons.appendChild(saveSettingsButton);\r\n  panelControlButtons.appendChild(importSettingsButton);\r\n  panelControlButtons.appendChild(exportSettingsButton);\r\n  panelControlButtons.appendChild(clearCacheButton);\r\n  panelControlButtons.appendChild(closePanelButton);\r\n\r\n  panelHeaderContainer.appendChild(panelControlButtons);\r\n\r\n  settingsPanel.appendChild(panelHeaderContainer);\r\n\r\n  // Create a container for the settings content\r\n  const settingsContainer = document.createElement('div');\r\n  settingsContainer.className = 'settings-content-container';\r\n\r\n  // Array of settings types with corresponding emoji\r\n  const settingsTypes = [\r\n    { type: 'tracked', emoji: '👀' },\r\n    { type: 'mention', emoji: '📢' },\r\n    { type: 'replacement', emoji: '♻️' },\r\n    { type: 'moderator', emoji: '⚔️' },\r\n    { type: 'ignored', emoji: '🛑' },\r\n    { type: 'toggle', emoji: '🔘' }\r\n  ];\r\n\r\n  settingsTypes.forEach(({ type, emoji }) => {\r\n    const description = document.createElement('div');\r\n    description.className = `settings-${type}-description settings-description`; // Add specific class and settings-description\r\n\r\n    // Create the description container directly\r\n    const container = document.createElement('div');\r\n    container.className = `settings-${type}-container`;\r\n\r\n    // Set the text content with first letter capitalized and append emoji\r\n    description.textContent = `${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} ${emoji}`;\r\n\r\n    settingsContainer.appendChild(description);\r\n    settingsContainer.appendChild(container);\r\n  });\r\n\r\n  // Append the settings content container to the settings panel\r\n  settingsPanel.appendChild(settingsContainer);\r\n\r\n  // Applies common styles to a select element and its options\r\n  function styleSelect(select) {\r\n    select.style.height = '30px';\r\n    select.style.maxWidth = '120px';\r\n    select.style.minWidth = '105px';\r\n    select.style.padding = '0.4em';\r\n    select.style.font = '1em Montserrat';\r\n    select.style.fontFamily = 'Montserrat';\r\n    select.style.setProperty('color', 'bisque', 'important');\r\n    select.style.setProperty('border-radius', '0.2em', 'important');\r\n    select.style.boxSizing = 'border-box';\r\n    select.style.setProperty('background-color', 'rgb(17,17,17)', 'important');\r\n    select.style.setProperty('border', '1px solid rgb(34,34,34)', 'important');\r\n\r\n    // Style each option element\r\n    Array.from(select.options).forEach(option => {\r\n      option.style.height = '30px';\r\n      option.style.setProperty('background-color', 'rgb(17,17,17)', 'important');\r\n      option.style.setProperty('color', 'bisque', 'important');\r\n      option.style.fontFamily = 'Montserrat';\r\n    });\r\n  }\r\n\r\n  // Common function to attach click event for removing an item\r\n  function attachRemoveListener(removeButton, item) {\r\n    removeButton.addEventListener('click', () => {\r\n      item.remove(); // Remove the parent element\r\n    });\r\n  }\r\n\r\n  // Function to attach click event for toggling between \"assigned-thawed-config\" and \"assigned-frozen-config\"\r\n  function attachSnowflakeListener(snowflakeButton, username) {\r\n    snowflakeButton.addEventListener('click', () => {\r\n      const isFrozen = snowflakeButton.classList.toggle('assigned-frozen-config');\r\n      snowflakeButton.classList.toggle('assigned-thawed-config');\r\n\r\n      // Set opacity based on the assigned class\r\n      snowflakeButton.style.opacity = isFrozen ? '1' : '0.3';\r\n\r\n      // Update localStorage using the helper function\r\n      updateUserState(username, isFrozen ? 'frozen' : 'thawed');\r\n    });\r\n  }\r\n\r\n  // Helper function to create a container element\r\n  function createContainer(type, layout = 'inline-flex') {\r\n    const item = document.createElement('div');\r\n    item.className = `${type}-item`;\r\n    item.style.display = layout;\r\n    item.style.gap = '0.5em';\r\n    item.style.padding = '0.25em';\r\n    return item;\r\n  }\r\n\r\n  // Helper function to create an input element\r\n  function createInput(type, value = '', placeholder = '') {\r\n    const input = document.createElement('input');\r\n    input.className = `settings-field ${type}-field`;\r\n    input.value = value;\r\n    input.placeholder = placeholder;\r\n    return input;\r\n  }\r\n\r\n  // Helper function to create a remove button with styles and event listener\r\n  function createRemoveButton(type, item) {\r\n    const removeButton = document.createElement('div');\r\n    removeButton.className = `settings-button remove-settings-button remove-${type}-word`;\r\n    removeButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.removeSVG;\r\n    attachRemoveListener(removeButton, item);\r\n    return removeButton;\r\n  }\r\n\r\n  // Helper function to create a snowflake button with styles and event listener\r\n  function createSnowflakeButton(state = 'thawed', username) {\r\n    const snowflakeButton = document.createElement('div');\r\n    snowflakeButton.className = `settings-button assigned-settings-button assigned-${state}-config`;\r\n\r\n    // Set initial opacity based on the state\r\n    snowflakeButton.style.opacity = state === 'thawed' ? '0.3' : '1';\r\n    snowflakeButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.snowflakeSVG;\r\n\r\n    attachSnowflakeListener(snowflakeButton, username); // Pass username here\r\n    return snowflakeButton;\r\n  }\r\n\r\n  // Function to update a specific user in localStorage to add the state property\r\n  function updateUserState(username, state) {\r\n    const usersData = localStorage.getItem(\"usersToTrack\");\r\n    if (usersData) {\r\n      const updatedUsers = JSON.parse(usersData).map(user =>\r\n        user.name === username ? { ...user, state } : user\r\n      );\r\n      localStorage.setItem(\"usersToTrack\", JSON.stringify(updatedUsers));\r\n    }\r\n  }\r\n\r\n  // Function to create a spoiler container (as provided)\r\n  function createSpoilerContainer(contentElement, options = {}) {\r\n    const container = document.createElement('div');\r\n    container.classList.add(\"settings-spoiler\");\r\n    const toggleButton = document.createElement('button');\r\n\r\n    toggleButton.textContent = options.showText || 'Show Content';\r\n\r\n    contentElement.style.display = 'none';\r\n\r\n    toggleButton.addEventListener('click', () => {\r\n      const isHidden = contentElement.style.display === 'none';\r\n      contentElement.style.display = isHidden ? 'flex' : 'none';\r\n      toggleButton.textContent = isHidden\r\n        ? (options.hideText || 'Hide Content')\r\n        : (options.showText || 'Show Content');\r\n    });\r\n\r\n    container.appendChild(toggleButton);\r\n    container.appendChild(contentElement);\r\n\r\n    return container;\r\n  }\r\n\r\n  // Function to create a tracked item (with gender select)\r\n  function createTrackedItem(user) {\r\n    const item = createContainer('tracked', 'flex');\r\n\r\n    const usernameInput = createInput('tracked-username', user.name, 'Username');\r\n    const pronunciationInput = createInput('tracked-pronunciation', user.pronunciation, 'Pronunciation');\r\n    const removeButton = createRemoveButton('tracked', item);\r\n\r\n    // Set the initial state based on the user's state property, defaulting to 'thawed' if it doesn't exist\r\n    const initialState = (user.state === 'frozen') ? 'frozen' : 'thawed';\r\n    const snowflakeButton = createSnowflakeButton(initialState, user.name); // Pass username\r\n\r\n    const genderSelect = document.createElement('select');\r\n    genderSelect.className = 'tracked-gender-select';\r\n    const genders = [\r\n      { value: 'Male', emoji: '👨' },\r\n      { value: 'Female', emoji: '👩' },\r\n    ];\r\n    genders.forEach(({ value, emoji }) => {\r\n      const option = document.createElement('option');\r\n      option.value = value;\r\n      option.textContent = `${emoji} ${value}`;\r\n      if (user.gender === value) option.selected = true;\r\n      genderSelect.appendChild(option);\r\n    });\r\n    styleSelect(genderSelect);\r\n\r\n    item.appendChild(usernameInput);\r\n    item.appendChild(genderSelect);\r\n    item.appendChild(pronunciationInput);\r\n    item.appendChild(removeButton);\r\n    item.appendChild(snowflakeButton);\r\n\r\n    return item;\r\n  }\r\n\r\n  // Function to create a mention item\r\n  function createMentionItem(keyword) {\r\n    const item = createContainer('mention');\r\n    const mentionInput = createInput('mention', keyword, 'Mention Keyword');\r\n    const removeButton = createRemoveButton('mention', item);\r\n\r\n    item.appendChild(mentionInput);\r\n    item.appendChild(removeButton);\r\n\r\n    return item;\r\n  }\r\n\r\n  // Function to create a username replacement item for text to speech API\r\n  function createReplacementItem(replacement = { original: '', replacement: '' }) {\r\n    const item = createContainer('replacement');\r\n    const originalInput = createInput('replacement-original', replacement.original, 'Original username');\r\n    const replacementInput = createInput('replacement', replacement.replacement, 'Replacement name');\r\n    const removeButton = createRemoveButton('replacement', item);\r\n\r\n    item.appendChild(originalInput);\r\n    item.appendChild(replacementInput);\r\n    item.appendChild(removeButton);\r\n\r\n    return item;\r\n  }\r\n\r\n  // Function to create a moderator item\r\n  function createModeratorItem(moderator) {\r\n    const item = createContainer('moderator');\r\n    const moderatorInput = createInput('moderator', moderator, 'Moderator Name');\r\n    const removeButton = createRemoveButton('moderator', item);\r\n\r\n    item.appendChild(moderatorInput);\r\n    item.appendChild(removeButton);\r\n\r\n    return item;\r\n  }\r\n\r\n  // Function to create an ignored item\r\n  function createIgnoredItem(user) {\r\n    const item = createContainer('ignored');\r\n    const ignoredInput = createInput('ignored', user, 'Ignored User');\r\n    const removeButton = createRemoveButton('ignored', item);\r\n\r\n    item.appendChild(ignoredInput);\r\n    item.appendChild(removeButton);\r\n\r\n    return item;\r\n  }\r\n\r\n  // Function to create a toggle item with a description and select for yes/no options\r\n  function createToggleItem(toggle, name, optionValue) {\r\n    const item = createContainer('toggle', 'flex');\r\n    item.style.alignItems = 'center';\r\n\r\n    // Create the select element for yes/no\r\n    const select = document.createElement('select');\r\n    select.className = 'toggle-select';\r\n\r\n    // Create the description element\r\n    const description = document.createElement('span');\r\n    description.className = 'toggle-description';\r\n    description.innerText = toggle.description;\r\n    // Set the custom data attribute for the setting using the name parameter\r\n    description.setAttribute('data-toggle-name', name); // Set data-toggle-name to the name parameter\r\n\r\n    // Add click event to open the image in a new tab\r\n    description.style.cursor = 'pointer'; // Add pointer cursor to indicate it's clickable\r\n    description.style.color = 'burlywood';\r\n    description.style.transition = 'color 0.15s ease-in-out';\r\n\r\n    description.addEventListener('click', () => {\r\n      if (toggle.image) {\r\n        window.open(toggle.image, '_blank'); // Open the image in a new tab\r\n      }\r\n    });\r\n\r\n    // Compact mouseover and mouseout events\r\n    description.addEventListener('mouseover', function () { description.style.color = 'lightgoldenrodyellow'; })\r\n    description.addEventListener('mouseout', function () { description.style.color = 'burlywood'; });\r\n\r\n    // Define options with emojis for yes and no\r\n    const options = [\r\n      { value: 'yes', emoji: '✔️' },\r\n      { value: 'no', emoji: '❌' }\r\n    ];\r\n\r\n    // Create options for the select element\r\n    options.forEach(({ value, emoji }) => {\r\n      const option = document.createElement('option');\r\n      option.value = value;\r\n      option.textContent = `${emoji} ${value}`; // Format text as \"✔️ yes\" or \"❌ no\"\r\n      select.appendChild(option);\r\n    });\r\n\r\n    // Set the initial value of the select based on the optionValue parameter\r\n    select.value = optionValue; // Assign the optionValue to the select element\r\n\r\n    // Style the select element\r\n    styleSelect(select); // Call the styling function\r\n\r\n    // Append the description and select to the toggle item\r\n    item.appendChild(select);\r\n    item.appendChild(description);\r\n\r\n    return item; // Return the created toggle item\r\n  }\r\n\r\n  function populateSettings() {\r\n    const containers = {\r\n      usersToTrack: '.settings-tracked-container',\r\n      mentionKeywords: '.settings-mention-container',\r\n      usernameReplacements: '.settings-replacement-container',\r\n      moderator: '.settings-moderator-container',\r\n      ignored: '.settings-ignored-container'\r\n    };\r\n\r\n    const creators = {\r\n      usersToTrack: { name: 'tracked', createItem: createTrackedItem },\r\n      mentionKeywords: { name: 'mention', createItem: createMentionItem },\r\n      usernameReplacements: { name: 'replacement', createItem: createReplacementItem },\r\n      moderator: { name: 'moderator', createItem: createModeratorItem },\r\n      ignored: { name: 'ignored', createItem: createIgnoredItem }\r\n    };\r\n\r\n    const data = getSettingsData();\r\n\r\n    Object.entries(data).forEach(([key, items]) => {\r\n      const container = document.querySelector(containers[key]);\r\n      if (!container) return;\r\n      container.classList.add(\"settings-container\");\r\n\r\n      if (key === 'mentionKeywords' || key === 'moderator' || key === 'ignored') {\r\n        container.style.flexDirection = 'row';\r\n      }\r\n\r\n      // Clear existing items and add buttons, but ensure the add button is not removed\r\n      const existingAddButton = container.querySelector('.add-settings-button');\r\n      while (container.firstChild) {\r\n        if (container.firstChild !== existingAddButton) {\r\n          container.removeChild(container.firstChild);\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Populate items\r\n      items.forEach(item => container.appendChild(creators[key].createItem(item)));\r\n\r\n      const addButton = createAddButton(containers[key], creators[key].createItem);\r\n      container.appendChild(addButton);\r\n\r\n      // Check if already wrapped in a spoiler\r\n      const isAlreadyWrapped = container.closest('.settings-spoiler') !== null;\r\n\r\n      if (!isAlreadyWrapped) {\r\n        const parent = container.parentNode;\r\n        if (parent) {\r\n          const index = Array.from(parent.childNodes).indexOf(container);\r\n          parent.removeChild(container);\r\n          const spoiler = createSpoilerContainer(container, {\r\n            showText: `Show ${creators[key].name} settings`,\r\n            hideText: `Hide ${creators[key].name} settings`\r\n          });\r\n          spoiler.classList.add('settings-spoiler-wrapper');\r\n          if (index >= parent.childNodes.length) {\r\n            parent.appendChild(spoiler);\r\n          } else {\r\n            parent.insertBefore(spoiler, parent.childNodes[index]);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Process toggle settings separately\r\n    const storedToggleSettings = JSON.parse(localStorage.getItem('toggle')) || [];\r\n    const toggleContainer = document.querySelector('.settings-toggle-container');\r\n    const toggleSettings = [\r\n      {\r\n        name: 'showChatStaticNotifications',\r\n        description: '👀 Show chat static notifications',\r\n        image: 'https://i.imgur.com/oUPSi9I.jpeg'\r\n      },\r\n      {\r\n        name: 'showGlobalDynamicNotifications',\r\n        description: '👀 Show global dynamic notifications',\r\n        image: 'https://i.imgur.com/8ffCdUG.jpeg'\r\n      },\r\n      {\r\n        name: 'enabledBeepOnChatJoinLeave',\r\n        description: '🔊 Play a beep sound and speak feedback when the user enters or leaves the chat',\r\n        image: 'https://i.imgur.com/6PXFIES.jpeg'\r\n      },\r\n      {\r\n        name: 'switchToGoogleTTSEngine',\r\n        description: '🔊 Switch to google TTS engine if available',\r\n        image: 'https://i.imgur.com/0H94LII.jpeg'\r\n      }\r\n    ];\r\n\r\n    toggleSettings.forEach(toggle => {\r\n      const storedSetting = storedToggleSettings.find(item => item.name === toggle.name);\r\n      const optionValue = storedSetting ? storedSetting.option : 'yes';\r\n      const toggleItem = createToggleItem(toggle, toggle.name, optionValue);\r\n      toggleContainer.appendChild(toggleItem);\r\n    });\r\n  }\r\n\r\n  // Function to create an \"Add\" button for dynamic item creation\r\n  function createAddButton(containerSelector, itemCreator) {\r\n    const middleWord = containerSelector.split('-')[1]; // Extract key type (e.g., tracked, mention)\r\n    const existingButton = document.querySelector(`.add-${middleWord}-item`); // Check if the button already exists\r\n    // If the button exists, remove it\r\n    if (existingButton) existingButton.remove();\r\n\r\n    const addButton = document.createElement('div');\r\n    // Set class, content, and style for the button\r\n    addButton.className = `settings-button add-settings-button add-${middleWord}-item`;\r\n    addButton.innerHTML = _icons_js__WEBPACK_IMPORTED_MODULE_0__.addSVG; // Add SVG icon to the button\r\n    addButton.style.margin = '0.4em';\r\n\r\n    // On click, validate the last item and create a new one if valid\r\n    addButton.addEventListener('click', () => {\r\n      const container = document.querySelector(containerSelector); // Get the container element\r\n\r\n      // Get all settings {type} items and select the last one\r\n      const allItems = container.querySelectorAll(`.${middleWord}-item`);\r\n      const lastItem = allItems.length > 0 ? allItems[allItems.length - 1] : null;\r\n\r\n      // Check if the last item has any input fields\r\n      const inputFields = lastItem ? lastItem.querySelectorAll('input') : []; // Get all input fields in the last item\r\n      const hasEmptyFields = Array.from(inputFields).some(field => field.value.trim().length === 0); // Check for empty fields\r\n\r\n      // Allow creation only if the last item has no empty fields (or if there are no items yet)\r\n      const canCreateNewItem = !lastItem || !hasEmptyFields;\r\n\r\n      if (canCreateNewItem) {\r\n        // Create a new empty item based on the item creator function\r\n        const emptyItem = itemCreator === createTrackedItem\r\n          ? itemCreator({ name: '', pronunciation: '' }) // Remove gender from tracked item creation\r\n          : itemCreator('');\r\n\r\n        // Check if the new item is a valid HTMLElement before inserting\r\n        if (emptyItem instanceof HTMLElement) {\r\n          container.insertBefore(emptyItem, addButton); // Insert the new item before the Add button\r\n        } else {\r\n          console.error('Invalid item created.'); // Log an error if the item is not valid\r\n        }\r\n      } else {\r\n        // Alert the user if the last item is filled\r\n        alert('Please fill in the previous item before adding a new one.');\r\n      }\r\n    });\r\n\r\n    return addButton; // Return the created button\r\n  }\r\n\r\n  // Create and append scroll buttons\r\n  const { scrollButtonsContainer } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.createScrollButtons)(settingsContainer);\r\n  settingsPanel.appendChild(scrollButtonsContainer);\r\n\r\n  // Append the settings panel to the body\r\n  document.body.appendChild(settingsPanel);\r\n\r\n  // Call the function to populate settings on page load\r\n  populateSettings();\r\n\r\n  // Make save button work as expected\r\n  initializeSaveButtonLogic(saveSettingsButton);\r\n\r\n  // Fade in the settings panel and dimming background element\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerTargetElement)(settingsPanel, 'show');\r\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.triggerDimmingElement)('show');\r\n}\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/settings.js?");

/***/ }),

/***/ "./src/modules/tooltip.js":
/*!********************************!*\
  !*** ./src/modules/tooltip.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCustomTooltip: () => (/* binding */ createCustomTooltip)\n/* harmony export */ });\nlet tooltipInstance = null;\r\nlet tooltipHideTimeout = null;\r\nlet tooltipShowTimeout = null;\r\nlet isTooltipVisible = false;\r\nlet isTooltipShown = false;\r\nlet currentElement = null;\r\n\r\nconst tooltipMousemoveHandler = (e) => {\r\n  if (tooltipInstance) {\r\n    tooltipInstance.style.left = `${e.clientX + 0}px`;\r\n    tooltipInstance.style.top = `${e.clientY + 18}px`;\r\n  }\r\n};\r\n\r\n// Global hide function\r\nconst hideTooltip = () => {\r\n  isTooltipVisible = false;\r\n  currentElement = null;\r\n  clearTimeout(tooltipShowTimeout);\r\n  tooltipShowTimeout = null;\r\n\r\n  clearTimeout(tooltipHideTimeout);\r\n  tooltipHideTimeout = setTimeout(() => {\r\n    if (tooltipInstance) {\r\n      tooltipInstance.style.opacity = '0';\r\n      isTooltipShown = false;\r\n      setTimeout(() => {\r\n        if (!isTooltipVisible && tooltipInstance) {\r\n          tooltipInstance.style.display = 'none';\r\n          document.removeEventListener('mousemove', tooltipMousemoveHandler);\r\n        }\r\n      }, 50);\r\n    }\r\n  }, 100);\r\n};\r\n\r\n// MutationObserver to check element removal\r\nconst observer = new MutationObserver(() => {\r\n  if (currentElement && !document.contains(currentElement)) {\r\n    hideTooltip();\r\n  }\r\n});\r\nobserver.observe(document, { childList: true, subtree: true });\r\n\r\nfunction createCustomTooltip(element, tooltipText) {\r\n  if (element.classList.contains('events-included')) return;\r\n  element.classList.add('events-included');\r\n\r\n  tooltipInstance ||= (() => {\r\n    const tooltipElement = document.createElement('div');\r\n    tooltipElement.classList.add(\"custom-tooltip-popup\");\r\n    document.body.appendChild(tooltipElement);\r\n    return tooltipElement;\r\n  })();\r\n\r\n  const showTooltip = (e) => {\r\n    isTooltipVisible = true;\r\n    currentElement = element;\r\n    clearTimeout(tooltipShowTimeout);\r\n    clearTimeout(tooltipHideTimeout);\r\n    tooltipInstance.textContent = tooltipText;\r\n\r\n    document.addEventListener('mousemove', tooltipMousemoveHandler);\r\n    tooltipMousemoveHandler(e);\r\n\r\n    if (!isTooltipShown) {\r\n      tooltipShowTimeout = setTimeout(() => {\r\n        tooltipInstance.style.display = 'flex';\r\n        tooltipInstance.style.opacity = '1';\r\n        isTooltipShown = true;\r\n      }, 600);\r\n    }\r\n  };\r\n\r\n  element.addEventListener('mouseenter', showTooltip);\r\n  element.addEventListener('mouseleave', hideTooltip);\r\n}\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/tooltip.js?");

/***/ }),

/***/ "./src/modules/video-converter.js":
/*!****************************************!*\
  !*** ./src/modules/video-converter.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertVideoLinksToPlayer: () => (/* binding */ convertVideoLinksToPlayer)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/modules/helpers.js\");\n// helpers\r\n\r\n\r\nconst videoExtensionEmoji = '🎥';\r\nconst webDomainEmoji = '🖥️';\r\nconst untrustedEoji = '💀️️';\r\n\r\n// List of allowed video extensions\r\nconst allowedVideoExtensions = ['mp4', 'webm', 'ogg', 'mov', 'avi'];\r\n\r\n/**\r\n * Checks if a given URL has an allowed video extension.\r\n * @param {string} url - The URL to check.\r\n * @returns {{allowed: boolean, extension: string}} - Indicates if the extension is allowed and returns the extension.\r\n */\r\nfunction isAllowedVideoExtension(url) {\r\n  // Shared extension extraction logic\r\n  const getExtension = (str) =>\r\n    (str.match(/\\.([^?#.]+)(?:[?#]|$)/i)?.[1]?.toLowerCase() || '');\r\n\r\n  try {\r\n    const extension = getExtension(url);\r\n    return {\r\n      allowed: allowedVideoExtensions.includes(extension),\r\n      extension\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Error in isAllowedVideoExtension:\", error.message);\r\n    return {\r\n      allowed: false,\r\n      extension: getExtension(String(url)) // Handle non-string URLs\r\n    };\r\n  }\r\n}\r\n\r\nfunction convertVideoLinksToPlayer(containerType) {\r\n  // Define container selectors for different message types\r\n  const containerSelectors = {\r\n    generalMessages: '.messages-content div',\r\n    chatlogsMessages: '.chat-logs-container',\r\n    personalMessages: '.messages-container-wrapper'\r\n  };\r\n\r\n  // Get the container selector based on the provided type\r\n  const containerSelector = containerSelectors[containerType];\r\n  if (!containerSelector) {\r\n    console.error('Invalid container type specified');\r\n    return;\r\n  }\r\n\r\n  // Select the container element\r\n  const container = document.querySelector(containerSelector);\r\n  if (!container) return;\r\n\r\n  // Find all unprocessed links inside the container\r\n  const links = container.querySelectorAll(\"a:not(.skipped):not(.processed-video)\");\r\n  if (!links.length) return;\r\n\r\n  links.forEach(link => {\r\n    const url = link.href;\r\n    if (!url) return;\r\n\r\n    // Get video details using our helper function\r\n    const videoInfo = getVideoInfo(url);\r\n    if (!videoInfo) return;\r\n\r\n    // Add media class if youtube or video\r\n    link.classList.add(\"media\");\r\n\r\n    // Check if the link's href includes a trusted domain\r\n    const { isTrusted, domain } = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isTrustedDomain)(url);\r\n\r\n    // For untrusted domains, add classes and update text before waiting for a click\r\n    if (!isTrusted) {\r\n      link.classList.add(\"skipped\");\r\n      link.textContent = `${videoExtensionEmoji} ${videoInfo.videoType} ${webDomainEmoji} Hostname (${domain}) ${untrustedEoji} Untrusted`;\r\n      link.addEventListener(\"click\", e => {\r\n        if (!link.classList.contains(\"processed-video\")) {\r\n          e.preventDefault();\r\n          link.classList.remove(\"skipped\");\r\n          processVideoLink(link, url, domain, videoInfo);\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    // For trusted links, process immediately\r\n    processVideoLink(link, url, domain, videoInfo);\r\n  });\r\n\r\n  function processVideoLink(link, url, domain, videoInfo) {\r\n    const { youtubeMatch, videoType, videoId } = videoInfo;\r\n    // Use the helper function to check for allowed video extensions\r\n    const videoCheck = isAllowedVideoExtension(url);\r\n    if (!youtubeMatch && !videoCheck.allowed) return;\r\n\r\n    // Add media and processed-video classes (if not already added)\r\n    link.classList.add(\"processed-video\");\r\n\r\n    // Create a wrapper div for better structure\r\n    const wrapper = document.createElement('div');\r\n    wrapper.classList.add(\"video-wrapper\");\r\n\r\n    // Create an appropriate embed element (iframe for YouTube, video for allowed formats)\r\n    let embedElement = document.createElement(youtubeMatch ? 'iframe' : 'video');\r\n    embedElement.classList.add(\"video-container\");\r\n\r\n    if (youtubeMatch) {\r\n      // Update link text and set YouTube embed\r\n      link.textContent = `${videoExtensionEmoji} ${videoType} ${webDomainEmoji} Hostname (${domain})`;\r\n      embedElement.src = `https://www.youtube.com/embed/${videoId}`;\r\n      embedElement.allowFullscreen = true;\r\n    } else {\r\n      // Update link text for MP4 videos\r\n      link.textContent = `${videoExtensionEmoji} ${videoType} ${webDomainEmoji} Hostname (${domain})`;\r\n      embedElement.src = url;\r\n      embedElement.controls = true;\r\n    }\r\n\r\n    // Set link attributes and insert elements\r\n    link.title = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isValidEncodedURL)(url) ? (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.decodeURL)(url) : url;\r\n    link.style.display = 'inline-flex';\r\n    link.parentNode.insertBefore(wrapper, link);\r\n    wrapper.append(link, embedElement);\r\n\r\n    // Scroll to the bottom of the container after processing links\r\n    (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.scrollMessagesToBottom)(containerType);\r\n  }\r\n\r\n  // Helper function to get video information based on the URL\r\n  function getVideoInfo(url) {\r\n    const youtubeMatch = url.match(/(?:shorts\\/|live\\/|watch\\?v=|youtu\\.be\\/)([a-zA-Z0-9_-]{11})/i);\r\n\r\n    if (youtubeMatch) {\r\n      const videoId = youtubeMatch[1];\r\n      const videoType = url.includes('shorts/') ? 'Shorts' :\r\n        url.includes('live/') ? 'Live' :\r\n          url.includes('watch?v=') ? 'Watch' :\r\n            url.includes('youtu.be/') ? 'Share' : 'YouTube';\r\n      return { youtubeMatch: true, videoId, videoType };\r\n    }\r\n\r\n    // Check if it's an MP4 or other video format\r\n    const extension = url.split('.').pop().toLowerCase();\r\n    if (allowedVideoExtensions.includes(extension)) {\r\n      return { youtubeMatch: false, videoType: `Video (${extension.toUpperCase()})` };\r\n    }\r\n\r\n    return false; // Return false if no match\r\n  }\r\n}\n\n//# sourceURL=webpack://tampermonkey-script/./src/modules/video-converter.js?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ \"./node_modules/css-loader/dist/cjs.js!./src/style.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://tampermonkey-script/./src/style.css?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;